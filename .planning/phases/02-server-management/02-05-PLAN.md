---
phase: 02-server-management
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/main/ipc/provisioning.ts
  - client/src/main/index.ts
  - client/src/renderer/src/pages/DeviceProvisioning.tsx
  - client/src/renderer/src/components/ProvisioningQR.tsx
  - client/src/renderer/src/App.tsx
  - shared/types/ipc-bridge.ts
  - client/src/preload/index.ts
autonomous: true
requirements:
  - SEC-12

must_haves:
  truths:
    - "Existing device can generate a QR code containing ephemeral X25519 public key + local IP + port"
    - "New device can scan the QR code and connect to the existing device over local TCP"
    - "Keypair transfer is encrypted with X25519 DH shared secret via HKDF-SHA256 + AES-256-GCM"
    - "No server involvement in the device provisioning process"
    - "TCP listener and ephemeral keys are destroyed immediately after transfer"
  artifacts:
    - path: "client/src/main/ipc/provisioning.ts"
      provides: "TCP listener, X25519 key exchange, encrypted keypair transfer"
      contains: "startProvisioning"
    - path: "client/src/renderer/src/pages/DeviceProvisioning.tsx"
      provides: "Device provisioning UI with QR display and scan-to-receive flow"
      contains: "DeviceProvisioning"
    - path: "client/src/renderer/src/components/ProvisioningQR.tsx"
      provides: "QR code rendering for provisioning"
      contains: "ProvisioningQR"
  key_links:
    - from: "client/src/renderer/src/pages/DeviceProvisioning.tsx"
      to: "client/src/main/ipc/provisioning.ts"
      via: "IPC bridge: window.united.provisioning.startProvisioning()"
      pattern: "startProvisioning"
    - from: "client/src/main/ipc/provisioning.ts"
      to: "Node.js net + crypto modules"
      via: "TCP listener and X25519 + AES-256-GCM"
      pattern: "createServer|diffieHellman"
---

<objective>
Implement SEC-12 device provisioning via QR code: existing device displays QR with ephemeral encryption key and local address, new device scans and receives encrypted keypair over local TCP.

Purpose: Users need to add new devices without server involvement, maintaining UNITED's sovereignty principle. QR-based local transfer is the most secure and user-friendly approach for co-located devices.

Output: IPC provisioning module with TCP listener and X25519 key exchange, provisioning UI with QR code display and receive flow, IPC bridge extensions.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-management/02-RESEARCH.md
@.planning/phases/02-server-management/02-CONTEXT.md
@.planning/phases/01-foundation/01-06-SUMMARY.md
@client/src/main/ipc/crypto.ts
@client/src/main/index.ts
@shared/types/ipc-bridge.ts
@client/src/preload/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: IPC provisioning module with TCP listener and crypto</name>
  <files>
    client/src/main/ipc/provisioning.ts
    client/src/main/index.ts
    shared/types/ipc-bridge.ts
    client/src/preload/index.ts
  </files>
  <action>
1. Create `client/src/main/ipc/provisioning.ts` implementing the SEC-12 protocol from Pattern 9 in research, using Node.js built-in modules only (no x25519-dalek needed on client):

   **Sender side (existing device):**
   - `startProvisioning()`:
     a. Generate ephemeral X25519 keypair using `crypto.generateKeyPairSync('x25519')`
     b. Start TCP server on random port using `net.createServer()`, bind to `0.0.0.0`
     c. Get local IP via `os.networkInterfaces()` (pick first non-internal IPv4 address)
     d. Return QR payload as JSON string: `{ "ip": "192.168.x.x", "port": 12345, "pk": "<ephemeral X25519 public key hex>" }`
   - TCP connection handler:
     a. Read first 32 bytes: new device's ephemeral X25519 public key
     b. Compute shared secret via `crypto.diffieHellman({ privateKey: ephemeralPriv, publicKey: receivedPub })`
     c. Derive encryption key via HKDF-SHA256: `crypto.hkdfSync('sha256', sharedSecret, 'united-device-provisioning', 'keypair-transfer', 32)`
     d. Read current Ed25519 private key + mnemonic words from local storage (via the existing crypto IPC module)
     e. Encrypt payload with AES-256-GCM (using derived key, random 12-byte IV): `{ privateKey: hex, mnemonic: string }`
     f. Send: 12 bytes IV + 16 bytes auth tag + ciphertext
     g. Wait for 32-byte MAC confirmation from new device
     h. Close TCP server, destroy ephemeral keys
   - `cancelProvisioning()`: Close TCP server, destroy keys.
   - Timeout: auto-cancel after 5 minutes if no connection.

   **Receiver side (new device):**
   - `receiveProvisioning(qrPayload: string)`:
     a. Parse QR JSON to get IP, port, pk (ephemeral public key)
     b. Generate own ephemeral X25519 keypair
     c. Connect to IP:port via `net.createConnection()`
     d. Send own ephemeral public key (32 bytes)
     e. Compute same shared secret via DH
     f. Derive same encryption key via HKDF-SHA256 (same parameters)
     g. Read IV (12 bytes) + auth tag (16 bytes) + ciphertext from TCP
     h. Decrypt with AES-256-GCM
     i. Send 32-byte HMAC-SHA256 confirmation (HMAC of decrypted payload using derived key)
     j. Store received keypair locally (reuse existing crypto module's storage functions)
     k. Close connection, destroy ephemeral keys
     l. Return success with public key fingerprint

2. Add IPC handlers to `client/src/main/index.ts`:
   - `united:provisioning:start` → calls startProvisioning(), returns QR payload
   - `united:provisioning:cancel` → calls cancelProvisioning()
   - `united:provisioning:receive` → calls receiveProvisioning(qrPayload)

3. Update `shared/types/ipc-bridge.ts` to add provisioning methods to the UnitedAPI interface:
   ```typescript
   provisioning: {
     startProvisioning: () => Promise<{ qrPayload: string }>
     cancelProvisioning: () => Promise<void>
     receiveProvisioning: (qrPayload: string) => Promise<{ fingerprint: string }>
   }
   ```

4. Update `client/src/preload/index.ts` to expose provisioning IPC methods via contextBridge.
  </action>
  <verify>
Verify TypeScript compilation: `cd /c/Users/matts/UNITED/client && npx tsc --noEmit` (or appropriate build command). Check that Node.js `crypto.generateKeyPairSync('x25519')` and `crypto.diffieHellman` are available in the target Node.js version. The full protocol flow cannot be tested without two Electron instances, but compilation and type checking should pass.
  </verify>
  <done>Provisioning IPC module compiles with TCP listener, X25519 key exchange, HKDF key derivation, and AES-256-GCM encryption. IPC bridge exposes startProvisioning, cancelProvisioning, and receiveProvisioning. Preload exposes methods via contextBridge. No server involvement.</done>
</task>

<task type="auto">
  <name>Task 2: Device provisioning UI (QR display and receive flow)</name>
  <files>
    client/src/renderer/src/pages/DeviceProvisioning.tsx
    client/src/renderer/src/components/ProvisioningQR.tsx
    client/src/renderer/src/App.tsx
  </files>
  <action>
1. Create `client/src/renderer/src/components/ProvisioningQR.tsx`:
   - Receives `qrPayload` string as prop
   - Renders QR code using `qrcode.react` (already in project from TOTP enrollment)
   - Large QR code centered on screen with dark background
   - Status text below: "Scan this QR code with your new device"
   - Cancel button below

2. Create `client/src/renderer/src/pages/DeviceProvisioning.tsx`:
   - Two-mode component: "Send" mode (existing device) and "Receive" mode (new device)

   **Send mode (existing device has identity):**
   - "Transfer Identity to New Device" heading
   - "Start Transfer" button → calls `window.united.provisioning.startProvisioning()`
   - On success, shows ProvisioningQR component with the QR payload
   - Status indicator: "Waiting for new device to connect..."
   - On connection + successful transfer: "Transfer complete! Your new device is ready."
   - Cancel button calls `window.united.provisioning.cancelProvisioning()`
   - Auto-cancel after 5 minutes with message "Transfer timed out"

   **Receive mode (new device, no identity yet):**
   - Shown on Welcome page as an alternative to Create/Recover
   - "Transfer from Existing Device" option
   - Text input for QR payload (since Electron desktop can't scan QR with camera — user would need to type/paste the payload, or we detect if a camera is available). NOTE: For v1, support manual entry of the QR payload text. Camera scanning can be added later. The QR code is designed to be short enough to type if needed (IP + port + 64-char hex key).
   - Alternatively: provide a simple text code that the user can enter manually (display the QR payload in a copiable format on the sending device alongside the QR).
   - "Connect" button → calls `window.united.provisioning.receiveProvisioning(payload)`
   - On success: redirect to main app with transferred identity

3. Update `client/src/renderer/src/App.tsx`:
   - Add route for DeviceProvisioning page
   - Accessible from Welcome page (as "Transfer from Device" option alongside Create/Recover)
   - Also accessible from Settings for existing users who want to provision a new device

   Follow existing component patterns from Phase 1 (dark theme, Tailwind classes, consistent spacing). The page follows the same layout as CreateIdentity/RecoverIdentity.
  </action>
  <verify>
Verify the client builds without errors: `cd /c/Users/matts/UNITED/client && npx electron-vite build` (or appropriate build command). Visually verify: the DeviceProvisioning page renders with Send/Receive modes, QR code displays correctly in Send mode, and the input field works in Receive mode.
  </verify>
  <done>DeviceProvisioning page renders with Send and Receive modes. QR code displays via qrcode.react. Manual text input fallback for Receive mode. Route added to App.tsx. Accessible from Welcome page and Settings.</done>
</task>

</tasks>

<verification>
- Client compiles with provisioning module and UI components
- ProvisioningQR renders a scannable QR code
- IPC bridge correctly exposes all 3 provisioning methods
- Send mode generates QR payload with local IP + port + ephemeral public key
- Receive mode accepts QR payload and calls receiveProvisioning
- No server involvement in any provisioning code path
</verification>

<success_criteria>
SEC-12 device provisioning is implemented end-to-end: existing device generates QR with ephemeral X25519 key and local address, new device connects via TCP, keypair is transferred encrypted. UI supports both send and receive modes. No server involvement.
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-management/02-05-SUMMARY.md`
</output>
