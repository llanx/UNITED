---
phase: 02-server-management
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/main/provisioning/server.ts
  - client/src/main/provisioning/qr.ts
  - client/src/renderer/src/components/provisioning/DeviceProvisioningModal.tsx
  - client/src/renderer/src/components/provisioning/QRScanner.tsx
  - client/src/preload/index.ts
  - shared/types/ipc-bridge.ts
autonomous: true
requirements:
  - SEC-12

must_haves:
  truths:
    - "Existing device can display a QR code containing an ephemeral encryption key and local network address"
    - "New device can scan the QR code and connect to the existing device over local TCP"
    - "Identity keypair is transferred encrypted via AES-256-GCM over the local connection"
    - "No server is involved in the device provisioning transfer"
    - "After provisioning, the new device has the full current keypair and can authenticate to servers"
  artifacts:
    - path: "client/src/main/provisioning/server.ts"
      provides: "TCP listener for receiving device provisioning connections"
      contains: "startProvisioningServer"
    - path: "client/src/main/provisioning/qr.ts"
      provides: "QR code content generation with ephemeral key and address"
      contains: "generateProvisioningQR"
    - path: "client/src/renderer/src/components/provisioning/DeviceProvisioningModal.tsx"
      provides: "UI for initiating and completing device provisioning"
      contains: "DeviceProvisioningModal"
  key_links:
    - from: "client/src/renderer/src/components/provisioning/DeviceProvisioningModal.tsx"
      to: "client/src/main/provisioning/server.ts"
      via: "IPC bridge for starting/stopping provisioning server"
      pattern: "window.united.provisioning"
    - from: "client/src/main/provisioning/server.ts"
      to: "client/src/main/provisioning/qr.ts"
      via: "Server generates QR content with its listen address"
      pattern: "generateProvisioningQR"
---

<objective>
Implement SEC-12 device provisioning: QR code display on existing device, local TCP connection, encrypted keypair transfer to new device, with no server involvement.

Purpose: Users need to set up UNITED on a new device without re-entering their mnemonic or relying on any server. QR-based local transfer is the fastest and most secure provisioning method, consistent with UNITED's "no third party touches your data" principle.

Output: Provisioning TCP server, QR code generation, encrypted transfer protocol, client UI for both sending and receiving sides.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-management/02-CONTEXT.md
@.planning/phases/02-server-management/02-RESEARCH.md
@.planning/phases/01-foundation/01-06-SUMMARY.md
@shared/types/ipc-bridge.ts
@client/src/preload/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Provisioning protocol implementation (main process)</name>
  <files>
    client/src/main/provisioning/server.ts
    client/src/main/provisioning/qr.ts
    client/src/preload/index.ts
    shared/types/ipc-bridge.ts
  </files>
  <action>
  Implement the SEC-12 device provisioning protocol in the Electron main process.

  Per user decision: "QR code contains a short-lived encryption key + local network address. Devices connect directly over local network, transfer full current keypair encrypted. No server involvement."
  Per research recommendation: "Skip mDNS for v1. Encode the IP address and port directly in the QR code."

  1. Create `client/src/main/provisioning/qr.ts`:
     - `generateProvisioningQR()`:
       - Generate ephemeral X25519 keypair (using sodium-native or @noble/curves)
       - Start TCP server on random port (Node.js `net.createServer()`)
       - Get local IP address (use `os.networkInterfaces()` to find non-internal IPv4)
       - Return QR content as JSON string: `{ "ip": "192.168.x.x", "port": 12345, "pubkey": "<hex ephemeral X25519 public key>", "v": 1 }`
       - Include protocol version for forward compatibility
       - QR content should be compact enough for a standard QR code

  2. Create `client/src/main/provisioning/server.ts`:
     - **Sending side (existing device):**
       - `startProvisioningServer(identity: { secretKey, publicKey, mnemonic? })`:
         - Create ephemeral X25519 keypair
         - Start TCP server on random available port (0 for OS-assigned)
         - Set timeout (60 seconds) -- auto-close if no connection received
         - On connection:
           a. Read new device's ephemeral X25519 public key (first 32 bytes)
           b. Compute shared secret via X25519 key exchange
           c. Derive encryption key via HKDF-SHA256 (shared secret, salt = "united-provision-v1")
           d. Encrypt identity payload with XChaCha20-Poly1305 (per client Phase 1 decision: XChaCha20 not AES-GCM for client-side)
           e. Payload: JSON { ed25519_secret_key (hex), ed25519_public_key (hex), encrypted_private_key_blob (the passphrase-encrypted blob) }
           f. Send: [24-byte nonce][encrypted payload]
           g. Wait for ACK byte (0x01) from new device
           h. Close connection and destroy ephemeral keys
         - Return: { qrContent: string, port: number, cleanup: () => void }

     - **Receiving side (new device):**
       - `connectToProvisioningDevice(qrData: { ip, port, pubkey })`:
         - Generate own ephemeral X25519 keypair
         - Connect TCP to ip:port
         - Send own ephemeral public key (32 bytes)
         - Read nonce (24 bytes) + encrypted payload
         - Compute shared secret via X25519 key exchange with server's pubkey from QR
         - Derive decryption key via HKDF-SHA256 (same parameters)
         - Decrypt with XChaCha20-Poly1305
         - Parse JSON payload
         - Send ACK byte (0x01)
         - Close connection and destroy ephemeral keys
         - Return: decrypted identity data
         - Store identity locally using existing identity storage from Phase 1

  3. Update `shared/types/ipc-bridge.ts`:
     - Add provisioning IPC methods to the UnitedAPI interface:
       ```typescript
       provisioning: {
         startProvisioning: () => Promise<{ qrContent: string }>
         cancelProvisioning: () => Promise<void>
         scanAndConnect: (qrData: string) => Promise<{ success: boolean; fingerprint?: string }>
       }
       ```

  4. Update `client/src/preload/index.ts`:
     - Add IPC handlers for provisioning methods (invoke main process handlers)
     - Expose through contextBridge as `window.united.provisioning`
  </action>
  <verify>
  - TypeScript compiles: `npx tsc --noEmit` in client directory
  - Unit test: Start provisioning server, connect locally, verify encrypted transfer completes
  - Verify QR content is valid JSON with ip, port, pubkey fields
  - Verify ephemeral keys are destroyed after transfer
  </verify>
  <done>
  Provisioning protocol implemented: ephemeral X25519 key exchange over local TCP, XChaCha20-Poly1305 encrypted identity transfer, 60-second timeout, QR content generation with local IP and port. IPC bridge extended with provisioning methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Device provisioning UI components</name>
  <files>
    client/src/renderer/src/components/provisioning/DeviceProvisioningModal.tsx
    client/src/renderer/src/components/provisioning/QRScanner.tsx
  </files>
  <action>
  Create the UI for both sides of device provisioning.

  1. Create `DeviceProvisioningModal.tsx`:
     - Modal dialog with two tabs/modes:
       a. **"Share Identity" (existing device):**
          - Button: "Generate QR Code"
          - On click: call `window.united.provisioning.startProvisioning()`
          - Display QR code using qrcode.react (already in project) with the returned qrContent
          - Show instruction: "Scan this QR code with your new device"
          - Show countdown timer (60 seconds)
          - Show status: "Waiting for connection..." -> "Transferring..." -> "Complete!"
          - Cancel button calls `window.united.provisioning.cancelProvisioning()`

       b. **"Set Up From Existing Device" (new device):**
          - Camera-based QR scanner using QRScanner component
          - On scan: parse QR JSON, call `window.united.provisioning.scanAndConnect(qrData)`
          - Show status: "Connecting..." -> "Receiving identity..." -> "Complete!"
          - On success: show fingerprint confirmation and "Done" button
          - On error: show error message with retry option

     - Dark theme styling consistent with existing client components
     - Accessible from: Settings > Device Provisioning, or from the Welcome/Recovery screen

  2. Create `QRScanner.tsx`:
     - Use browser `navigator.mediaDevices.getUserMedia({ video: true })` for camera access
     - Use a lightweight QR decoding library (jsQR or html5-qrcode -- check what's available or add html5-qrcode)
     - Render camera feed in a video element
     - Continuously scan frames for QR codes
     - On successful decode: call onScan callback with decoded string
     - Handle permissions: show message if camera access denied
     - Include a manual entry fallback: text input where user can type the QR content JSON (for cases where camera doesn't work)

  NOTE: If html5-qrcode is not already a dependency, add it to client/package.json. This is the most reliable browser-based QR scanner. Alternatively, use `@aspect-build/qrcode-reader` or `jsqr` -- use Claude's discretion on the simplest working option.
  </action>
  <verify>
  - Client builds: `npm run build` in client directory
  - DeviceProvisioningModal renders with both tabs
  - QR code displays when provisioning is started
  - QR scanner accesses camera (manual test -- automated camera test not feasible)
  - Manual entry fallback works for QR content
  </verify>
  <done>
  Device provisioning UI complete: modal with share/receive modes, QR code display via qrcode.react, camera-based QR scanner with manual entry fallback, status indicators, 60-second timeout countdown. Both sides of the provisioning flow accessible from UI.
  </done>
</task>

</tasks>

<verification>
- Client builds without errors
- Provisioning server starts and generates valid QR content
- Two local clients can complete the full provisioning flow (manual test)
- Encrypted transfer uses XChaCha20-Poly1305, not plaintext
- Ephemeral keys destroyed after transfer
- 60-second timeout closes provisioning server if no connection
- QR scanner works with camera or manual JSON entry
</verification>

<success_criteria>
- QR code contains ephemeral X25519 public key + local IP + port
- Devices connect via direct TCP on local network (no server involvement)
- Identity transferred encrypted with derived key from X25519 exchange
- 60-second timeout prevents indefinite listening
- UI supports both sending (QR display) and receiving (QR scan) flows
- Manual entry fallback when camera is unavailable
- Transfer includes current keypair (handles key rotation correctly)
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-management/02-05-SUMMARY.md`
</output>
