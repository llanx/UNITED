---
phase: 02-server-management
plan: 04
type: tdd
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - server/src/moderation/mod.rs
  - server/src/moderation/kick.rs
  - server/src/moderation/ban.rs
  - server/src/invite/mod.rs
  - server/src/invite/generate.rs
  - server/src/invite/validate.rs
  - server/src/invite/landing.rs
  - server/src/routes.rs
  - server/src/main.rs
  - server/src/ws/handler.rs
  - server/src/identity/registration.rs
  - server/tests/moderation_test.rs
  - server/tests/invite_test.rs
autonomous: true
requirements:
  - SRVR-05
  - SRVR-06
  - SRVR-08
  - SRVR-09

must_haves:
  truths:
    - "Server admin can kick a user (force-close WS, user can rejoin with valid invite)"
    - "Server admin can ban a user with optional reason and optional duration"
    - "Banned user's existing WS connections are force-closed with 4003 code and ban reason"
    - "Banned user cannot reconnect (ban check on WS connect and REST auth)"
    - "Temporary bans auto-expire (lazy cleanup on read)"
    - "Server admin can generate invite links with optional expiration and max uses"
    - "Invite link URL serves an HTML landing page with server info"
    - "New user can join via invite code (atomic use_count increment, @everyone auto-assign)"
    - "Invite-only mode rejects registration without a valid invite code"
  artifacts:
    - path: "server/src/moderation/kick.rs"
      provides: "Kick endpoint with WS force-close"
      contains: "kick_user"
    - path: "server/src/moderation/ban.rs"
      provides: "Ban/unban endpoints with force-close and lazy expiry check"
      contains: "ban_user"
    - path: "server/src/invite/generate.rs"
      provides: "Invite creation endpoint"
      contains: "create_invite"
    - path: "server/src/invite/validate.rs"
      provides: "Atomic invite consumption during registration"
      contains: "consume_invite"
    - path: "server/src/invite/landing.rs"
      provides: "HTML landing page at /invite/{code}"
      contains: "invite_landing_page"
    - path: "server/tests/moderation_test.rs"
      provides: "Integration tests for kick and ban"
      contains: "test"
    - path: "server/tests/invite_test.rs"
      provides: "Integration tests for invite generation and consumption"
      contains: "test"
  key_links:
    - from: "server/src/moderation/ban.rs"
      to: "server/src/ws/broadcast.rs"
      via: "force_close_user with 4003 code on ban"
      pattern: "force_close_user.*4003"
    - from: "server/src/moderation/ban.rs"
      to: "server/src/ws/handler.rs"
      via: "ban check on WS connect"
      pattern: "check_ban"
    - from: "server/src/invite/validate.rs"
      to: "server/src/identity/registration.rs"
      via: "consume_invite called during registration"
      pattern: "consume_invite"
---

<objective>
Implement moderation tools (kick/ban) and invite system (generation, consumption, landing page) with full integration test coverage.

Purpose: Admins need moderation tools to manage their community, and invite links are how new users discover and join servers. Kick provides a soft warning, ban removes access with optional duration. Invite links with landing pages are the primary onboarding mechanism.

Output: Kick/ban endpoints with WS force-close, ban checks on connect, invite generation with expiration/use-count limits, atomic invite consumption during registration, HTML landing page, and integration tests for both systems.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-management/02-RESEARCH.md
@.planning/phases/02-server-management/02-CONTEXT.md
@.planning/phases/02-server-management/02-01-SUMMARY.md
@.planning/phases/02-server-management/02-02-SUMMARY.md
@.planning/phases/02-server-management/02-03-SUMMARY.md
@server/src/roles/permissions.rs
@server/src/ws/broadcast.rs
@server/src/ws/handler.rs
@server/src/identity/registration.rs
@shared/proto/moderation.proto
@shared/proto/invite.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for moderation and invites</name>
  <files>
    server/tests/moderation_test.rs
    server/tests/invite_test.rs
  </files>
  <action>
Write integration tests using the existing `start_test_server()` pattern.

**Moderation tests** (server/tests/moderation_test.rs):

1. `test_kick_user` — Register owner + second user. Owner POSTs /api/moderation/kick with {user_id}. Assert 200. Verify kicked user can still re-register (kick is soft removal).

2. `test_kick_requires_kick_members_permission` — Register as non-privileged user, attempt kick, assert 403.

3. `test_ban_user` — Register owner + second user. Owner POSTs /api/moderation/ban with {user_id, reason: "spam"}. Assert 200 with ban record. Verify banned user cannot authenticate (GET /api/auth/challenge with their fingerprint should succeed, but verify should fail with ban info, OR a REST endpoint returns 403 with ban reason).

4. `test_ban_with_expiration` — Ban user with expires_at 2 seconds in the future. Verify ban is active. Wait 3 seconds. Verify ban has expired (user can authenticate again via lazy cleanup).

5. `test_cannot_ban_owner` — Attempt to ban the server owner, assert 403 "Cannot ban the server owner".

6. `test_unban_user` — Ban a user, then POST /api/moderation/unban with {fingerprint}. Assert 200. Verify user can authenticate again.

7. `test_ban_includes_reason` — Ban with reason "spamming", verify the ban record in /api/moderation/bans list includes the reason.

**Invite tests** (server/tests/invite_test.rs):

8. `test_create_invite` — Owner POSTs /api/invites with {max_uses: 5, expires_at: <1 hour from now>}. Assert 201 with invite object containing 8-char code.

9. `test_invite_landing_page` — Create invite, GET /invite/{code} (browser endpoint, no auth). Assert 200 with HTML containing server name and "Open in UNITED" link.

10. `test_join_via_invite` — Create invite, new user registers with invite_code parameter. Assert registration succeeds. Verify user has @everyone role. Verify invite use_count incremented.

11. `test_invite_max_uses_enforced` — Create invite with max_uses=1. Use it once (register). Try to use it again (register second user). Assert second registration fails with "Invalid, expired, or exhausted invite code".

12. `test_invite_expiration_enforced` — Create invite with expires_at 1 second from now. Wait 2 seconds. Try to use it. Assert failure.

13. `test_invite_only_mode_rejects_without_code` — Set registration mode to invite-only. Attempt registration without invite code. Assert rejection. Then register with valid invite code. Assert success.

14. `test_delete_invite` — Create invite, DELETE /api/invites/{code}. Assert 200. Verify invite is no longer valid (landing page returns 404).
  </action>
  <verify>
Run `cd /c/Users/matts/UNITED/server && /c/Users/matts/.cargo/bin/cargo test --test moderation_test --test invite_test -- --nocapture 2>&1 | head -80` — tests should compile but FAIL (RED phase).
  </verify>
  <done>14 integration tests compile and fail with expected errors. Tests cover kick, ban (permanent + temporary + reason), unban, invite CRUD, invite consumption, max uses, expiration, invite-only mode, and landing page.</done>
</task>

<task type="auto">
  <name>Task 2: Implement moderation (kick/ban) and invites</name>
  <files>
    server/src/moderation/mod.rs
    server/src/moderation/kick.rs
    server/src/moderation/ban.rs
    server/src/invite/mod.rs
    server/src/invite/generate.rs
    server/src/invite/validate.rs
    server/src/invite/landing.rs
    server/src/routes.rs
    server/src/main.rs
    server/src/ws/handler.rs
    server/src/identity/registration.rs
  </files>
  <action>
**Moderation module:**

1. Create `server/src/moderation/mod.rs` with `pub mod kick; pub mod ban;`.

2. Create `server/src/moderation/kick.rs`:
   - `POST /api/moderation/kick` — require_permission(KICK_MEMBERS). Look up target user. Cannot kick the owner (return 403). Force-close all WebSocket connections for the user with close code 4004 and reason "You have been kicked from this server". Remove non-default role assignments from user_roles (keep @everyone). Do NOT delete the user row. Broadcast UserKickedEvent. Return 200.

3. Create `server/src/moderation/ban.rs`:
   - `POST /api/moderation/ban` — require_permission(BAN_MEMBERS). Use exact code pattern from Example 3 in research. Look up target user. Cannot ban owner (403). INSERT OR REPLACE into bans table with fingerprint, banned_by (claimer), optional reason, optional expires_at, created_at. Force-close all WS connections with 4003 and reason (or default "You have been banned from this server"). Broadcast UserBannedEvent. Return 200 with ban_id.
   - `POST /api/moderation/unban` — require_permission(BAN_MEMBERS). Delete from bans WHERE fingerprint = ?. Broadcast UserUnbannedEvent. Return 200.
   - `GET /api/moderation/bans` — require_permission(BAN_MEMBERS). List all active bans (non-expired). Include lazy cleanup of expired bans.
   - `pub fn check_ban(conn: &rusqlite::Connection, fingerprint: &str) -> Option<BanInfo>` — lazy delete expired bans, then check for active ban. Use exact code from Pattern 6 in research. This function is called from the WS handler on connect.

4. Update `server/src/ws/handler.rs`:
   - In the ws_upgrade handler, AFTER JWT validation and BEFORE accepting the WS connection, check if the user is banned by calling `check_ban()` with their fingerprint. If banned, reject the WS upgrade with 4003 close code and ban reason. This prevents banned users from establishing new WS connections.

**Invite module:**

5. Create `server/src/invite/mod.rs` with `pub mod generate; pub mod validate; pub mod landing;`.

6. Create `server/src/invite/generate.rs`:
   - `POST /api/invites` — require_permission(ADMIN). Generate 8-char alphanumeric invite code using Pattern 7 from research (rand 0.9 API: rand::rng() and random_range()). Insert into invites table with created_by, optional max_uses, optional expires_at. Return 201 with full invite object.
   - `DELETE /api/invites/{code}` — require_permission(ADMIN). Delete from invites. Return 200.
   - `GET /api/invites` — require_permission(ADMIN). List all invites with usage stats.

7. Create `server/src/invite/validate.rs`:
   - `pub fn consume_invite(conn: &rusqlite::Connection, code: &str) -> Result<(), (StatusCode, String)>` — Use atomic SQL from Example 2 in research: `UPDATE invites SET use_count = use_count + 1 WHERE code = ?1 AND (expires_at IS NULL OR expires_at > ?2) AND (max_uses IS NULL OR use_count < max_uses)`. Check rows_affected; if 0, return error. This function is called from the registration handler.

8. Create `server/src/invite/landing.rs`:
   - `GET /invite/{code}` — PUBLIC endpoint (no auth). Validate invite exists and is not expired/exhausted. Query server name and description from server_settings. Return HTML landing page using Pattern 8 from research (inline HTML with html_escape helper). Include "Open in UNITED" deep link (`united://invite/{code}`) and GitHub releases download link.

9. Update `server/src/identity/registration.rs`:
   - When registration_mode is "invite_only" (or a new mode check), require an invite_code parameter. Call consume_invite() before creating the user row. If consume fails, reject registration.
   - When registration_mode is "open", invite_code is optional. If provided, consume it (to track usage). If not provided, allow registration without invite.

10. Add `pub mod moderation; pub mod invite;` to server/src/main.rs.

11. Wire all new routes into `server/src/routes.rs`:
    - Moderation routes: POST /api/moderation/kick, POST /api/moderation/ban, POST /api/moderation/unban, GET /api/moderation/bans
    - Invite routes: POST /api/invites, GET /api/invites, DELETE /api/invites/{code}
    - Landing page: GET /invite/{code} (public, no auth, no rate limiting needed beyond default)
    - All API routes behind JWT auth except landing page.
  </action>
  <verify>
Run `cd /c/Users/matts/UNITED/server && /c/Users/matts/.cargo/bin/cargo test --test moderation_test --test invite_test -- --nocapture` — all 14 tests should PASS. Run `cargo test` for full suite — all Phase 1 + Phase 2 tests pass.
  </verify>
  <done>Kick force-closes WS with 4004, does not delete user. Ban stores record and force-closes WS with 4003 and reason. Temporary bans expire lazily. Ban check on WS connect prevents reconnection. Invite codes are 8-char alphanumeric with atomic consumption. Landing page serves HTML with server info. Registration supports invite-only mode. All 14 tests pass.</done>
</task>

</tasks>

<verification>
- `cargo test` passes all tests (full suite)
- Kicked user retains their identity and can rejoin
- Banned user cannot authenticate or establish WS connection
- Ban with reason displays reason in 4003 close
- Temporary ban expires after duration
- Invite with max_uses enforced atomically (no race condition)
- Invite expiration prevents use after time
- Landing page renders with server name and description
- Invite-only mode rejects registration without code
</verification>

<success_criteria>
Server admin can kick and ban users with proper enforcement. Invite system works end-to-end: generate, landing page, consume during registration, enforce limits. 14+ integration tests pass. No regressions in existing tests.
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-management/02-04-SUMMARY.md`
</output>
