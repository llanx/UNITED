---
phase: 02-server-management
plan: 04
type: tdd
wave: 3
depends_on: ["02-01", "02-02", "02-03"]
files_modified:
  - server/src/moderation/mod.rs
  - server/src/moderation/kick.rs
  - server/src/moderation/ban.rs
  - server/src/invite/mod.rs
  - server/src/invite/generate.rs
  - server/src/invite/validate.rs
  - server/src/invite/landing.rs
  - server/src/ws/handler.rs
  - server/src/auth/middleware.rs
  - server/tests/moderation_test.rs
  - server/tests/invite_test.rs
autonomous: true
requirements:
  - SRVR-05
  - SRVR-06
  - SRVR-08
  - SRVR-09

must_haves:
  truths:
    - "Admin can kick a user, closing their WebSocket connections, and the kicked user can rejoin with a valid invite"
    - "Admin can ban a user with optional reason and duration, force-closing their WS and preventing reconnection"
    - "Temporary bans auto-expire: lazy cleanup on next connection attempt clears expired bans"
    - "Admin can generate invite links with optional expiration and use count limits"
    - "A new user can join the server via invite code, getting auto-assigned @everyone role and seeing the channel list"
    - "Invite landing page at /invite/{code} shows server info with Open in UNITED button"
    - "Ban check runs on WebSocket upgrade and REST auth to prevent banned user access"
  artifacts:
    - path: "server/src/moderation/kick.rs"
      provides: "Kick endpoint that closes WS connections"
      contains: "kick_user"
    - path: "server/src/moderation/ban.rs"
      provides: "Ban, unban endpoints with lazy expiration cleanup"
      contains: "ban_user"
    - path: "server/src/invite/generate.rs"
      provides: "Invite creation with expiration and use count"
      contains: "create_invite"
    - path: "server/src/invite/validate.rs"
      provides: "Invite validation and consumption on join"
      contains: "validate_invite"
    - path: "server/src/invite/landing.rs"
      provides: "HTML landing page for invite links"
      contains: "invite_landing_page"
    - path: "server/tests/moderation_test.rs"
      provides: "Integration tests for kick and ban"
      contains: "test_kick_user"
    - path: "server/tests/invite_test.rs"
      provides: "Integration tests for invite generation and join"
      contains: "test_create_invite"
  key_links:
    - from: "server/src/moderation/ban.rs"
      to: "server/src/ws/mod.rs"
      via: "Force-close banned user connections via ConnectionRegistry"
      pattern: "connections.*get.*send.*Close"
    - from: "server/src/moderation/ban.rs"
      to: "server/src/ws/handler.rs"
      via: "Ban check on WS upgrade prevents reconnection"
      pattern: "check_ban"
    - from: "server/src/invite/validate.rs"
      to: "server/src/db/migrations.rs"
      via: "Atomic use_count increment prevents over-use"
      pattern: "use_count = use_count \\+ 1.*WHERE.*use_count < max_uses"
    - from: "server/src/invite/validate.rs"
      to: "server/src/identity/registration.rs"
      via: "Join via invite reuses registration flow"
      pattern: "invite_code"
---

<objective>
Implement moderation (kick/ban/unban with real-time WS force-close), invite generation with expiration and use limits, invite-based server joining, and the invite landing page.

Purpose: Moderation gives admins control over their community. Invites are the gateway for new members. Together they complete the membership management cycle: invite users in, manage their behavior, and remove bad actors.

Output: Kick/ban/unban endpoints, ban check middleware, invite CRUD, join-via-invite flow, HTML landing page, and integration tests.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-server-management/02-CONTEXT.md
@.planning/phases/02-server-management/02-RESEARCH.md
@.planning/phases/02-server-management/02-01-SUMMARY.md
@.planning/phases/02-server-management/02-02-SUMMARY.md
@.planning/phases/02-server-management/02-03-SUMMARY.md
@server/src/moderation/mod.rs
@server/src/invite/mod.rs
@server/src/ws/mod.rs
@server/src/ws/handler.rs
@server/src/ws/actor.rs
@server/src/auth/middleware.rs
@server/src/identity/registration.rs
@server/src/roles/permissions.rs
@server/src/state.rs
@server/tests/auth_test.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integration tests for moderation and invites (RED phase)</name>
  <files>
    server/tests/moderation_test.rs
    server/tests/invite_test.rs
  </files>
  <action>
  Write integration tests FIRST (TDD RED phase).

  **Moderation tests** (server/tests/moderation_test.rs):

  1. `test_kick_user` -- Owner registers, second user registers, owner POSTs /api/moderation/kick with { user_id }. Expect 200. Verify kicked user's WebSocket is closed (if connected). Verify kicked user can still re-register or reconnect.

  2. `test_kick_requires_permission` -- Non-admin user tries to kick. Expect 403.

  3. `test_ban_user_permanent` -- Owner bans second user via POST /api/moderation/ban with { user_id, reason: "Spam" }. Expect 200. Banned user tries to establish a new WebSocket connection. Expect WS close code 4003.

  4. `test_ban_user_temporary` -- Owner bans user with { user_id, duration_seconds: 60 }. Expect 200. Verify ban record has expires_at set.

  5. `test_unban_user` -- Owner bans then unbans user via POST /api/moderation/unban with { user_id }. Expect 200. User should be able to reconnect.

  6. `test_ban_list` -- Ban a user, then GET /api/moderation/bans. Expect list including the ban with reason and expiration.

  7. `test_ban_check_on_auth` -- Ban a user, then try to verify a challenge for that user. Expect auth rejection (either at challenge verify or as a specific banned response).

  **Invite tests** (server/tests/invite_test.rs):

  1. `test_create_invite` -- Owner POSTs /api/invites with { max_uses: 5, expires_in_seconds: 3600 }. Expect 201 with invite JSON (code, max_uses, expires_at, use_count: 0).

  2. `test_create_invite_unlimited` -- POST /api/invites with no max_uses or expiration. Expect 201 with null max_uses and null expires_at.

  3. `test_list_invites` -- Create invites, GET /api/invites. Expect list of all invites.

  4. `test_delete_invite` -- Create invite, DELETE /api/invites/{code}. Expect 200.

  5. `test_join_via_invite` -- Create invite, new user POSTs /api/invite/join with { invite_code, fingerprint, public_key, display_name, genesis_signature, encrypted_blob }. Expect 200 with auth tokens. Invite use_count incremented. User has @everyone role.

  6. `test_join_expired_invite` -- Create invite with expires_in_seconds: 1, wait 2 seconds, try join. Expect 400 ("Invite expired").

  7. `test_join_max_uses_exceeded` -- Create invite with max_uses: 1, join once (success), try second join. Expect 400 ("Invite has been used up").

  8. `test_invite_landing_page` -- GET /invite/{code} (raw HTTP, not /api/). Expect 200 with HTML content containing server name and "Open in UNITED" text.

  9. `test_invite_requires_admin` -- Non-admin tries POST /api/invites. Expect 403. (Invite creation requires ADMIN per context -- actually, it should require a specific permission. Per the minimal permission set, ADMIN is the gatekeeper for invite creation.)

  10. `test_banned_user_cannot_join` -- Ban a fingerprint, try joining with that fingerprint via invite. Expect rejection.

  Commit: `test(02-04): add failing moderation and invite integration tests`
  </action>
  <verify>
  `cargo test --test moderation_test --test invite_test` -- tests compile but FAIL (RED state).
  </verify>
  <done>
  17 integration tests written across 2 test files. All compile but fail because moderation and invite endpoints are not yet implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Moderation implementation (kick, ban, unban, ban middleware)</name>
  <files>
    server/src/moderation/mod.rs
    server/src/moderation/kick.rs
    server/src/moderation/ban.rs
    server/src/ws/handler.rs
    server/src/auth/middleware.rs
  </files>
  <action>
  1. Create `server/src/moderation/kick.rs`:
     - `POST /api/moderation/kick` handler:
       - Requires KICK_MEMBERS permission
       - Accepts { user_id }
       - Per user decision: "Kick = soft removal -- kicked user can rejoin immediately with a valid invite"
       - Per research: Do NOT delete user row. Close their WS connections + remove role assignments (except @everyone).
       - Look up user's connections in ConnectionRegistry, send Close frame with code 4004 (kicked) to each
       - Delete from user_roles WHERE user_id = X AND role_id NOT IN (SELECT id FROM roles WHERE is_default = 1)
       - Return 200

  2. Create `server/src/moderation/ban.rs`:
     - `POST /api/moderation/ban` handler:
       - Requires BAN_MEMBERS permission
       - Accepts { user_id, reason (optional), duration_seconds (optional, 0 or absent = permanent) }
       - Look up user's fingerprint from users table
       - Insert into bans table: { id: UUIDv7, fingerprint, banned_by: claims.sub, reason, expires_at: now + duration or NULL, created_at: now }
       - Per user decision: "Clear ban notice -- uses existing 4003 WebSocket close code"
       - Force-close all WS connections for the banned user via ConnectionRegistry with close code 4003 and reason
       - Broadcast UserBanned WS event to all other connected clients
       - Return 200

     - `POST /api/moderation/unban` handler:
       - Requires BAN_MEMBERS permission
       - Accepts { user_id }
       - Look up fingerprint, DELETE FROM bans WHERE fingerprint = X
       - Broadcast UserUnbanned WS event
       - Return 200

     - `GET /api/moderation/bans` handler:
       - Requires BAN_MEMBERS permission
       - Return all active bans (non-expired) with ban info
       - Lazy cleanup: DELETE expired bans during query (per Research Pattern 5)

     - `check_ban(conn: &Connection, fingerprint: &str) -> Option<BanInfo>`:
       - Public helper function for ban checking
       - Lazy expiration: DELETE expired bans for this fingerprint first, then check for active ban
       - Return Some(BanInfo) if banned, None if not

  3. Update `server/src/ws/handler.rs`:
     - In the WebSocket upgrade handler, AFTER JWT validation and BEFORE upgrading the connection:
       - Call `check_ban(conn, fingerprint)` using the fingerprint from JWT claims
       - If banned, return WS close code 4003 with ban reason
     - Per Pitfall 6: "After inserting a ban, immediately look up the banned user's connections and send a Close frame"

  4. Update `server/src/auth/middleware.rs` or the challenge verify endpoint:
     - After JWT validation (in Claims extraction or in challenge verify), check ban status
     - If user is banned, reject with appropriate error

  5. Update `server/src/moderation/mod.rs` to expose `pub mod kick; pub mod ban;` and wire routes.

  Commit: `feat(02-04): implement kick, ban, unban with WS force-close and ban middleware`
  </action>
  <verify>
  - `cargo test --test moderation_test` -- All 7 moderation tests pass
  - Verify ban check prevents WS connection for banned user
  - Verify kick closes connections but allows rejoin
  </verify>
  <done>
  Kick closes WS connections and removes non-default roles. Ban inserts record, force-closes WS, and prevents reconnection via ban check middleware. Unban removes ban record. Temporary bans have expiration with lazy cleanup. All moderation tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Invite generation, join flow, and landing page implementation</name>
  <files>
    server/src/invite/mod.rs
    server/src/invite/generate.rs
    server/src/invite/validate.rs
    server/src/invite/landing.rs
    server/src/identity/registration.rs
  </files>
  <action>
  1. Create `server/src/invite/generate.rs`:
     - `POST /api/invites` handler:
       - Requires ADMIN permission
       - Accepts { max_uses (optional), expires_in_seconds (optional) }
       - Generate 8-character alphanumeric code using rand (per Research Pattern 6: base62 charset)
       - Compute expires_at = now + duration if provided, else NULL
       - INSERT INTO invites
       - Return 201 with InviteInfo JSON

     - `GET /api/invites` handler:
       - Requires ADMIN permission
       - Return all invites (including expired/used, admin can see history)
       - Clean up expired invites lazily (or just show them with a status)

     - `DELETE /api/invites/{code}` handler:
       - Requires ADMIN permission
       - DELETE FROM invites WHERE code = X
       - Return 200

  2. Create `server/src/invite/validate.rs`:
     - `validate_invite(conn: &Connection, code: &str) -> Result<InviteRow, String>`:
       - Check invite exists, is not expired (expires_at is NULL or > now), use_count < max_uses (or max_uses is NULL)
       - Return invite row or error message

     - `consume_invite(conn: &Connection, code: &str) -> Result<(), String>`:
       - Atomic: `UPDATE invites SET use_count = use_count + 1 WHERE code = ?1 AND (max_uses IS NULL OR use_count < max_uses) RETURNING use_count`
       - Per Pitfall 4: If RETURNING yields no rows, invite is exhausted
       - Also check expiration in the same query

     - `POST /api/invite/join` handler:
       - Accepts { invite_code, fingerprint, public_key, display_name, genesis_signature, encrypted_blob }
       - Validate invite code via validate_invite
       - Check fingerprint not banned via check_ban
       - Register user (reuse/call into registration logic from identity/registration.rs)
       - Consume invite (increment use_count)
       - Auto-assign @everyone role
       - Return auth tokens (same as register response)
       - This is the primary user onboarding path (alongside direct registration if open mode is enabled)

  3. Create `server/src/invite/landing.rs`:
     - `GET /invite/{code}` handler (note: NOT under /api/ -- this is a browser-facing page):
       - Validate invite exists and is not expired
       - If invalid/expired, show a "This invite is no longer valid" page
       - If valid, render embedded HTML (per Research Pattern 7):
         - Dark theme, minimal styling
         - Server name and description from server_settings
         - "Open in UNITED" button linking to `united://invite/{code}`
         - "Don't have UNITED?" link to GitHub releases
       - Return `Html<String>` response

  4. Update `server/src/invite/mod.rs` to expose modules and wire routes.
     - The landing page route (`/invite/{code}`) must be added to the main router, NOT nested under /api/. Ensure it doesn't conflict with the API routes.

  5. Consider registration mode: If the server is in invite-only mode (per Phase 1 config), the existing `/api/auth/register` endpoint should require an invite code. If open mode, direct registration works without invite. The `/api/invite/join` endpoint always requires a valid invite code regardless of mode.

  Commit: `feat(02-04): implement invite generation, join flow, and landing page`
  </action>
  <verify>
  - `cargo test --test invite_test` -- All 10 invite tests pass
  - `cargo test` -- ALL tests pass (moderation + invite + channels + roles + Phase 1)
  - Visit /invite/{code} in browser, verify HTML page renders with server info
  - Join via invite, verify user gets @everyone role and can see channels
  </verify>
  <done>
  Invite generation with expiration and use limits works. Join-via-invite creates user, assigns @everyone, returns tokens. Landing page serves HTML at /invite/{code}. Atomic use_count prevents over-use. Expired invites rejected. Banned fingerprints cannot join. All 17 tests pass (7 moderation + 10 invite).
  </done>
</task>

</tasks>

<verification>
- `cargo test --test moderation_test --test invite_test` -- All 17 tests pass
- `cargo test` -- All tests pass across all test files
- Kick: closes WS, user can rejoin
- Ban: closes WS, prevents reconnection, shows reason with code 4003
- Temporary ban: expires and allows reconnection
- Invite: create with limits, join increments count, expired/exhausted rejected
- Landing page: HTML at /invite/{code} with server info
- Banned user cannot join via invite
</verification>

<success_criteria>
- Kick removes non-default roles and closes WS connections
- Ban stores record, force-closes WS, prevents reconnection via middleware
- Temporary bans auto-expire with lazy cleanup
- Unban removes ban and allows reconnection
- Invite generation with optional expiration and use count limits
- Join-via-invite registers user, assigns @everyone, returns auth tokens
- Atomic use_count increment prevents race condition over-use
- Landing page HTML at /invite/{code} with server info and deep link
- TDD: Tests written first, all passing
</success_criteria>

<output>
After completion, create `.planning/phases/02-server-management/02-04-SUMMARY.md`
</output>
