---
phase: 12-wire-client-connection-lifecycle
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - client/src/renderer/src/pages/Main.tsx
  - client/src/renderer/src/components/ConnectionBanner.tsx
  - client/src/renderer/src/components/ChatView.tsx
  - client/src/renderer/src/components/DmChatView.tsx
  - client/src/renderer/src/components/MessageComposer.tsx
  - client/src/renderer/src/components/DmComposer.tsx
  - client/src/renderer/src/hooks/useAuth.ts
  - client/src/main/ws/protocol.ts
autonomous: true
requirements:
  - MSG-01
  - MSG-04
  - MSG-05
  - MSG-06
  - MSG-09
  - DM-01
  - VOICE-01
  - VOICE-02
  - VOICE-03
  - P2P-02
  - APP-03
must_haves:
  truths:
    - "WebSocket connects automatically when /app mounts, activating all real-time features"
    - "Presence updates appear in the member list sidebar after WS connects"
    - "Typing indicators appear when other users are composing"
    - "Message composer is disabled when WS is disconnected, re-enables on reconnect"
    - "Connection status banner shows above message input when disconnected >500ms"
    - "P2P mesh auto-starts after WS connects (existing behavior, now reachable)"
    - "Dead code (useAuth.ts, protocol.ts stubs) is removed"
  artifacts:
    - path: "client/src/renderer/src/pages/Main.tsx"
      provides: "usePresence mount and WS connect trigger"
      contains: "usePresence"
    - path: "client/src/renderer/src/components/ConnectionBanner.tsx"
      provides: "Thin status banner above message input"
      contains: "Reconnecting"
    - path: "client/src/renderer/src/components/MessageComposer.tsx"
      provides: "Disabled input when disconnected"
      contains: "status"
    - path: "client/src/renderer/src/components/DmComposer.tsx"
      provides: "Disabled input when disconnected"
      contains: "status"
  key_links:
    - from: "client/src/renderer/src/pages/Main.tsx"
      to: "client/src/main/ipc/connection.ts"
      via: "window.united.connectWs() IPC call on mount"
      pattern: "connectWs"
    - from: "client/src/renderer/src/pages/Main.tsx"
      to: "client/src/renderer/src/hooks/usePresence.ts"
      via: "usePresence() hook mount"
      pattern: "usePresence"
    - from: "client/src/renderer/src/components/MessageComposer.tsx"
      to: "client/src/renderer/src/stores/index.ts"
      via: "useStore((s) => s.status) for connection awareness"
      pattern: "useStore.*status"
    - from: "client/src/main/index.ts"
      to: "client/src/main/ws/voice-events.ts"
      via: "setupVoiceEventListener() called at app startup — activates when WS connects"
      pattern: "setupVoiceEventListener"
    - from: "client/src/main/ipc/connection.ts"
      to: "client/src/main/p2p/node.ts"
      via: "wsClient.on('status') auto-starts P2P mesh on WS 'connected'"
      pattern: "startP2PNode"
---

<objective>
Mount usePresence() in Main.tsx, trigger WS connect on /app mount, add connection status banner, disable composers when disconnected, and remove dead code.

Purpose: This plan activates all 11 remaining requirements by connecting WebSocket when /app mounts. Once WS is connected, all existing event forwarders (chat-events.ts, dm-events.ts, voice-events.ts) become reachable, P2P mesh auto-starts, and presence data flows to the UI. The connection banner and disabled composers provide the UX specified in CONTEXT.md.

Output: Fully functional real-time pipeline from auth to WS to all features. Dead code removed.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-wire-client-connection-lifecycle/12-CONTEXT.md
@.planning/phases/12-wire-client-connection-lifecycle/12-RESEARCH.md
@.planning/phases/12-wire-client-connection-lifecycle/12-01-SUMMARY.md
@client/src/renderer/src/pages/Main.tsx
@client/src/renderer/src/hooks/usePresence.ts
@client/src/renderer/src/hooks/useConnection.ts
@client/src/renderer/src/hooks/useAuth.ts
@client/src/renderer/src/components/MainContent.tsx
@client/src/renderer/src/components/MessageComposer.tsx
@client/src/renderer/src/components/DmComposer.tsx
@client/src/renderer/src/components/ChatView.tsx
@client/src/renderer/src/components/DmChatView.tsx
@client/src/renderer/src/stores/index.ts
@client/src/main/ws/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Mount usePresence, trigger WS connect, and add ConnectionBanner</name>
  <files>
    client/src/renderer/src/pages/Main.tsx
    client/src/renderer/src/components/ConnectionBanner.tsx
    client/src/renderer/src/components/ChatView.tsx
    client/src/renderer/src/components/DmChatView.tsx
  </files>
  <action>
    1. **Main.tsx** — Add two hooks:

       a) Import and mount `usePresence` from `../hooks/usePresence`:
       ```typescript
       import { usePresence } from '../hooks/usePresence'
       // Inside Main():
       usePresence()  // Subscribes to presence + typing events from main process
       ```

       b) Add a `useEffect` to trigger WS connection on mount. This is the "single code path" both returning-user and new-user flows converge to:
       ```typescript
       useEffect(() => {
         // Both flows have a valid JWT by the time /app mounts (Plan 01 ensures this)
         // Connect WebSocket — this activates all real-time features
         window.united.connectWs().catch((err) => {
           console.error('[WS] Connection failed:', err)
         })
       }, [])
       ```

       This useEffect runs once on mount. The WsClient handles reconnection internally. P2P auto-starts when WS status becomes 'connected' (existing listener in connection.ts).

    2. **ConnectionBanner.tsx** — Create a new component that shows a thin banner when disconnected:

       ```typescript
       import { useState, useEffect, useRef } from 'react'
       import { useStore } from '../stores'

       export default function ConnectionBanner() {
         const status = useStore((s) => s.status)
         const [visible, setVisible] = useState(false)
         const timerRef = useRef<ReturnType<typeof setTimeout> | null>(null)

         useEffect(() => {
           if (status !== 'connected') {
             // 500ms delay threshold to avoid flicker on fast connections (CONTEXT.md decision)
             timerRef.current = setTimeout(() => setVisible(true), 500)
           } else {
             // Connected — hide immediately
             if (timerRef.current) clearTimeout(timerRef.current)
             setVisible(false)
           }
           return () => {
             if (timerRef.current) clearTimeout(timerRef.current)
           }
         }, [status])

         if (!visible) return null

         return (
           <div className="flex items-center justify-center bg-yellow-600/90 px-3 py-1 text-xs font-medium text-white">
             {status === 'reconnecting' ? 'Reconnecting...' : 'Connecting...'}
           </div>
         )
       }
       ```

       Style: thin horizontal banner, yellow/amber background, centered text. Disappears when connected. Per CONTEXT.md: "thin banner above message input" and "500ms delay threshold."

    3. **ChatView.tsx** — Render `<ConnectionBanner />` above the MessageComposer component at the bottom of the chat view. Find where MessageComposer is rendered and insert `<ConnectionBanner />` directly above it.

    4. **DmChatView.tsx** — Same pattern: render `<ConnectionBanner />` above the DmComposer component.
  </action>
  <verify>
    - Main.tsx imports and calls usePresence()
    - Main.tsx has useEffect calling window.united.connectWs()
    - ConnectionBanner.tsx exists with 500ms delay threshold logic
    - ChatView.tsx renders ConnectionBanner above MessageComposer
    - DmChatView.tsx renders ConnectionBanner above DmComposer
    - TypeScript compiles: `cd client && npx tsc --noEmit`
  </verify>
  <done>
    Main.tsx mounts usePresence() for real-time presence and typing updates. Main.tsx triggers WS connection on mount via connectWs() IPC. ConnectionBanner shows above message input when disconnected >500ms. Banner appears in both channel chat and DM views.
  </done>
</task>

<task type="auto">
  <name>Task 2: Disable composers when disconnected and remove dead code</name>
  <files>
    client/src/renderer/src/components/MessageComposer.tsx
    client/src/renderer/src/components/DmComposer.tsx
    client/src/renderer/src/hooks/useAuth.ts
    client/src/main/ws/protocol.ts
  </files>
  <action>
    1. **MessageComposer.tsx** — Add connection status awareness:

       a) Import useStore and read connection status:
       ```typescript
       const status = useStore((s) => s.status)
       const isDisconnected = status !== 'connected'
       ```

       b) Disable the textarea when disconnected:
       - Add `disabled={isDisconnected}` to the textarea element
       - Change placeholder to `"Reconnecting..."` when disconnected (CONTEXT.md decision: "greyed out, re-enables on reconnect")
       - Prevent the send handler from executing when disconnected (early return in handleSend if isDisconnected)

       c) Style the disabled state:
       - Add `opacity-50 cursor-not-allowed` classes when isDisconnected
       - Disable the send button and attachment button as well

    2. **DmComposer.tsx** — Same pattern as MessageComposer:

       a) Import useStore, read status
       b) Disable textarea and send button when disconnected
       c) Show "Reconnecting..." placeholder when disconnected
       d) Prevent send when disconnected

    3. **Delete dead code:**

       a) **useAuth.ts** — Delete the file entirely. It is dead code (never imported anywhere). Its orchestration logic is now split correctly between Welcome.tsx (auth before navigate) and Main.tsx (WS connect after mount), per CONTEXT.md decisions. Keeping it around would cause confusion.

       b) **protocol.ts** — Delete the file entirely. It contains only stubs that throw errors ("protobuf codegen required"). These functions are unreachable — WsClient uses the protobuf event forwarders (chat-events.ts, dm-events.ts, voice-events.ts) directly, not protocol.ts encode/decode.

       c) After deletion, grep for any remaining imports of `useAuth` or `protocol` and remove them. Check:
          - `grep -r "useAuth" client/src/renderer/` — should find no imports
          - `grep -r "protocol" client/src/main/ws/` — should only find the event forwarder files, not protocol.ts imports

    4. **Verify voice and P2P event pipelines activate on WS connect** (no code changes expected — confirm existing wiring):

       a) Confirm `client/src/main/index.ts` calls `setupVoiceEventListener()` at app startup (alongside `setupChatEventListener()` and `setupDmEventListener()`). These register WS message listeners on the shared `wsClient` — once WS connects (via `connectWs()` from Task 1 of this plan), voice events flow automatically.

       b) Confirm `client/src/main/ipc/connection.ts` has the P2P auto-start listener inside `registerConnectionHandlers()`:
          ```
          wsClient.on('status', (status) => {
            if (status === 'connected' && !getP2PNode()) {
              startP2PNode(url)
            }
          })
          ```
          This fires when WS status becomes 'connected', starting the P2P mesh automatically.

       c) If either wiring is missing (setupVoiceEventListener not called, or P2P auto-start listener absent), add the missing call. Based on current codebase analysis, both are present — this step is a safety verification.

       d) Run grep to confirm:
          - `grep -n "setupVoiceEventListener" client/src/main/index.ts` — must show the call
          - `grep -n "startP2PNode" client/src/main/ipc/connection.ts` — must show auto-start in status listener
  </action>
  <verify>
    - MessageComposer textarea is disabled when status !== 'connected'
    - DmComposer textarea is disabled when status !== 'connected'
    - client/src/renderer/src/hooks/useAuth.ts no longer exists
    - client/src/main/ws/protocol.ts no longer exists
    - No remaining imports reference useAuth or protocol.ts
    - `grep -n "setupVoiceEventListener" client/src/main/index.ts` confirms voice event listener is registered at startup
    - `grep -n "startP2PNode" client/src/main/ipc/connection.ts` confirms P2P auto-start fires on WS 'connected' status
    - TypeScript compiles: `cd client && npx tsc --noEmit`
  </verify>
  <done>
    Message input disabled with "Reconnecting..." placeholder when WS is disconnected. Both MessageComposer and DmComposer are connection-aware. Dead code removed: useAuth.ts (unused orchestration hook) and protocol.ts (unreachable stubs). No dangling imports. Voice event listener (setupVoiceEventListener) confirmed registered at app startup. P2P auto-start confirmed wired to WS 'connected' status change.
  </done>
</task>

</tasks>

<verification>
1. Main.tsx mounts usePresence() — presence data flows from WS to Zustand store to UI
2. Main.tsx triggers connectWs() on mount — WS connects using JWT from Plan 01
3. P2P mesh auto-starts when WS status becomes 'connected' (existing listener, now reachable)
4. ConnectionBanner appears above message input when disconnected >500ms, disappears when connected
5. MessageComposer and DmComposer are disabled when disconnected
6. useAuth.ts and protocol.ts are deleted with no dangling imports
7. TypeScript compiles without errors
8. All 11 remaining requirements become functional because WS connection enables their event pipelines
</verification>

<success_criteria>
- WS connects automatically when /app mounts
- Presence, typing, chat, DM, and voice events all flow from server to renderer
- P2P gossipsub mesh starts after WS connects
- Disconnected state: banner visible, composer disabled, features degrade gracefully
- Connected state: zero UI noise, all features operational
- No dead code remains (useAuth.ts, protocol.ts removed)
</success_criteria>

<output>
After completion, create `.planning/phases/12-wire-client-connection-lifecycle/12-02-SUMMARY.md`
</output>
