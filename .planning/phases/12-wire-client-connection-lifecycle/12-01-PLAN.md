---
phase: 12-wire-client-connection-lifecycle
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/main/ipc/channels.ts
  - client/src/main/ipc/connection.ts
  - client/src/main/ipc/auth.ts
  - shared/types/ipc-bridge.ts
  - client/src/preload/index.ts
  - client/src/renderer/src/pages/Welcome.tsx
  - client/src/renderer/src/pages/JoinServer.tsx
  - client/src/main/ws/client.ts
autonomous: true
requirements:
  - SEC-02
must_haves:
  truths:
    - "Returning user unlocks identity and the app calls challenge-response auth to get a JWT before navigating to /app"
    - "New user registers via invite and already has JWT from register response before navigating to /app"
    - "WebSocket connects immediately when /app loads without requiring a second auth prompt"
    - "Reconnection begins without visible delay after disconnect, then backs off gradually to 30s cap"
  artifacts:
    - path: "client/src/main/ipc/connection.ts"
      provides: "AUTH_AUTHENTICATE and AUTH_CONNECT_WS IPC handlers"
      contains: "ipcMain.handle(IPC.AUTH_AUTHENTICATE"
    - path: "client/src/main/ipc/channels.ts"
      provides: "New IPC channel constants"
      contains: "AUTH_AUTHENTICATE"
    - path: "shared/types/ipc-bridge.ts"
      provides: "Type declarations for authenticateToServer and connectWs"
      contains: "authenticateToServer"
    - path: "client/src/preload/index.ts"
      provides: "Preload bridge exposure for new IPC methods"
      contains: "authenticateToServer"
    - path: "client/src/renderer/src/pages/Welcome.tsx"
      provides: "Challenge-response call before navigate"
      contains: "authenticateToServer"
    - path: "client/src/renderer/src/pages/JoinServer.tsx"
      provides: "No new auth call needed (JWT from register), but flow must not break"
  key_links:
    - from: "client/src/renderer/src/pages/Welcome.tsx"
      to: "client/src/main/ipc/connection.ts"
      via: "window.united.authenticateToServer(url) IPC"
      pattern: "authenticateToServer"
    - from: "client/src/main/ipc/connection.ts"
      to: "client/src/main/ipc/auth.ts"
      via: "storeTokens() after challenge-response"
      pattern: "storeTokens"
---

<objective>
Wire challenge-response auth into the returning-user unlock flow and add IPC handlers so the renderer can trigger authentication and WS connection.

Purpose: SEC-02 requires challenge-response authentication with JWT tokens. The code exists in connection.ts but is dead -- never callable from the renderer. This plan adds IPC handlers to bridge that gap, wires Welcome.tsx to call challenge-response before navigating to /app, and tweaks the WsClient backoff to match the user's specified schedule (immediate first retry).

Output: New IPC handlers (authenticateToServer, connectWs) exposed via preload bridge. Welcome.tsx calls authenticateToServer before navigate. WsClient first reconnect is immediate.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-wire-client-connection-lifecycle/12-CONTEXT.md
@.planning/phases/12-wire-client-connection-lifecycle/12-RESEARCH.md
@client/src/main/ipc/connection.ts
@client/src/main/ipc/auth.ts
@client/src/main/ipc/channels.ts
@client/src/main/ws/client.ts
@client/src/preload/index.ts
@shared/types/ipc-bridge.ts
@client/src/renderer/src/pages/Welcome.tsx
@client/src/renderer/src/pages/JoinServer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IPC handlers for auth and WS connection</name>
  <files>
    client/src/main/ipc/channels.ts
    client/src/main/ipc/connection.ts
    client/src/main/ipc/auth.ts
    shared/types/ipc-bridge.ts
    client/src/preload/index.ts
    client/src/main/ws/client.ts
  </files>
  <action>
    1. **channels.ts** — Add two new IPC channel constants:
       - `AUTH_AUTHENTICATE: 'auth:authenticate'` — performs challenge-response and stores JWT
       - `AUTH_CONNECT_WS: 'auth:connect-ws'` — connects WebSocket using stored JWT

    2. **connection.ts** — Add two new IPC handlers inside `registerConnectionHandlers()`:

       **Handler 1: AUTH_AUTHENTICATE**
       ```
       ipcMain.handle(IPC.AUTH_AUTHENTICATE, async (_event, serverUrl: string) => {
         setServerUrl(serverUrl)
         const { accessToken, refreshToken } = await performChallengeResponse(serverUrl)
         storeTokens(accessToken, refreshToken)
         return { success: true }
       })
       ```
       This requires importing `storeTokens` from `auth.ts`. Currently `storeTokens` is a private function — change it to an exported function in auth.ts so connection.ts can import it.

       **Handler 2: AUTH_CONNECT_WS**
       ```
       ipcMain.handle(IPC.AUTH_CONNECT_WS, async () => {
         const token = getAccessToken()
         const url = getServerUrl()
         if (!token || !url) throw new Error('Not authenticated — no JWT or server URL')
         connectWebSocket(url, token)
         return { success: true }
       })
       ```

    3. **auth.ts** — Export `storeTokens` so connection.ts can import it:
       Change `function storeTokens(...)` to `export function storeTokens(...)`

    4. **shared/types/ipc-bridge.ts** — Add types to the `UnitedAPI` interface:
       ```typescript
       authenticateToServer(serverUrl: string): Promise<{ success: boolean }>
       connectWs(): Promise<{ success: boolean }>
       ```

    5. **client/src/preload/index.ts** — Expose the new IPC methods on `window.united`:
       ```typescript
       authenticateToServer: (serverUrl: string) =>
         ipcRenderer.invoke('auth:authenticate', serverUrl),
       connectWs: () =>
         ipcRenderer.invoke('auth:connect-ws'),
       ```

    6. **client/src/main/ws/client.ts** — Tweak backoff for immediate first retry:
       In `scheduleReconnect()`, add a special case: if `this.attempt === 0`, call `this.doConnect()` immediately (via `setTimeout(() => this.doConnect(), 0)`) instead of using `calculateReconnectDelay`. This makes the backoff schedule: immediate → 1s → 2s → 4s → 8s → 16s → 30s cap, matching the user's CONTEXT.md decision.

       Also update `maxAttempts` to `Infinity` (or a very large number like 9999) in `DEFAULT_RECONNECT_CONFIG` to implement "never give up" behavior per CONTEXT.md.
  </action>
  <verify>
    - TypeScript compiles: `cd client && npx tsc --noEmit` (check for type errors)
    - New IPC constants exist in channels.ts
    - New handlers exist in connection.ts
    - storeTokens is exported from auth.ts
    - Preload bridge exposes authenticateToServer and connectWs
    - WsClient scheduleReconnect has immediate-first-retry logic
  </verify>
  <done>
    Two new IPC handlers (AUTH_AUTHENTICATE, AUTH_CONNECT_WS) are registered and exposed via preload bridge. storeTokens is exported from auth.ts. WsClient backoff matches CONTEXT.md schedule (immediate first retry, never give up).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auth into Welcome.tsx and verify JoinServer.tsx flow</name>
  <files>
    client/src/renderer/src/pages/Welcome.tsx
    client/src/renderer/src/pages/JoinServer.tsx
  </files>
  <action>
    1. **Welcome.tsx** — Modify `handleUnlock` to add challenge-response auth before navigating:

       After `unlockIdentity(passphrase)` and `setUnlocked(fingerprint, publicKey)`, and after `getActiveServer()` returns an active server:
       ```typescript
       if (activeServer) {
         // Challenge-response auth to get JWT (CONTEXT.md: auth completes before navigation)
         try {
           await window.united.authenticateToServer(activeServer.url)
         } catch (authErr) {
           // Auth failed — show error but stay on Welcome screen (CONTEXT.md decision)
           setError(authErr instanceof Error ? authErr.message : 'Server authentication failed')
           setUnlocking(false)
           return
         }
         navigate('/app')
       }
       ```

       Also update the Zustand store with server info from the cached active server before navigating:
       ```typescript
       useStore.setState({
         serverId: activeServer.id,
         serverUrl: activeServer.url,
         name: activeServer.name,
         description: activeServer.description,
         registrationMode: activeServer.registrationMode,
         displayName: activeServer.displayName,
       })
       ```

       This ensures Main.tsx has server context when it mounts.

    2. **JoinServer.tsx** — The new-user flow already gets a JWT from `window.united.register()` (which calls `storeTokens` in auth.ts). No additional auth call needed. Verify that `handleRegister` does NOT need changes — the JWT is already stored after register. The WS connection will happen in Main.tsx (Plan 02) after navigate('/app').

       However, verify that the server URL is set correctly. The `handleConnect` callback calls `window.united.connectToServer(normalized)` which calls `setServerUrl(normalizedUrl)` in the main process. This is needed so `connectWs()` can find the server URL. Confirm this path is correct for both the direct-URL and invite-join flows.

       No code changes needed in JoinServer.tsx if the server URL is already set by the existing `connectToServer` call.
  </action>
  <verify>
    - Welcome.tsx handleUnlock calls authenticateToServer before navigate('/app')
    - If auth fails, error is shown and user stays on Welcome screen
    - JoinServer.tsx flow: register → JWT stored → navigate('/app') (no changes needed)
    - Server store state is populated before navigation in both flows
  </verify>
  <done>
    Returning user flow calls challenge-response auth (via authenticateToServer IPC) before navigating to /app. Auth failure keeps user on Welcome screen with error message. New user flow unchanged (JWT already from register). Both flows ensure Zustand has server context before /app mounts.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors across all modified files
2. New IPC channel constants AUTH_AUTHENTICATE and AUTH_CONNECT_WS exist
3. connection.ts has two new ipcMain.handle registrations
4. storeTokens is exported from auth.ts and imported by connection.ts
5. preload/index.ts exposes authenticateToServer and connectWs
6. Welcome.tsx handleUnlock calls authenticateToServer before navigate
7. WsClient first reconnect is immediate (0ms), subsequent follow exponential backoff
</verification>

<success_criteria>
- Returning user: unlock → challenge-response → JWT stored → navigate('/app')
- New user: register → JWT stored → navigate('/app')
- Both flows have valid JWT in auth.ts module scope before reaching /app
- WsClient ready for immediate-first-retry reconnection
- All types compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/12-wire-client-connection-lifecycle/12-01-SUMMARY.md`
</output>
