---
phase: 06-content-distribution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/proto/blocks.proto
  - shared/proto/ws.proto
  - server/Cargo.toml
  - server/src/db/migrations.rs
  - server/src/db/models.rs
  - server/build.rs
  - server/src/proto/mod.rs
  - server/src/blocks/mod.rs
  - server/src/blocks/crypto.rs
  - server/src/blocks/store.rs
  - server/src/blocks/routes.rs
  - server/src/blocks/retention.rs
  - server/src/lib.rs
  - server/src/routes.rs
  - server/src/main.rs
  - server/src/config.rs
autonomous: true
requirements:
  - P2P-01
  - P2P-06

must_haves:
  truths:
    - "Server can receive a block upload via REST and store it encrypted with content-derived HKDF key"
    - "Server can serve a stored block back via REST given its SHA-256 hash"
    - "Server automatically purges blocks older than the configured retention TTL"
    - "Block data is encrypted at rest on the server using HKDF-SHA256 content-derived keys"
  artifacts:
    - path: "shared/proto/blocks.proto"
      provides: "BlockRef, BlockRequest, BlockResponse protobuf messages"
      contains: "message BlockRef"
    - path: "server/src/blocks/crypto.rs"
      provides: "HKDF-SHA256 content-derived key derivation and AES-256-GCM encrypt/decrypt"
      contains: "derive_content_key"
    - path: "server/src/blocks/store.rs"
      provides: "Block metadata SQLite operations and file-based encrypted block storage"
      contains: "put_block"
    - path: "server/src/blocks/routes.rs"
      provides: "PUT /api/blocks and GET /api/blocks/:hash REST endpoints"
      contains: "put_block_route"
    - path: "server/src/blocks/retention.rs"
      provides: "Background TTL purge task for expired blocks"
      contains: "spawn_retention_cleanup"
  key_links:
    - from: "server/src/blocks/routes.rs"
      to: "server/src/blocks/store.rs"
      via: "route handler calls store functions"
      pattern: "store::put_block|store::get_block"
    - from: "server/src/blocks/store.rs"
      to: "server/src/blocks/crypto.rs"
      via: "encrypt before write, decrypt after read"
      pattern: "crypto::server_encrypt_block|crypto::server_decrypt_block"
    - from: "server/src/blocks/retention.rs"
      to: "server/src/blocks/store.rs"
      via: "purge calls store delete functions"
      pattern: "store::delete_expired_blocks"
---

<objective>
Server-side content-addressed block store with HKDF-encrypted storage, REST API, and retention management.

Purpose: Build the server's block storage infrastructure so it can act as a super-seeder fallback for the P2P content distribution network. The server stores encrypted copies of content for availability when the peer swarm is thin.

Output: Protobuf schemas (blocks.proto), server migration 6, HKDF crypto module, REST endpoints for block upload/download, and background retention purge task.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-content-distribution/06-CONTEXT.md
@.planning/phases/06-content-distribution/06-RESEARCH.md
@server/src/db/migrations.rs
@server/src/config.rs
@server/src/state.rs
@server/src/routes.rs
@server/build.rs
@shared/proto/ws.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Protobuf schemas and server database migration</name>
  <files>
    shared/proto/blocks.proto
    shared/proto/ws.proto
    server/src/db/migrations.rs
    server/src/db/models.rs
    server/build.rs
    server/src/proto/mod.rs
  </files>
  <action>
    Create `shared/proto/blocks.proto` with package `united.blocks`:
    - `BlockRef`: hash (string), size (uint64), mime_type (string), width (uint32), height (uint32), micro_thumbnail (bytes), filename (string)
    - `BlockRequest`: hash (string)
    - `BlockResponse`: hash (string), data (bytes), not_found (bool)
    - `BlockStored`: hash (string), size (uint64), channel_id (string) — server confirms block upload
    - `BlockAvailable`: hash (string), peer_id (string) — notify peers of new block availability

    Extend `shared/proto/ws.proto` Envelope with Phase 6 block event payload variants:
    - Field 160: BlockStored (united.blocks.BlockStored)
    - Field 161: BlockRequest (united.blocks.BlockRequest)
    - Field 162: BlockAvailable (united.blocks.BlockAvailable)

    Add `blocks.proto` to `server/build.rs` prost_build input list.
    Add `blocks` proto module and re-export in `server/src/proto/mod.rs`.

    Create Migration 6 in `server/src/db/migrations.rs`:
    ```sql
    CREATE TABLE blocks (
      hash TEXT PRIMARY KEY,
      size INTEGER NOT NULL,
      encrypted_size INTEGER NOT NULL,
      channel_id TEXT,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      expires_at TEXT NOT NULL,
      FOREIGN KEY (channel_id) REFERENCES channels(id) ON DELETE SET NULL
    );
    CREATE INDEX idx_blocks_expires ON blocks(expires_at);
    CREATE INDEX idx_blocks_channel ON blocks(channel_id);
    ```

    Add `BlockRow` model to `server/src/db/models.rs` with hash, size, encrypted_size, channel_id, created_at, expires_at fields.
  </action>
  <verify>
    Run `cd server && cargo build` — compiles without errors.
    Verify blocks.proto generates Rust types (BlockRef, BlockRequest, BlockResponse, BlockStored, BlockAvailable).
  </verify>
  <done>
    blocks.proto defines all block exchange message types.
    ws.proto Envelope has Phase 6 payload variants (fields 160-162).
    Migration 6 creates blocks table with expiry index.
    BlockRow model exists in models.rs.
    Server compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Block store module with HKDF crypto, REST endpoints, and retention purge</name>
  <files>
    server/Cargo.toml
    server/src/blocks/mod.rs
    server/src/blocks/crypto.rs
    server/src/blocks/store.rs
    server/src/blocks/routes.rs
    server/src/blocks/retention.rs
    server/src/lib.rs
    server/src/routes.rs
    server/src/main.rs
    server/src/config.rs
  </files>
  <action>
    Add `hkdf = "0.12"` to server/Cargo.toml (sha2, aes-gcm already present).

    Create `server/src/blocks/mod.rs` with pub mod declarations for crypto, store, routes, retention.

    Create `server/src/blocks/crypto.rs`:
    - `derive_content_key(content_hash: &[u8; 32]) -> Key<Aes256Gcm>` using HKDF-SHA256 with salt `b"united-content-derived-key-v1"` and info `b"united-server-block-encryption"`.
    - `server_encrypt_block(content_hash: &[u8; 32], plaintext: &[u8]) -> Vec<u8>`: derive key, generate random 12-byte nonce, AES-256-GCM encrypt, return nonce (12 bytes) || ciphertext.
    - `server_decrypt_block(content_hash: &[u8; 32], ciphertext: &[u8]) -> Result<Vec<u8>, ...>`: split nonce from ciphertext, derive key, decrypt.

    Create `server/src/blocks/store.rs`:
    - Block data stored as individual encrypted files in `{data_dir}/blocks/` directory (named by hex hash).
    - `put_block(db, data_dir, hash_hex, data, channel_id, retention_days) -> Result<()>`: compute SHA-256 to verify hash matches, encrypt with HKDF-derived key, write encrypted file, insert metadata row with expires_at = now + retention_days.
    - `get_block(db, data_dir, hash_hex) -> Result<Option<Vec<u8>>>`: read metadata row, read encrypted file, decrypt with content-derived key, return plaintext.
    - `has_block(db, hash_hex) -> bool`: check metadata existence.
    - `delete_block(db, data_dir, hash_hex) -> Result<()>`: delete file and metadata row.
    - `delete_expired_blocks(db, data_dir) -> Result<usize>`: query blocks WHERE expires_at < datetime('now'), delete files and rows, return count.
    - Use `spawn_blocking` for DB and file I/O operations in async context.
    - Create `{data_dir}/blocks/` directory on first write if it doesn't exist.

    Create `server/src/blocks/routes.rs`:
    - `PUT /api/blocks`: Accept raw binary body with `X-Block-Hash` header (hex), optional `X-Channel-Id` header. Verify SHA-256 matches, call store::put_block, return 201 with JSON `{ "hash": "...", "size": N }`. Requires JWT auth.
    - `GET /api/blocks/:hash`: Read from store, return raw binary body with `Content-Type: application/octet-stream`. Return 404 if not found. Requires JWT auth.
    - Use existing auth extractor pattern (`Claims` from JWT middleware).

    Create `server/src/blocks/retention.rs`:
    - `spawn_retention_cleanup(db, data_dir, interval_secs)`: spawn a tokio task that runs `delete_expired_blocks` every `interval_secs` (default 3600 = 1 hour). Log count of purged blocks.

    Add `[blocks]` section to `server/src/config.rs`:
    - `retention_days: u32` (default 30)
    - `cleanup_interval_secs: u64` (default 3600)
    Add to generate_config_template().

    Wire into application:
    - Add `pub mod blocks` to `server/src/lib.rs`.
    - Add block routes to `server/src/routes.rs` router.
    - Spawn retention cleanup task in `server/src/main.rs` alongside existing background tasks.
  </action>
  <verify>
    Run `cd server && cargo build` — compiles without errors.
    Run `cd server && cargo test` — all existing tests pass (no regressions).
  </verify>
  <done>
    HKDF-SHA256 content-derived encryption working for block storage.
    PUT /api/blocks accepts binary upload with hash verification.
    GET /api/blocks/:hash serves decrypted block content.
    Background retention purge deletes expired blocks every hour.
    Block data stored as encrypted files in {data_dir}/blocks/.
    Server compiles and all existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cargo build` in server/ succeeds with no errors
2. `cargo test` in server/ — all existing tests pass (no regressions)
3. blocks.proto generates correct Rust types
4. Migration 6 creates blocks table
5. Block routes are wired into the router
6. Retention cleanup task is spawned at startup
</verification>

<success_criteria>
- Server can store and retrieve content-addressed blocks via REST API
- All blocks are encrypted at rest using HKDF-derived keys from content hash
- Expired blocks are automatically purged after configured TTL
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06-content-distribution/06-01-SUMMARY.md`
</output>
