---
phase: 06-content-distribution
plan: 04
type: execute
wave: 2
depends_on:
  - "06-01"
  - "06-02"
files_modified:
  - client/package.json
  - shared/proto/blocks.proto
  - client/src/main/blocks/thumbnails.ts
  - client/src/main/p2p/gossipsub.ts
  - client/src/renderer/src/components/ContentPlaceholder.tsx
  - client/src/renderer/src/components/AttachmentCard.tsx
  - client/src/renderer/src/hooks/useBlockContent.ts
  - client/src/renderer/src/stores/settings.ts
  - client/src/renderer/src/stores/blocks.ts
  - client/src/renderer/src/components/StorageSettings.tsx
autonomous: true
requirements:
  - P2P-10
  - APP-04

must_haves:
  truths:
    - "Small content (<50KB) is inlined with gossip messages for instant rendering"
    - "Large images include a block reference with hash, dimensions, and micro-thumbnail"
    - "Non-image files include metadata (filename, size, MIME type) for immediate card rendering"
    - "Media content reserves exact dimensions during loading — zero layout reflow"
    - "Progressive timeout feedback: shimmer -> 'Fetching from network...' -> 'Content unavailable' with retry"
    - "User can configure storage budget and warm TTL via settings slider"
  artifacts:
    - path: "client/src/main/blocks/thumbnails.ts"
      provides: "Micro-thumbnail generation via sharp (~100px JPEG)"
      contains: "generateMicroThumbnail"
    - path: "client/src/renderer/src/components/ContentPlaceholder.tsx"
      provides: "Progressive loading placeholder with shimmer, status text, and error states"
      contains: "ContentPlaceholder"
    - path: "client/src/renderer/src/components/AttachmentCard.tsx"
      provides: "File attachment card with filename, size, type icon, download trigger"
      contains: "AttachmentCard"
    - path: "client/src/renderer/src/hooks/useBlockContent.ts"
      provides: "React hook: hash -> content with loading/error/retry states"
      contains: "useBlockContent"
    - path: "client/src/renderer/src/components/StorageSettings.tsx"
      provides: "Storage budget slider and warm TTL configuration"
      contains: "StorageSettings"
  key_links:
    - from: "client/src/renderer/src/hooks/useBlockContent.ts"
      to: "IPC BLOCK_RESOLVE"
      via: "hook calls window.united.blocks.resolveBlock(hash)"
      pattern: "window\\.united\\.blocks\\.resolveBlock"
    - from: "client/src/renderer/src/components/ContentPlaceholder.tsx"
      to: "client/src/renderer/src/hooks/useBlockContent.ts"
      via: "placeholder uses hook's loading/error state for progressive feedback"
      pattern: "useBlockContent"
    - from: "client/src/main/blocks/thumbnails.ts"
      to: "client/src/main/p2p/gossipsub.ts"
      via: "thumbnail generated before gossip publish for image attachments"
      pattern: "generateMicroThumbnail"
---

<objective>
Gossip inline/deferred content integration, micro-thumbnails, UI components for content loading, and storage settings.

Purpose: Wire the content pipeline end-to-end: extend gossip messages to carry inline content or block references, generate micro-thumbnails for images, build UI components that show progressive loading states (shimmer -> fetching -> unavailable), and give users control over their storage budget. This completes the user-facing experience of the block distribution system.

Output: thumbnails.ts, extended gossip envelope, ContentPlaceholder, AttachmentCard, useBlockContent hook, StorageSettings panel, blocks Zustand store.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-content-distribution/06-CONTEXT.md
@.planning/phases/06-content-distribution/06-RESEARCH.md
@.planning/phases/06-content-distribution/06-02-SUMMARY.md
@client/src/main/p2p/gossipsub.ts
@client/src/renderer/src/stores/settings.ts
@client/src/renderer/src/stores/index.ts
@client/src/renderer/src/components/SkeletonShimmer.tsx
@client/src/preload/index.ts
@shared/types/ipc-bridge.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Micro-thumbnails and gossip inline/deferred content</name>
  <files>
    client/package.json
    client/src/main/blocks/thumbnails.ts
    client/src/main/p2p/gossipsub.ts
  </files>
  <action>
    Install `sharp` in client: `npm install sharp`. Then rebuild for Electron: `npx electron-rebuild --version 40.6.0` (same pattern as sodium-native and better-sqlite3).

    Create `client/src/main/blocks/thumbnails.ts`:
    - `generateMicroThumbnail(imageData: Buffer): Promise<{ thumbnail: Buffer, width: number, height: number }>`:
      1. Read image metadata via `sharp(imageData).metadata()` to get original width and height.
      2. Resize to max 100px width (maintain aspect ratio) with `sharp(imageData).resize(100, undefined, { fit: 'inside' })`.
      3. Convert to JPEG at quality 40: `.jpeg({ quality: 40 }).toBuffer()`.
      4. Return { thumbnail, width (original), height (original) }.
      5. Throw descriptive error if image dimensions cannot be read.
    - `isImageMime(mimeType: string): boolean` — returns true for image/jpeg, image/png, image/gif, image/webp.
    - `getFileMimeType(filename: string): string` — basic extension-to-MIME mapping for common types (jpg, png, gif, webp, pdf, zip, mp4, etc.). Default: application/octet-stream.

    Update `client/src/main/p2p/gossipsub.ts` to support inline vs deferred content in gossip:
    - Add helper `prepareContentForGossip(data: Buffer, filename: string, mimeType: string): { inline: boolean, payload: Buffer, blockRef?: BlockRefData }`:
      1. If data.length <= 50 * 1024 (50KB): return `{ inline: true, payload: data }` — content inlined with gossip.
      2. If data.length > 50KB AND isImageMime(mimeType):
         - Store block via putBlock.
         - Generate micro-thumbnail via generateMicroThumbnail.
         - Return `{ inline: false, blockRef: { hash, size, mimeType, width, height, microThumbnail, filename } }`.
      3. If data.length > 50KB AND NOT image:
         - Store block via putBlock.
         - Return `{ inline: false, blockRef: { hash, size, mimeType, width: 0, height: 0, filename } }` — metadata only, no thumbnail.
    - Enforce the 50KB limit on RAW content before protobuf encoding (per Pitfall 3 in research — actual gossip message ~51-52KB after envelope overhead, safely under 64KB gossipsub limit).
    - The GossipEnvelope already has a payload field. Block references will be encoded as part of the message content. Phase 7 will add the full media attachment flow that produces these references during message composition. For now, the infrastructure is ready.
    - Add a guard check before gossip publish: if total envelope size exceeds 60KB after encoding, reject with error (safety margin below 64KB gossipsub max_transmit_size).
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` — TypeScript compiles without errors.
    Verify sharp is in package.json dependencies.
    Verify generateMicroThumbnail exports from thumbnails.ts.
    Verify prepareContentForGossip handles both inline and deferred paths.
  </verify>
  <done>
    sharp installed and rebuilt for Electron.
    Micro-thumbnail generation: 100px max width, JPEG quality 40, returns original dimensions.
    Gossip content preparation: <50KB inlined, images >50KB get block ref + micro-thumbnail, non-images >50KB get metadata-only block ref.
    Gossip envelope size guard prevents exceeding 64KB gossipsub limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Content loading UI components, useBlockContent hook, and storage settings</name>
  <files>
    client/src/renderer/src/components/ContentPlaceholder.tsx
    client/src/renderer/src/components/AttachmentCard.tsx
    client/src/renderer/src/hooks/useBlockContent.ts
    client/src/renderer/src/stores/blocks.ts
    client/src/renderer/src/stores/settings.ts
    client/src/renderer/src/stores/index.ts
    client/src/renderer/src/components/StorageSettings.tsx
  </files>
  <action>
    Create `client/src/renderer/src/stores/blocks.ts` — Zustand slice for block resolution state:
    - `blockStates: Map<string, { status: 'loading' | 'loaded' | 'error', data?: string (base64), error?: string, startedAt: number }>`.
    - `requestBlock(hash: string): void` — sets status to loading with startedAt timestamp.
    - `blockLoaded(hash: string, data: string): void` — sets status to loaded with base64 data.
    - `blockFailed(hash: string, error: string): void` — sets status to error.
    - `retryBlock(hash: string): void` — resets to loading, re-triggers resolution.
    - Add to root store composition in `client/src/renderer/src/stores/index.ts`.

    Create `client/src/renderer/src/hooks/useBlockContent.ts`:
    - `useBlockContent(hash: string | null): { status: 'idle' | 'loading' | 'loaded' | 'error', data: Buffer | null, progress: 'cache' | 'fetching' | 'unavailable', retry: () => void }`:
      1. If hash is null, return idle.
      2. On mount / hash change: call `window.united.blocks.resolveBlock(hash)` via IPC.
      3. Track elapsed time for progressive feedback:
         - 0-3 seconds: progress = 'cache' (shimmer state)
         - 3-15 seconds: progress = 'fetching' ("Fetching from network...")
         - After 15 seconds: progress = 'unavailable' (error state with retry)
      4. Use `useRef` for timeouts to transition between progress states.
      5. On success: set status = 'loaded', clear timeouts.
      6. On failure after 15s: set status = 'error', progress = 'unavailable'.
      7. `retry`: re-trigger the full cascade (same code path, same progressive timeout).
      8. Cleanup timeouts on unmount.

    Create `client/src/renderer/src/components/ContentPlaceholder.tsx`:
    - Props: `width: number, height: number, progress: 'cache' | 'fetching' | 'unavailable', onRetry?: () => void, className?: string`.
    - Renders at EXACT width x height (or max-width with aspect-ratio CSS for responsive) — zero reflow per APP-04.
    - **cache state:** Render the existing SkeletonShimmer component (from Phase 1) at the specified dimensions. Consistent with existing loading patterns.
    - **fetching state:** Shimmer background with centered text "Fetching from network..." in muted color.
    - **unavailable state:** Gray background with centered broken-image icon (SVG), "Content unavailable" text, and a "Retry" button that calls onRetry. Preserve exact dimensions.
    - Use Tailwind classes consistent with existing component patterns (dark theme, CSS custom properties).
    - `aspect-ratio` CSS property derived from width/height to maintain proportions during resize.

    Create `client/src/renderer/src/components/AttachmentCard.tsx`:
    - Props: `filename: string, size: number, mimeType: string, hash?: string, onDownload?: () => void, className?: string`.
    - Renders a compact card with:
      - File type icon (SVG) based on MIME type category: image, video, audio, document (pdf), archive (zip), code, generic.
      - Filename (truncated with ellipsis if long).
      - File size formatted (KB, MB, GB).
      - Download button/icon.
    - Tailwind styled: `bg-[var(--bg-secondary)] rounded-lg p-3 flex items-center gap-3 hover:bg-[var(--bg-tertiary)]` or similar, consistent with existing dark theme.
    - Fixed dimensions: width fills container, height is constant (~60px) — no reflow.

    Update `client/src/renderer/src/stores/settings.ts`:
    - Add to SettingsSlice: `storageBudgetGb: number` (default 5), `warmTtlDays: number` (default 7).
    - Add actions: `setStorageBudget(gb: number)`, `setWarmTtl(days: number)`.
    - Actions call `window.united.blocks.setConfig(...)` to persist to block store.
    - Add to hydration: load config from block store on app start.

    Create `client/src/renderer/src/components/StorageSettings.tsx`:
    - Storage budget slider: range 1-50 GB, shows current value and usage bar.
    - Usage bar segments: P1 (green, "Protected"), P2-P3 (blue, "Active"), P4 (gray, "Seeding"), free space (dark).
    - Warm TTL slider: range 3-30 days, labeled "Keep content for X days (space permitting)" per CONTEXT.md.
    - Calls settings store actions on change.
    - Fetches current usage via `window.united.blocks.getStorageUsage()` on mount.
    - This component will be wired into the app's settings panel. For now, export it as a standalone component ready for integration.
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` — TypeScript compiles without errors.
    Verify ContentPlaceholder renders all 3 progress states.
    Verify AttachmentCard renders file metadata with type icons.
    Verify useBlockContent hook handles progressive timeout states.
    Verify StorageSettings has budget slider and TTL slider.
  </verify>
  <done>
    blocks Zustand store tracks block resolution state per hash.
    useBlockContent hook: resolves blocks via IPC with progressive timeout (0-3s shimmer, 3-15s fetching, 15s+ unavailable with retry).
    ContentPlaceholder: renders at exact dimensions with shimmer/fetching/unavailable states. Zero reflow.
    AttachmentCard: renders file metadata with type icon, size, and download trigger.
    StorageSettings: budget slider (1-50 GB), TTL slider (3-30 days), visual usage bar by tier.
    Settings store extended with storageBudgetGb and warmTtlDays.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in client/ succeeds
2. sharp installed and electron-rebuild completed
3. Micro-thumbnail generation produces small JPEG from image buffer
4. ContentPlaceholder renders at exact dimensions in all 3 states
5. useBlockContent hook progresses through loading states with correct timeouts
6. AttachmentCard displays file info with appropriate type icons
7. StorageSettings sliders control budget and TTL
</verification>

<success_criteria>
- Small content (<50KB) prepared for gossip inline embedding
- Large images get block reference with micro-thumbnail for blur preview
- Non-image files get metadata-only block reference for immediate card rendering
- Content placeholders maintain exact dimensions throughout loading lifecycle
- Progressive timeout gives continuous user feedback during P2P resolution
- Users can configure storage budget and content retention
</success_criteria>

<output>
After completion, create `.planning/phases/06-content-distribution/06-04-SUMMARY.md`
</output>
