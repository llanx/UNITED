---
phase: 06-content-distribution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/package.json
  - client/src/main/blocks/types.ts
  - client/src/main/blocks/crypto.ts
  - client/src/main/blocks/cache.ts
  - client/src/main/blocks/store.ts
  - client/src/main/blocks/tiers.ts
  - client/src/main/blocks/index.ts
  - client/src/main/db/schema.ts
  - client/src/main/ipc/blocks.ts
  - client/src/main/ipc/channels.ts
  - client/src/main/ipc/dm.ts
  - client/src/main/ws/dm-events.ts
  - client/src/main/index.ts
  - client/src/preload/index.ts
  - shared/types/ipc-bridge.ts
autonomous: true
requirements:
  - P2P-01
  - P2P-05
  - SEC-04

must_haves:
  truths:
    - "Client can store content as SHA-256 hashed blocks with the hash as the address"
    - "All blocks written to disk are encrypted with AES-256-GCM (or XChaCha20-Poly1305 fallback) using an Argon2id-derived key"
    - "Content is organized into priority tiers (P1 never evict, P2 hot, P3 warm, P4 altruistic)"
    - "Silent LRU eviction respects tier ordering and storage budget"
    - "Block store key is derived at identity unlock and zeroed on lock/quit"
    - "Received DMs are persisted to block store with P1_NEVER_EVICT tier (never evicted by LRU sweep)"
  artifacts:
    - path: "client/src/main/blocks/types.ts"
      provides: "BlockMeta, ContentTier, BlockStoreConfig types"
      contains: "ContentTier"
    - path: "client/src/main/blocks/crypto.ts"
      provides: "Block encryption/decryption and block store key derivation"
      contains: "deriveBlockStoreKey"
    - path: "client/src/main/blocks/store.ts"
      provides: "putBlock, getLocalBlock, hasBlock, deleteBlock with file-based encrypted storage"
      contains: "putBlock"
    - path: "client/src/main/blocks/cache.ts"
      provides: "L0 in-memory LRU cache with 256MB byte-size budget"
      contains: "createBlockCache"
    - path: "client/src/main/blocks/tiers.ts"
      provides: "Tier assignment, eviction sweep, budget enforcement"
      contains: "startEvictionSweep"
    - path: "client/src/main/ipc/blocks.ts"
      provides: "IPC handlers bridging renderer to block store"
      contains: "registerBlockHandlers"
  key_links:
    - from: "client/src/main/blocks/store.ts"
      to: "client/src/main/blocks/crypto.ts"
      via: "encrypt on write, decrypt on read"
      pattern: "encryptBlock|decryptBlock"
    - from: "client/src/main/blocks/store.ts"
      to: "client/src/main/blocks/cache.ts"
      via: "L0 cache updated on put and get"
      pattern: "memoryCache\\.set|memoryCache\\.get"
    - from: "client/src/main/ipc/blocks.ts"
      to: "client/src/main/blocks/index.ts"
      via: "IPC handlers call block store public API"
      pattern: "blockStore\\.putBlock|blockStore\\.getBlock"
    - from: "client/src/main/blocks/crypto.ts"
      to: "client/src/main/ipc/crypto.ts"
      via: "block store key derived alongside session key on unlock"
      pattern: "deriveBlockStoreKey"
    - from: "client/src/main/ws/dm-events.ts"
      to: "client/src/main/blocks/index.ts"
      via: "received DMs stored as P1 blocks after decryption"
      pattern: "putBlock.*P1_NEVER_EVICT"
    - from: "client/src/main/ipc/dm.ts"
      to: "client/src/main/blocks/index.ts"
      via: "history/offline DMs stored as P1 blocks after decryption"
      pattern: "putBlock.*P1_NEVER_EVICT"
---

<objective>
Client-side content-addressed block store with encrypted file storage, tiered retention, LRU eviction, and IPC bridge.

Purpose: Build the local block storage layer that all content reads and writes go through. Blocks are SHA-256 addressed, encrypted at rest with an Argon2id-derived key, organized into priority tiers, and managed within a user-configurable storage budget. This is the foundation that the cache cascade (Plan 03) and UI components (Plan 04) build upon.

Output: client/src/main/blocks/ module with store, crypto, cache, tiers, types; IPC handlers; client DB migration for block metadata.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-content-distribution/06-CONTEXT.md
@.planning/phases/06-content-distribution/06-RESEARCH.md
@client/src/main/ipc/crypto.ts
@client/src/main/db/schema.ts
@client/src/main/ipc/channels.ts
@client/src/preload/index.ts
@shared/types/ipc-bridge.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Block store types, crypto, cache, and file-based store</name>
  <files>
    client/package.json
    client/src/main/blocks/types.ts
    client/src/main/blocks/crypto.ts
    client/src/main/blocks/cache.ts
    client/src/main/blocks/store.ts
    client/src/main/db/schema.ts
  </files>
  <action>
    Install dependencies: `npm install lru-cache` in the client directory. (`sharp` and `it-length-prefixed-stream` are needed in Plans 03-04, not here.)

    Create `client/src/main/blocks/types.ts`:
    - `ContentTier` enum: P1_NEVER_EVICT = 1, P2_HOT = 2, P3_WARM = 3, P4_ALTRUISTIC = 4
    - `BlockMeta` interface: hash (string), size (number), tier (ContentTier), mimeType? (string), width? (number), height? (number), filename? (string), createdAt (string), lastAccessedAt (string)
    - `BlockStoreConfig` interface: budgetBytes (number), warmTtlDays (number)
    - Default constants: DEFAULT_BUDGET_BYTES = 5 * 1024 * 1024 * 1024 (5 GB), DEFAULT_WARM_TTL_DAYS = 7, MIN_BUDGET_GB = 1, MAX_BUDGET_GB = 50

    Create `client/src/main/blocks/crypto.ts`:
    - Import sodium from 'sodium-native' and { hkdfSync } from 'crypto'.
    - Module-level `blockStoreKey: Buffer | null` (zeroed on lock/quit like sessionSecretKey).
    - `deriveBlockStoreKey(passphrase: string, salt: Buffer): Buffer` — Argon2id with same parameters as identity (m_cost=262144*1024 bytes=256MB, t_cost=3, ALG_ARGON2ID13). Uses a DEDICATED salt separate from the identity salt, stored alongside identity in SQLite (generate random 16 bytes on first use).
    - `initBlockStoreKey(passphrase: string, salt: Buffer): void` — derives and stores key in module-level variable.
    - `clearBlockStoreKey(): void` — sodium_memzero + null.
    - `getBlockStoreKey(): Buffer | null` — returns current key.
    - `encryptBlock(data: Buffer, key: Buffer): Buffer` — check `sodium.crypto_aead_aes256gcm_is_available()`. If true: random 12-byte nonce, AES-256-GCM encrypt, return nonce || ciphertext. If false: random 24-byte nonce, XChaCha20-Poly1305 encrypt, return nonce || ciphertext. Prepend a 1-byte version tag (0x01 = AES-GCM, 0x02 = XChaCha20) so decrypt knows which algorithm was used.
    - `decryptBlock(encrypted: Buffer, key: Buffer): Buffer` — read version byte, extract nonce and ciphertext based on algorithm, decrypt and return plaintext.
    - `computeBlockHash(data: Buffer): string` — createHash('sha256').update(data).digest('hex').
    - Content-derived HKDF for server communication: `deriveContentKey(contentHashHex: string): Buffer` — hkdfSync('sha256', hashBytes, 'united-content-derived-key-v1', 'united-server-block-encryption', 32). This allows client to decrypt blocks fetched from server.

    Create `client/src/main/blocks/cache.ts`:
    - `createBlockCache(maxBytes?: number): LRUCache<string, Buffer>` — default 256MB maxSize, sizeCalculation: (value) => value.length. No TTL (eviction is purely size-based).
    - Export singleton via `getBlockCache()` / `initBlockCache()`.

    Create `client/src/main/blocks/store.ts`:
    - Uses better-sqlite3 (existing) for block_meta table and filesystem for encrypted block data.
    - Block files stored in `{userData}/blocks/` directory (using Electron app.getPath('userData')).
    - `initBlockStore(db)`: create block_meta table and block_store_config table if not exist. Create blocks directory.
    - `putBlock(data: Buffer, tier: ContentTier, meta?: Partial<BlockMeta>): string` — compute hash, check exists (dedup — if exists, maybe upgrade tier if higher priority, touch lastAccessedAt, return hash), encrypt with block store key, write file, insert metadata, update L0 cache. Return hash.
    - `getLocalBlock(hash: string): Buffer | null` — check L0 cache first, then read file + decrypt, update L0 cache on hit, touch lastAccessedAt.
    - `hasBlock(hash: string): boolean` — check metadata row exists.
    - `deleteBlock(hash: string): void` — delete file and metadata row, remove from L0 cache.
    - `touchAccess(hash: string): void` — update lastAccessedAt.
    - `maybeUpgradeTier(hash: string, newTier: ContentTier): void` — only upgrade (lower number = higher priority).
    - `getStorageUsage(): { total: number, byTier: Record<ContentTier, number> }` — aggregate sizes from metadata.
    - `getConfig(): BlockStoreConfig` / `setConfig(config: Partial<BlockStoreConfig>): void` — read/write block_store_config table.

    Add client-side DB migration for block_meta table in `client/src/main/db/schema.ts`:
    ```sql
    CREATE TABLE IF NOT EXISTS block_meta (
      hash TEXT PRIMARY KEY,
      size INTEGER NOT NULL,
      tier INTEGER NOT NULL DEFAULT 3,
      mime_type TEXT,
      width INTEGER,
      height INTEGER,
      filename TEXT,
      created_at TEXT NOT NULL DEFAULT (datetime('now')),
      last_accessed_at TEXT NOT NULL DEFAULT (datetime('now'))
    );
    CREATE INDEX IF NOT EXISTS idx_block_meta_tier_access ON block_meta(tier, last_accessed_at);

    CREATE TABLE IF NOT EXISTS block_store_config (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL
    );
    ```
    Also store the block_store_salt (16 random bytes) in block_store_config on first init.
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` — TypeScript compiles without errors.
    Verify lru-cache is in package.json dependencies.
  </verify>
  <done>
    Block types defined (ContentTier, BlockMeta, BlockStoreConfig).
    Crypto module derives block store key via Argon2id, encrypts blocks with AES-256-GCM (XChaCha20 fallback), version-tagged for algorithm detection.
    L0 memory cache bounded at 256MB with byte-size tracking.
    File-based block store: putBlock/getLocalBlock/hasBlock/deleteBlock with dedup and tier management.
    Client DB migration creates block_meta and block_store_config tables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Tier eviction, IPC bridge, and key lifecycle integration</name>
  <files>
    client/src/main/blocks/tiers.ts
    client/src/main/blocks/index.ts
    client/src/main/ipc/blocks.ts
    client/src/main/ipc/channels.ts
    client/src/main/ipc/crypto.ts
    client/src/main/index.ts
    client/src/preload/index.ts
    shared/types/ipc-bridge.ts
  </files>
  <action>
    Create `client/src/main/blocks/tiers.ts`:
    - `startEvictionSweep(budgetBytes: number): NodeJS.Timeout` — runs every 60 seconds.
      1. Calculate P1 usage (never evict).
      2. Calculate evictable budget = max(0, budgetBytes - P1 usage).
      3. Calculate evictable usage = total - P1.
      4. If under budget, return.
      5. Calculate toFree = evictableUsage - evictableBudget.
      6. Evict in tier order: P4_ALTRUISTIC first, then P3_WARM, then P2_HOT. Within each tier, LRU (oldest lastAccessedAt first). Query: `SELECT hash, size FROM block_meta WHERE tier = ? ORDER BY last_accessed_at ASC`.
      7. Delete blocks until toFree is satisfied.
    - `stopEvictionSweep(timer: NodeJS.Timeout): void` — clearInterval.
    - `checkTtlExpiry(warmTtlDays: number): void` — called within eviction sweep. For P3_WARM and P4_ALTRUISTIC blocks, check if created_at + warmTtlDays has passed. Downgrade P3 to P4 (for eventual eviction) or delete P4 blocks past TTL if budget is tight.
    - TTL is best-effort per CONTEXT.md: "Keep content for X days (space permitting)". Budget is the hard limit.

    Create `client/src/main/blocks/index.ts`:
    - Public API that re-exports and orchestrates: init(db, passphrase, salt), putBlock, getLocalBlock, hasBlock, deleteBlock, getStorageUsage, getConfig, setConfig, shutdown.
    - `init`: initialize DB tables, derive block store key, create L0 cache, start eviction sweep.
    - `shutdown`: stop eviction sweep, clear block store key, clear L0 cache.

    Create `client/src/main/ipc/blocks.ts`:
    - IPC channel constants in standard pattern: BLOCK_PUT, BLOCK_GET, BLOCK_HAS, BLOCK_DELETE, BLOCK_STORAGE_USAGE, BLOCK_GET_CONFIG, BLOCK_SET_CONFIG.
    - `registerBlockHandlers(ipcMain: IpcMain)`:
      - `handle(BLOCK_PUT, (_, data, tier, meta) => ...)` — calls blockStore.putBlock
      - `handle(BLOCK_GET, (_, hash) => ...)` — calls blockStore.getLocalBlock, returns base64-encoded data or null
      - `handle(BLOCK_HAS, (_, hash) => ...)` — calls blockStore.hasBlock
      - `handle(BLOCK_DELETE, (_, hash) => ...)` — calls blockStore.deleteBlock
      - `handle(BLOCK_STORAGE_USAGE, () => ...)` — calls blockStore.getStorageUsage
      - `handle(BLOCK_GET_CONFIG, () => ...)` — calls blockStore.getConfig
      - `handle(BLOCK_SET_CONFIG, (_, config) => ...)` — calls blockStore.setConfig, restart eviction sweep with new budget

    Update IPC channel constants in `client/src/main/ipc/channels.ts` — add BLOCK_* constants.

    Integrate block store key lifecycle with identity unlock/lock in `client/src/main/ipc/crypto.ts`:
    - On successful identity unlock (after deriveAndSetSessionKeys): also call `initBlockStoreKey(passphrase, blockStoreSalt)`. The blockStoreSalt is read from block_store_config table (generated on first use if missing).
    - On lock/quit (clearSessionKeys): also call `clearBlockStoreKey()`.

    Wire DM receive paths to persist received DMs as P1_NEVER_EVICT blocks (locked decision: received DMs must never be evicted because only sender+recipient can decrypt):

    Update `client/src/main/ws/dm-events.ts`:
    - Import `putBlock` from `../blocks/index` and `ContentTier` from `../blocks/types`.
    - In `handleDmMessage()`, after successful decryption (when `decryptionFailed === false`): call `putBlock(Buffer.from(content, 'utf-8'), ContentTier.P1_NEVER_EVICT, { mimeType: 'text/plain', filename: `dm-${msg.id}` })`. Fire-and-forget (don't await, don't block the DM event delivery). Wrap in try/catch to log but not fail the DM flow.

    Update `client/src/main/ipc/dm.ts`:
    - Import `putBlock` from `../blocks/index` and `ContentTier` from `../blocks/types`.
    - In `DM_FETCH_HISTORY` and `DM_FETCH_OFFLINE` handlers, after decrypting messages: for each successfully decrypted message (decryptionFailed === false), call `putBlock(Buffer.from(msg.content, 'utf-8'), ContentTier.P1_NEVER_EVICT, { mimeType: 'text/plain', filename: `dm-${msg.id}` })`. Fire-and-forget, wrapped in try/catch. This catches DMs fetched via REST (history scroll-back, offline sync) that didn't arrive via the WS live path.

    Update `client/src/main/index.ts`:
    - Import and call `registerBlockHandlers(ipcMain)`.
    - Initialize block store after identity unlock succeeds.

    Update `client/src/preload/index.ts`:
    - Add `blocks` namespace to the preload bridge: putBlock, getBlock, hasBlock, deleteBlock, getStorageUsage, getConfig, setConfig.

    Update `shared/types/ipc-bridge.ts`:
    - Add `BlockStorageUsage` type: { total: number, byTier: Record<number, number> }.
    - Add `BlockStoreConfig` type: { budgetBytes: number, warmTtlDays: number }.
    - Add `blocks` namespace to UnitedAPI interface with typed methods.
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` — TypeScript compiles without errors.
    Verify IPC channel constants are defined.
    Verify preload exposes blocks namespace.
  </verify>
  <done>
    Eviction sweep runs every 60s: P4 first, then P3, then P2, LRU within tier. Budget is hard limit, TTL is best-effort.
    Block store public API (index.ts) provides clean init/putBlock/getLocalBlock/shutdown interface.
    IPC handlers bridge renderer to block store for all operations.
    Block store key derived alongside session key on identity unlock, zeroed on lock/quit.
    Received DMs persisted as P1_NEVER_EVICT blocks via both WS live path and REST history/offline paths.
    Preload bridge exposes blocks namespace with typed methods.
    UnitedAPI type updated with blocks interface.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in client/ succeeds
2. lru-cache is installed in package.json
3. Block store can putBlock and getLocalBlock (data round-trips through encryption)
4. Eviction sweep respects tier ordering and budget
5. Block store key lifecycle integrated with identity unlock/lock
6. IPC handlers registered and preload bridge updated
</verification>

<success_criteria>
- Content-addressed blocks can be stored and retrieved locally
- All local blocks are encrypted at rest with a user-credential-derived key
- Tier-based eviction keeps storage within budget (P1 never evicted)
- Block store key is derived on unlock and securely zeroed on lock
- Renderer can access block store via typed IPC bridge
</success_criteria>

<output>
After completion, create `.planning/phases/06-content-distribution/06-02-SUMMARY.md`
</output>
