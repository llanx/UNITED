---
phase: 06-content-distribution
plan: 03
type: execute
wave: 2
depends_on:
  - "06-01"
  - "06-02"
files_modified:
  - client/package.json
  - client/src/main/blocks/protocol.ts
  - client/src/main/blocks/cascade.ts
  - client/src/main/blocks/index.ts
  - client/src/main/p2p/node.ts
  - client/src/main/ipc/blocks.ts
  - client/src/main/ipc/connection.ts
autonomous: true
requirements:
  - P2P-03
  - P2P-09

must_haves:
  truths:
    - "Content resolves through the 5-layer cascade: L0 memory -> L1 local store -> L2 hot peers (parallel) -> L3 peer directory -> L4 server fallback"
    - "L2 sends block requests to all connected peers in parallel and uses the first response (Promise.any)"
    - "All blocks received from peers are verified by SHA-256 hash before acceptance"
    - "Blocks fetched from server are decrypted using content-derived HKDF key"
    - "Custom /united/block/1.0.0 protocol allows peers to serve blocks to each other"
  artifacts:
    - path: "client/src/main/blocks/protocol.ts"
      provides: "Custom libp2p block exchange protocol handler and requester"
      contains: "BLOCK_PROTOCOL"
    - path: "client/src/main/blocks/cascade.ts"
      provides: "5-layer cache cascade resolver"
      contains: "resolveBlock"
  key_links:
    - from: "client/src/main/blocks/cascade.ts"
      to: "client/src/main/blocks/store.ts"
      via: "L0 and L1 layers read from local block store"
      pattern: "getLocalBlock|memoryCache\\.get"
    - from: "client/src/main/blocks/cascade.ts"
      to: "client/src/main/blocks/protocol.ts"
      via: "L2 layer fetches from connected peers"
      pattern: "fetchFromHotPeers"
    - from: "client/src/main/blocks/cascade.ts"
      to: "server REST /api/blocks/:hash"
      via: "L4 server fallback via HTTP fetch"
      pattern: "fetchFromServer"
    - from: "client/src/main/blocks/protocol.ts"
      to: "client/src/main/p2p/node.ts"
      via: "registers handler on libp2p node, dials peers for blocks"
      pattern: "node\\.handle|node\\.dialProtocol"
---

<objective>
Custom libp2p block exchange protocol and 5-layer cache cascade for content resolution.

Purpose: Wire the content resolution pipeline so that `getBlock(hash)` transparently tries memory cache, local encrypted store, connected peers (parallel), peer directory discovery, and server fallback in order. This makes content available from the fastest source while the P2P network provides decentralized availability.

Output: protocol.ts (libp2p /united/block/1.0.0 handler), cascade.ts (5-layer resolver), updated block store index and IPC bridge.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-content-distribution/06-CONTEXT.md
@.planning/phases/06-content-distribution/06-RESEARCH.md
@.planning/phases/06-content-distribution/06-02-SUMMARY.md
@client/src/main/p2p/node.ts
@client/src/main/p2p/discovery.ts
@client/src/main/ipc/connection.ts
@client/src/main/blocks/index.ts
@client/src/main/blocks/store.ts
@client/src/main/blocks/crypto.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Custom libp2p block exchange protocol</name>
  <files>
    client/package.json
    client/src/main/blocks/protocol.ts
    client/src/main/p2p/node.ts
  </files>
  <action>
    Install `it-length-prefixed-stream` in client: `npm install it-length-prefixed-stream`.

    Create `client/src/main/blocks/protocol.ts`:
    - `BLOCK_PROTOCOL = '/united/block/1.0.0'`
    - `registerBlockProtocol(node: Libp2p): void` — calls `node.handle(BLOCK_PROTOCOL, handler)`. The handler:
      1. Creates lpStream from the raw stream.
      2. Reads the requested hash (text-encoded).
      3. Looks up the block in local store via `getLocalBlock(hash)`.
      4. If found: writes the block data. If not found: writes a zero-length response.
      5. Closes the stream.
      6. Wrap in try/catch to log and suppress handler errors.

    - `fetchBlockFromPeer(node: Libp2p, peerId: PeerId, hash: string, timeout: number): Promise<Buffer>`:
      1. `dialProtocol(peerId, BLOCK_PROTOCOL, { signal: AbortSignal.timeout(timeout) })`.
      2. Create lpStream.
      3. Write the hash as UTF-8 bytes.
      4. Read the response.
      5. If empty response: throw "not found".
      6. Convert to Buffer, verify SHA-256 hash matches requested hash (critical security check). Throw if mismatch.
      7. Close stream, return data.

    - `fetchFromHotPeers(node: Libp2p, hash: string, options: { timeout: number }): Promise<Buffer | null>`:
      1. Get connected peers from `node.getConnections()` — extract unique PeerIds.
      2. If no peers, return null.
      3. Create an AbortController for cancellation.
      4. Map each peer to `fetchBlockFromPeer(node, peerId, hash, options.timeout)`.
      5. Use `Promise.any(requests)` — first successful response wins.
      6. On success: signal abort to cancel remaining requests. Return data.
      7. On AggregateError (all failed): return null.

    Update `client/src/main/p2p/node.ts`:
    - After creating the libp2p node, call `registerBlockProtocol(node)` to register the block exchange handler.
    - Export a getter for the node instance so the cascade module can access it for dialing.
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` — TypeScript compiles without errors.
    Verify BLOCK_PROTOCOL constant is exported.
    Verify registerBlockProtocol is called after node creation.
  </verify>
  <done>
    Custom /united/block/1.0.0 protocol registered on libp2p node.
    Incoming block requests served from local store.
    fetchFromHotPeers sends parallel requests to all connected peers, first response wins via Promise.any.
    All received blocks verified by SHA-256 hash before acceptance.
    AbortController cancels remaining requests after first success.
  </done>
</task>

<task type="auto">
  <name>Task 2: 5-layer cache cascade and server fallback</name>
  <files>
    client/src/main/blocks/cascade.ts
    client/src/main/blocks/index.ts
    client/src/main/ipc/blocks.ts
    client/src/main/ipc/connection.ts
  </files>
  <action>
    Create `client/src/main/blocks/cascade.ts`:
    - `resolveBlock(hash: string): Promise<Buffer | null>` — the core 5-layer cascade:

      **L0: Memory cache** (microseconds)
      - Check `memoryCache.get(hash)` from cache.ts.
      - If hit, return immediately.

      **L1: Local encrypted block store** (milliseconds)
      - Call `getLocalBlock(hash)` from store.ts.
      - If found: update L0 cache, touch access time, return.

      **L2: Hot peers — parallel fetch** (seconds)
      - Call `fetchFromHotPeers(node, hash, { timeout: 3000 })` from protocol.ts.
      - If found: call `putBlock(data, ContentTier.P3_WARM)` to persist locally, return.

      **L3: DHT/swarm discovery via peer directory**
      - Query the server's peer directory via existing WS to discover peers that might have the block.
      - Get additional peer multiaddresses from the server's peer directory (PeerDirectoryRequest via WS).
      - Attempt to fetch from discovered peers with a 5-second timeout.
      - If found: persist locally as P3_WARM, return.
      - NOTE: For v1, L3 reuses the WS-based peer directory from Phase 3 rather than implementing a full DHT. The server's peer directory serves as the discovery mechanism.

      **L4: Server fallback** (reliable)
      - HTTP GET to `{serverUrl}/api/blocks/{hash}` with JWT auth header.
      - Server returns encrypted block (content-derived HKDF encryption).
      - Client decrypts using `deriveContentKey(hash)` from crypto.ts.
      - If found: persist locally as P4_ALTRUISTIC, return.

      Return null if all layers fail (content unavailable).

    - `resolveBlockWithProgress(hash: string, onProgress: (layer: string) => void): Promise<Buffer | null>` — same cascade but calls onProgress('L0'), onProgress('L1'), etc. as each layer is attempted. This supports the progressive timeout UI feedback.

    Update `client/src/main/blocks/index.ts`:
    - Add `getBlock(hash: string): Promise<Buffer | null>` to public API — delegates to cascade.resolveBlock. This is THE canonical way to retrieve content.
    - Re-export resolveBlock and resolveBlockWithProgress for advanced use.

    Update `client/src/main/ipc/blocks.ts`:
    - Add `handle(BLOCK_RESOLVE, (_, hash) => ...)` IPC handler — calls the cascade-backed `getBlock(hash)`, returns base64-encoded data or null. This is the primary IPC method for the renderer to request content.
    - Add IPC channel constant BLOCK_RESOLVE.

    Update `client/src/main/ipc/connection.ts`:
    - Ensure the server URL and auth token are accessible to the cascade's L4 layer. The cascade needs to make authenticated HTTP requests to the server. Use the existing WS client's server URL and stored JWT access token.
  </action>
  <verify>
    Run `cd client && npx tsc --noEmit` — TypeScript compiles without errors.
    Verify resolveBlock function exists with L0-L4 cascade logic.
    Verify BLOCK_RESOLVE IPC handler is registered.
  </verify>
  <done>
    5-layer cache cascade operational: L0 memory (microseconds) -> L1 local store (milliseconds) -> L2 hot peers with parallel fetch (seconds) -> L3 peer directory discovery -> L4 server fallback.
    Server fallback decrypts content-derived HKDF blocks.
    Blocks fetched from peers/server are persisted locally.
    getBlock(hash) is the canonical content resolution API.
    BLOCK_RESOLVE IPC handler bridges cascade to renderer.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` in client/ succeeds
2. it-length-prefixed-stream is in package.json
3. Block protocol is registered on libp2p node startup
4. Cascade resolves through all 5 layers in order
5. Blocks from peers are hash-verified before acceptance
6. Server blocks are HKDF-decrypted before local storage
7. IPC BLOCK_RESOLVE handler available to renderer
</verification>

<success_criteria>
- Content resolution transparently cascades through 5 layers
- Parallel peer fetching uses first-responder-wins pattern
- All peer-received blocks are SHA-256 verified
- Server-stored blocks are decrypted using content-derived keys
- Failed resolution returns null for "content unavailable" UI state
</success_criteria>

<output>
After completion, create `.planning/phases/06-content-distribution/06-03-SUMMARY.md`
</output>
