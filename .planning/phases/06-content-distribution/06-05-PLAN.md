---
phase: 06-content-distribution
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/preload/index.ts
  - shared/types/ipc-bridge.ts
  - client/src/renderer/src/hooks/useBlockContent.ts
autonomous: true
gap_closure: true
requirements:
  - P2P-03

must_haves:
  truths:
    - "Renderer can trigger the 5-layer cache cascade (L0 memory -> L1 local -> L2 hot peers -> L3 peer directory -> L4 server) via resolveBlock IPC"
    - "Progressive timeout feedback (shimmer -> 'Fetching from network...' -> 'Content unavailable') accurately reflects network fetching when cascade runs"
  artifacts:
    - path: "client/src/preload/index.ts"
      provides: "resolveBlock entry in blocks namespace invoking IPC.BLOCK_RESOLVE"
      contains: "resolveBlock"
    - path: "shared/types/ipc-bridge.ts"
      provides: "resolveBlock method in UnitedAPI.blocks type contract"
      contains: "resolveBlock"
    - path: "client/src/renderer/src/hooks/useBlockContent.ts"
      provides: "Hook calls resolveBlock (cascade) instead of getBlock (local-only)"
      contains: "window.united.blocks.resolveBlock"
  key_links:
    - from: "client/src/renderer/src/hooks/useBlockContent.ts"
      to: "client/src/preload/index.ts"
      via: "window.united.blocks.resolveBlock(hash)"
      pattern: "window\\.united\\.blocks\\.resolveBlock"
    - from: "client/src/preload/index.ts"
      to: "client/src/main/ipc/blocks.ts"
      via: "ipcRenderer.invoke(IPC.BLOCK_RESOLVE, hash)"
      pattern: "BLOCK_RESOLVE"
---

<objective>
Wire the 5-layer cache cascade to the renderer by adding resolveBlock to the preload bridge and updating the useBlockContent hook to use it.

Purpose: The cascade (L0 memory -> L1 local -> L2 hot peers -> L3 peer directory -> L4 server fallback) is fully implemented in the main process and the BLOCK_RESOLVE IPC handler exists, but the renderer cannot reach it. The preload bridge only exposes getBlock (BLOCK_GET, local-only). This gap means content available only on peers or the server will always time out to "Content unavailable" even though the infrastructure is correct. This fix completes requirement P2P-03.

Output: Three file changes: preload bridge gains resolveBlock, type contract gains resolveBlock, hook calls resolveBlock instead of getBlock.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-content-distribution/06-VERIFICATION.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From client/src/main/ipc/channels.ts (IPC channel constants):
```typescript
BLOCK_RESOLVE: 'block:resolve',
```

From client/src/main/ipc/blocks.ts (existing BLOCK_RESOLVE handler, line 83):
```typescript
ipcMain.handle(IPC.BLOCK_RESOLVE, async (
  _event,
  hash: string
): Promise<string | null> => {
  const data = await getBlock(hash)
  return data ? data.toString('base64') : null
})
```

From client/src/preload/index.ts (existing blocks namespace, lines 211-226):
```typescript
blocks: {
  putBlock: (dataBase64: string, tier: number, meta?: ...) =>
    ipcRenderer.invoke(IPC.BLOCK_PUT, dataBase64, tier, meta),
  getBlock: (hash: string) =>
    ipcRenderer.invoke(IPC.BLOCK_GET, hash) as Promise<string | null>,
  hasBlock: (hash: string) =>
    ipcRenderer.invoke(IPC.BLOCK_HAS, hash) as Promise<boolean>,
  deleteBlock: (hash: string) =>
    ipcRenderer.invoke(IPC.BLOCK_DELETE, hash) as Promise<void>,
  getStorageUsage: () =>
    ipcRenderer.invoke(IPC.BLOCK_STORAGE_USAGE) as Promise<BlockStorageUsage>,
  getConfig: () =>
    ipcRenderer.invoke(IPC.BLOCK_GET_CONFIG) as Promise<BlockStoreConfig>,
  setConfig: (config: Partial<BlockStoreConfig>) =>
    ipcRenderer.invoke(IPC.BLOCK_SET_CONFIG, config) as Promise<void>,
},
```

From shared/types/ipc-bridge.ts (existing blocks type, lines 610-625):
```typescript
blocks: {
  putBlock(dataBase64: string, tier: number, meta?: ...): Promise<string>;
  getBlock(hash: string): Promise<string | null>;
  hasBlock(hash: string): Promise<boolean>;
  deleteBlock(hash: string): Promise<void>;
  getStorageUsage(): Promise<BlockStorageUsage>;
  getConfig(): Promise<BlockStoreConfig>;
  setConfig(config: Partial<BlockStoreConfig>): Promise<void>;
};
```

From client/src/renderer/src/hooks/useBlockContent.ts (line 94, the bug):
```typescript
window.united.blocks.getBlock(hash).then((result) => {
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add resolveBlock to preload bridge and type contract, update useBlockContent hook</name>
  <files>
    client/src/preload/index.ts
    shared/types/ipc-bridge.ts
    client/src/renderer/src/hooks/useBlockContent.ts
  </files>
  <action>
    **1. Add resolveBlock to preload bridge (`client/src/preload/index.ts`):**

    In the `blocks` namespace object (around line 211-226), add a new entry after `setConfig`:

    ```typescript
    resolveBlock: (hash: string) =>
      ipcRenderer.invoke(IPC.BLOCK_RESOLVE, hash) as Promise<string | null>,
    ```

    This wires the renderer to the BLOCK_RESOLVE IPC handler (already exists at `client/src/main/ipc/blocks.ts` line 83) which calls the 5-layer cascade via `getBlock()` from `../blocks/index`.

    **2. Add resolveBlock to type contract (`shared/types/ipc-bridge.ts`):**

    In the `UnitedAPI.blocks` interface (around lines 610-625), add after the `setConfig` method:

    ```typescript
    /** Resolve a block via the 5-layer cache cascade (L0 memory -> L1 local -> L2 hot peers -> L3 peer directory -> L4 server fallback). Returns base64-encoded data or null. */
    resolveBlock(hash: string): Promise<string | null>;
    ```

    **3. Update useBlockContent hook (`client/src/renderer/src/hooks/useBlockContent.ts`):**

    Change line 94 from:
    ```typescript
    window.united.blocks.getBlock(hash).then((result) => {
    ```
    to:
    ```typescript
    window.united.blocks.resolveBlock(hash).then((result) => {
    ```

    This single-line change routes the hook through the 5-layer cascade instead of local-only lookup. The progressive timeout state machine (3s shimmer -> "Fetching from network..." -> 15s unavailable) is already correct and will now accurately reflect the cascade's network activity.

    Also update the comment on line 103 from "Block not found locally" to "Block not found via cascade" since the resolve path now exhausts all 5 layers:
    ```typescript
    // Block not found via cascade -- wait for timeout transitions
    ```

    **IMPORTANT:** Do NOT change any other behavior. The timeout state machine, retry logic, and cleanup are all correct. Only the IPC method called needs to change.
  </action>
  <verify>
    Run `cd C:/Users/matts/united/client && npx tsc --noEmit` -- TypeScript compiles without errors.
    Verify `resolveBlock` appears in `client/src/preload/index.ts` blocks namespace.
    Verify `resolveBlock` appears in `shared/types/ipc-bridge.ts` UnitedAPI.blocks interface.
    Verify `useBlockContent.ts` calls `window.united.blocks.resolveBlock(hash)` (not getBlock).
  </verify>
  <done>
    Preload bridge exposes resolveBlock mapping to IPC.BLOCK_RESOLVE.
    Type contract includes resolveBlock(hash): Promise&lt;string | null&gt; in UnitedAPI.blocks.
    useBlockContent hook calls resolveBlock instead of getBlock -- renderer now triggers the full 5-layer cascade.
    Progressive timeout states accurately reflect cascade network activity.
  </done>
</task>

</tasks>

<verification>
1. `cd client && npx tsc --noEmit` passes -- type contract matches preload implementation
2. `resolveBlock` exists in preload blocks namespace with correct IPC channel
3. `resolveBlock` exists in UnitedAPI.blocks type contract
4. useBlockContent calls `window.united.blocks.resolveBlock(hash)` at its resolution point
5. The chain is complete: useBlockContent -> preload resolveBlock -> IPC.BLOCK_RESOLVE -> cascade getBlock -> L0/L1/L2/L3/L4
</verification>

<success_criteria>
- The renderer can trigger the full 5-layer cache cascade when resolving block content
- Content available on peers (L2) or server (L4) is now reachable from the renderer
- Progressive timeout feedback accurately corresponds to network fetching activity
- P2P-03 requirement is fully satisfied (was partial due to this wiring gap)
</success_criteria>

<output>
After completion, create `.planning/phases/06-content-distribution/06-05-SUMMARY.md`
</output>
