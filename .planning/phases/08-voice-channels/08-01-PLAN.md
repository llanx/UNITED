---
phase: 08-voice-channels
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/proto/voice.proto
  - shared/proto/ws.proto
  - server/src/voice/mod.rs
  - server/src/voice/state.rs
  - server/src/voice/signaling.rs
  - server/src/voice/turn.rs
  - server/src/db/migrations.rs
  - server/src/config.rs
  - server/src/state.rs
  - server/src/routes.rs
  - server/src/ws/protocol.rs
  - server/src/lib.rs
  - server/src/proto/mod.rs
  - server/Cargo.toml
autonomous: true
requirements:
  - VOICE-01

must_haves:
  truths:
    - "Server tracks which users are in which voice channels via in-memory state"
    - "Server relays SDP offer/answer and ICE candidates between peers without inspecting content"
    - "Server generates time-limited TURN credentials using shared secret HMAC-SHA1"
    - "Voice channel join returns participant list and ICE server configuration"
    - "Voice channel has configurable max_participants (default 8, nullable for text channels)"
  artifacts:
    - path: "shared/proto/voice.proto"
      provides: "Voice channel protobuf messages"
      contains: "VoiceJoinRequest"
    - path: "server/src/voice/state.rs"
      provides: "In-memory voice channel state"
      contains: "DashMap"
    - path: "server/src/voice/signaling.rs"
      provides: "SDP/ICE relay via WS"
      contains: "handle_voice_sdp_offer"
    - path: "server/src/voice/turn.rs"
      provides: "TURN credential generation"
      contains: "generate_turn_credentials"
  key_links:
    - from: "shared/proto/ws.proto"
      to: "shared/proto/voice.proto"
      via: "import and Envelope oneof fields 180-199"
      pattern: "voice_join_request"
    - from: "server/src/ws/protocol.rs"
      to: "server/src/voice/signaling.rs"
      via: "dispatch_payload match arms for voice payloads"
      pattern: "VoiceJoinRequest"
    - from: "server/src/voice/signaling.rs"
      to: "server/src/voice/state.rs"
      via: "voice state lookup on join/leave"
      pattern: "voice_state"
---

<objective>
Build the server-side voice signaling infrastructure: protobuf schemas for voice channel events, in-memory voice channel state management, WebSocket signaling relay for SDP/ICE, TURN credential generation, and database migration for voice channel participant limits.

Purpose: Establishes the signaling backbone that all WebRTC peer connections depend on. Without this, clients have no way to discover peers, exchange connection details, or obtain TURN relay credentials.

Output: Voice protobuf schemas, server voice module (state + signaling + TURN), WS envelope extensions, migration 8.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-voice-channels/08-CONTEXT.md
@.planning/phases/08-voice-channels/08-RESEARCH.md

@shared/proto/ws.proto
@server/src/state.rs
@server/src/config.rs
@server/src/routes.rs
@server/src/ws/protocol.rs
@server/src/ws/broadcast.rs
@server/src/db/migrations.rs
@server/src/lib.rs

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From server/src/state.rs:
```rust
pub struct AppState {
    pub db: DbPool,
    pub challenges: Arc<DashMap<String, ChallengeEntry>>,
    pub jwt_secret: Vec<u8>,
    pub encryption_key: Vec<u8>,
    pub connections: ConnectionRegistry,
    pub registration_mode: String,
    pub swarm_cmd_tx: mpsc::UnboundedSender<SwarmCommand>,
    pub peer_directory: Arc<PeerDirectory>,
    pub server_peer_id: String,
    pub libp2p_port: u16,
    pub presence: Arc<DashMap<String, PresenceInfo>>,
    pub data_dir: String,
    pub block_retention_days: Option<u32>,
    pub block_cleanup_interval_secs: Option<u64>,
    pub max_upload_size_mb: Option<u32>,
}
```

From server/src/ws/broadcast.rs:
```rust
pub fn broadcast_to_all(registry: &ConnectionRegistry, envelope: &Envelope);
pub fn send_to_user(registry: &ConnectionRegistry, user_id: &str, envelope: &Envelope);
```

From server/src/ws/protocol.rs:
```rust
pub async fn handle_binary_message(data: &[u8], tx: &mpsc::UnboundedSender<Message>, state: &AppState, user_id: &str);
async fn dispatch_payload(payload: Payload, request_id: &str, tx: &mpsc::UnboundedSender<Message>, state: &AppState, user_id: &str);
```

WS Envelope field allocation: voice events at 180-199 (per research recommendation).

Existing migrations: 1 (users), 2 (channels/roles/bans/invites), 3 (messages), 4 (chat features), 5 (DMs), 6 (blocks), 7 (media).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Voice protobuf schemas and server voice module (state, signaling, TURN)</name>
  <files>
    shared/proto/voice.proto
    shared/proto/ws.proto
    server/src/voice/mod.rs
    server/src/voice/state.rs
    server/src/voice/signaling.rs
    server/src/voice/turn.rs
    server/Cargo.toml
    server/src/proto/mod.rs
    server/src/lib.rs
  </files>
  <action>
    **1. Create `shared/proto/voice.proto`** with package `united.voice` and these messages:

    ```protobuf
    // Voice join/leave
    VoiceJoinRequest { string channel_id = 1; }
    VoiceJoinResponse { repeated VoiceParticipant participants = 1; repeated IceServer ice_servers = 2; }
    VoiceLeaveRequest { string channel_id = 1; }
    VoiceLeaveEvent { string channel_id = 1; string user_id = 2; string display_name = 3; }

    // Signaling relay (server forwards without inspection)
    VoiceSdpOffer { string target_user_id = 1; string sdp = 2; string channel_id = 3; }
    VoiceSdpAnswer { string target_user_id = 1; string sdp = 2; string channel_id = 3; }
    VoiceIceCandidate { string target_user_id = 1; string candidate_json = 2; string channel_id = 3; }

    // State updates (broadcast via WS)
    VoiceStateUpdate { string channel_id = 1; string user_id = 2; bool muted = 3; bool deafened = 4; }
    VoiceSpeakingEvent { string channel_id = 1; string user_id = 2; bool speaking = 3; }

    // Participant info
    VoiceParticipant { string user_id = 1; string display_name = 2; string pubkey = 3; bool muted = 4; bool deafened = 5; }
    VoiceParticipantJoinedEvent { string channel_id = 1; VoiceParticipant participant = 2; }

    // ICE server config (STUN + TURN)
    IceServer { repeated string urls = 1; string username = 2; string credential = 3; }
    ```

    **2. Update `shared/proto/ws.proto`:**
    - Add `import "voice.proto";`
    - Add voice field allocations in the Envelope oneof (180-199):
      ```
      united.voice.VoiceJoinRequest voice_join_request = 180;
      united.voice.VoiceJoinResponse voice_join_response = 181;
      united.voice.VoiceLeaveRequest voice_leave_request = 182;
      united.voice.VoiceLeaveEvent voice_leave_event = 183;
      united.voice.VoiceSdpOffer voice_sdp_offer = 184;
      united.voice.VoiceSdpAnswer voice_sdp_answer = 185;
      united.voice.VoiceIceCandidate voice_ice_candidate = 186;
      united.voice.VoiceStateUpdate voice_state_update = 187;
      united.voice.VoiceSpeakingEvent voice_speaking_event = 188;
      united.voice.VoiceParticipantJoinedEvent voice_participant_joined_event = 189;
      ```
    - Add field number comment: `// 180-199: Voice Channels (Phase 8)`

    **3. Create `server/src/voice/mod.rs`** re-exporting state, signaling, and turn submodules.

    **4. Create `server/src/voice/state.rs`:**
    - `VoiceChannelState`: struct with `participants: Vec<VoiceParticipantInfo>` where `VoiceParticipantInfo` has `user_id`, `display_name`, `pubkey`, `muted`, `deafened` fields.
    - `VoiceState`: wrapper around `Arc<DashMap<String, VoiceChannelState>>` (channel_id -> state).
    - Methods: `join_channel(channel_id, participant) -> Result<Vec<VoiceParticipantInfo>>` (returns existing participants, validates max_participants), `leave_channel(channel_id, user_id)`, `get_participants(channel_id) -> Vec<VoiceParticipantInfo>`, `update_state(channel_id, user_id, muted, deafened)`, `leave_all_channels(user_id) -> Vec<String>` (for disconnect cleanup, returns channel_ids user was in).
    - `join_channel` must check the channel's max_participants limit from DB. If over soft cap (8 default), allow but return a flag `quality_warning: bool`. If over admin-configured hard limit, reject with error.
    - Use `DashMap` for lock-free concurrent access (consistent with existing patterns: challenges, presence).

    **5. Create `server/src/voice/signaling.rs`:**
    - `handle_voice_join(req, request_id, tx, state, user_id)`: Look up user's display_name and pubkey from DB. Add to voice state. Generate TURN credentials. Send VoiceJoinResponse to joiner. Broadcast VoiceParticipantJoinedEvent to existing participants via `send_to_user`. If user was in another voice channel, leave that first (auto-disconnect per CONTEXT.md).
    - `handle_voice_leave(req, request_id, tx, state, user_id)`: Remove from voice state. Broadcast VoiceLeaveEvent to remaining participants.
    - `handle_voice_sdp_offer(req, tx, state, user_id)`: Relay to target user via `send_to_user`. Attach sender's user_id so target knows who sent it.
    - `handle_voice_sdp_answer(req, tx, state, user_id)`: Same relay pattern.
    - `handle_voice_ice_candidate(req, tx, state, user_id)`: Same relay pattern.
    - `handle_voice_state_update(req, tx, state, user_id)`: Update voice state (muted/deafened). Broadcast to all participants in the channel.
    - `handle_voice_speaking(req, tx, state, user_id)`: Broadcast VoiceSpeakingEvent to all participants in the channel.
    - All relay functions add the sender's user_id to the forwarded message so the recipient knows who it's from. This uses the existing `send_to_user` broadcast pattern.

    **6. Create `server/src/voice/turn.rs`:**
    - `generate_turn_credentials(username: &str, shared_secret: &str, ttl_secs: u64) -> (String, String)`: Generate time-limited TURN credentials using HMAC-SHA1 of `"{timestamp}:{username}"` with the shared secret. Returns `(turn_username, credential)` as base64.
    - `get_ice_servers(turn_config: &TurnConfig) -> Vec<IceServer>`: Build the ICE server list. Always include a STUN server (`stun:stun.l.google.com:19302` as fallback). If TURN is configured, include `turn:{host}:{port}?transport=udp` and `turn:{host}:{port}?transport=tcp` with generated credentials.
    - Add `hmac` and `sha1` crates to `server/Cargo.toml`.

    **7. Update `server/Cargo.toml`:** Add `hmac = "0.12"` and `sha1 = "0.10"` dependencies.

    **8. Update `server/src/proto/mod.rs`:** Add `pub mod voice` to include the generated voice protobuf module (following existing pattern: `pub mod voice { include!(concat!(env!("OUT_DIR"), "/united.voice.rs")); }`). Check the existing pattern in proto/mod.rs and follow it exactly.

    **9. Update `server/src/lib.rs`:** Add `pub mod voice;` to register the new module.
  </action>
  <verify>
    cd /c/Users/matts/united/server && /c/Users/matts/.cargo/bin/cargo check 2>&1 | tail -5
  </verify>
  <done>
    voice.proto defines all voice signaling messages. ws.proto has voice fields at 180-199. Server voice module compiles with state management, signaling relay, and TURN credential generation. `cargo check` passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Migration 8 (max_participants), config extension, WS dispatch, route wiring</name>
  <files>
    server/src/db/migrations.rs
    server/src/config.rs
    server/src/state.rs
    server/src/routes.rs
    server/src/ws/protocol.rs
    server/src/main.rs
  </files>
  <action>
    **1. Add Migration 8 to `server/src/db/migrations.rs`:**
    ```sql
    -- Migration 8: Voice Channels (Phase 8)
    ALTER TABLE channels ADD COLUMN max_participants INTEGER;
    ```
    This adds a nullable `max_participants` column to channels. NULL for text channels, defaults to 8 for voice channels (enforced in application logic, not DB default, since existing voice channels created in Phase 2 have no value). Voice state.join_channel reads this value to enforce limits.

    **2. Update `server/src/config.rs`:**
    - Add `TurnConfig` struct:
      ```rust
      pub struct TurnConfig {
          pub enabled: bool,           // default false
          pub host: String,            // default "127.0.0.1"
          pub port: u16,               // default 3478
          pub shared_secret: String,   // auto-generated if empty
          pub credential_ttl_secs: u64, // default 86400 (24h)
      }
      ```
    - Add `turn: Option<TurnConfig>` to `Config`.
    - Add `[turn]` section to the config template in `generate_config_template()`:
      ```toml
      # ---- TURN Relay (Voice Channels) ----
      # [turn]
      # enabled = false
      # host = "127.0.0.1"
      # port = 3478
      # shared_secret = ""  # Auto-generated on first boot if empty
      # credential_ttl_secs = 86400  # 24 hours
      ```

    **3. Update `server/src/state.rs`:**
    - Add `pub voice_state: Arc<crate::voice::state::VoiceState>` to `AppState`.
    - Add `pub turn_config: Option<crate::config::TurnConfig>` to `AppState`.

    **4. Update `server/src/main.rs`:**
    - Initialize `VoiceState::new()` and add to AppState.
    - Pass turn config from loaded Config to AppState.
    - On disconnect cleanup in the WS actor (or in the voice state module), call `voice_state.leave_all_channels(user_id)` and broadcast VoiceLeaveEvent for each channel the user was in. This handles abrupt disconnects gracefully per CONTEXT.md ("auto-reconnect silently in background, remove after 15 seconds"). NOTE: The 15-second timeout is client-side; the server removes immediately on WS close and re-adds on reconnect.

    **5. Update `server/src/ws/protocol.rs`:**
    Add dispatch arms in `dispatch_payload` for all voice payload types:
    ```rust
    Payload::VoiceJoinRequest(req) => {
        crate::voice::signaling::handle_voice_join(req, request_id, tx, state, user_id).await;
    }
    Payload::VoiceLeaveRequest(req) => {
        crate::voice::signaling::handle_voice_leave(req, request_id, tx, state, user_id).await;
    }
    Payload::VoiceSdpOffer(req) => {
        crate::voice::signaling::handle_voice_sdp_offer(req, request_id, tx, state, user_id).await;
    }
    Payload::VoiceSdpAnswer(req) => {
        crate::voice::signaling::handle_voice_sdp_answer(req, request_id, tx, state, user_id).await;
    }
    Payload::VoiceIceCandidate(req) => {
        crate::voice::signaling::handle_voice_ice_candidate(req, request_id, tx, state, user_id).await;
    }
    Payload::VoiceStateUpdate(req) => {
        crate::voice::signaling::handle_voice_state_update(req, request_id, tx, state, user_id).await;
    }
    Payload::VoiceSpeakingEvent(req) => {
        crate::voice::signaling::handle_voice_speaking(req, request_id, tx, state, user_id).await;
    }
    ```

    **6. Add voice disconnect cleanup** in `server/src/ws/actor.rs`:
    When the WS connection closes (in the existing cleanup section after the read loop), call `state.voice_state.leave_all_channels(&user_id)` and for each returned channel_id, broadcast a `VoiceLeaveEvent` to remaining participants. This ensures abrupt disconnects (network loss, app crash) properly remove users from voice channels.

    **7. Update `server/src/routes.rs`:**
    Add a REST endpoint for voice channel participants (useful for UI state hydration on reconnect):
    ```
    GET /api/voice/{channel_id}/participants -> Vec<VoiceParticipant>
    ```
    This is a simple read from the in-memory voice state. Add it to the authenticated routes group.
  </action>
  <verify>
    cd /c/Users/matts/united/server && /c/Users/matts/.cargo/bin/cargo build 2>&1 | tail -5
  </verify>
  <done>
    Migration 8 adds max_participants to channels. TURN config section available in united.toml. VoiceState integrated into AppState. All 7 voice WS payload types dispatched to signaling handlers. Voice disconnect cleanup broadcasts leave events on WS close. REST endpoint returns voice channel participants. `cargo build` succeeds.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with voice module compiled
2. `cargo build` succeeds with all new dependencies
3. voice.proto defines all 10+ message types for join, leave, signaling, state, and speaking
4. ws.proto has voice fields at 180-189
5. WS dispatch handles all voice payload types
6. TURN credential generation uses HMAC-SHA1 with configurable shared secret
7. Voice state tracks participants per channel with join/leave/disconnect cleanup
</verification>

<success_criteria>
- Server compiles and builds with complete voice signaling infrastructure
- All voice protobuf messages defined and integrated into WS Envelope
- In-memory voice state tracks who is in which voice channel
- SDP/ICE messages relay between peers via existing WS connection
- TURN credentials generated with time-limited HMAC-SHA1 mechanism
- Abrupt disconnect triggers voice leave cleanup and broadcast
- max_participants column exists on channels table
</success_criteria>

<output>
After completion, create `.planning/phases/08-voice-channels/08-01-SUMMARY.md`
</output>
