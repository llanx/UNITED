---
phase: 10-media-attachment-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/chat/messages.rs
  - client/src/main/ipc/chat.ts
  - client/src/main/ws/chat-events.ts
autonomous: true
requirements:
  - MEDIA-01
  - MEDIA-02
  - MEDIA-03
  - MEDIA-04
gap_closure: true
must_haves:
  truths:
    - "Messages loaded from REST history have block_refs populated as a typed BlockRefData[] array (not a raw JSON string)"
    - "Messages received via WebSocket live delivery have block_refs populated from the protobuf repeated BlockRef field"
    - "InlineImage, InlineVideo, ImageGrid, and AttachmentCard components render media when block_refs data is present"
    - "The upload-to-render round-trip works end-to-end: user uploads media, sends message, other users see media inline"
  artifacts:
    - path: "server/src/chat/messages.rs"
      provides: "parse_block_refs_json function that populates proto block_refs field"
      contains: "parse_block_refs_json"
    - path: "client/src/main/ipc/chat.ts"
      provides: "block_refs_json parsing in CHAT_FETCH_HISTORY and CHAT_SEND handlers"
      contains: "JSON.parse"
    - path: "client/src/main/ws/chat-events.ts"
      provides: "blockRefs to block_refs mapping in newMessageEvent handler"
      contains: "block_refs"
  key_links:
    - from: "server/src/chat/messages.rs"
      to: "protobuf ChatMessage.block_refs"
      via: "parse_block_refs_json populates vec before WS broadcast"
      pattern: "parse_block_refs_json"
    - from: "client/src/main/ipc/chat.ts"
      to: "renderer ChatMessage.block_refs"
      via: "JSON.parse(block_refs_json) in IPC handler"
      pattern: "JSON\\.parse.*block_refs_json"
    - from: "client/src/main/ws/chat-events.ts"
      to: "renderer ChatMessage.block_refs"
      via: "map msg.blockRefs to block_refs in newMessageEvent"
      pattern: "msg\\.blockRefs"
---

<objective>
Fix block_refs data wiring across all three message delivery paths so media attachments render in channel messages.

Purpose: Media components (InlineImage, InlineVideo, ImageGrid, AttachmentCard, BlurhashPlaceholder) are fully implemented and correct but receive empty `block_refs` due to three data transformation gaps: (1) server WS broadcast sends `block_refs: vec![]` instead of parsing the stored JSON, (2) client REST history handler passes raw `block_refs_json` string without parsing, (3) client WS event handler omits `block_refs` entirely from the ChatEvent. Closing these three gaps enables all MEDIA-01 through MEDIA-04 requirements to function.

Output: Three files patched (~30 lines total), media attachments render in both history and live messages.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-media-attachment-wiring/10-RESEARCH.md
@shared/proto/blocks.proto
@shared/proto/chat.proto
@shared/types/ipc-bridge.ts
@server/src/chat/messages.rs
@client/src/main/ipc/chat.ts
@client/src/main/ws/chat-events.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix server WS broadcast to populate protobuf block_refs from block_refs_json</name>
  <files>server/src/chat/messages.rs</files>
  <action>
Add a helper function `parse_block_refs_json` to `server/src/chat/messages.rs` that converts the `block_refs_json: Option<String>` into a `Vec<proto::united::blocks::BlockRef>`.

The function must:
1. Return `vec![]` if `block_refs_json` is `None`
2. Parse the JSON string as `Vec<serde_json::Value>` using `serde_json::from_str`
3. Return `vec![]` if parsing fails (graceful degradation)
4. Map each JSON object to a `proto::united::blocks::BlockRef` struct:
   - `hash`: from JSON key `"hash"` (string)
   - `size`: from JSON key `"size"` (u64)
   - `mime_type`: from JSON key `"mimeType"` (string -- camelCase in JSON, snake_case in proto)
   - `width`: from JSON key `"width"` (u32)
   - `height`: from JSON key `"height"` (u32)
   - `micro_thumbnail`: from JSON key `"microThumbnail"` (base64 string -> decode to bytes using `base64::engine::general_purpose::STANDARD.decode()`)
   - `filename`: from JSON key `"filename"` (string)
   - `blurhash`: from JSON key `"blurhash"` (string, default empty)
5. Use `filter_map` so invalid entries are skipped rather than causing a panic

Add these imports at the top of the file (alongside existing imports):
```rust
use crate::proto::blocks as proto_blocks;
use base64::Engine as _;
```

Then replace line 187 (`block_refs: vec![],`) with:
```rust
block_refs: parse_block_refs_json(&block_refs_json),
```

Remove or update the comment "Block refs are carried as JSON in REST responses, not as proto in WS" since this is no longer true.

IMPORTANT: The JSON keys are camelCase (serialized from TypeScript `BlockRefData`): `mimeType`, `microThumbnail`, `blurhash`. The proto fields are snake_case: `mime_type`, `micro_thumbnail`, `blurhash`. Map accordingly.

IMPORTANT: `base64` crate is already in Cargo.toml (version 0.22.1). `serde_json` is already in Cargo.toml (version 1). No new dependencies needed.
  </action>
  <verify>
Run `cd server && cargo check` -- compilation must succeed with no errors. Verify the `parse_block_refs_json` function exists and the `block_refs` field in the `ChatMessage` proto construction uses it.
  </verify>
  <done>
Server builds successfully. The `create_message` handler populates `block_refs` in the protobuf `ChatMessage` from the stored `block_refs_json` before WS broadcast. Empty/null/malformed JSON gracefully returns an empty vec.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix client REST history and WS event handlers to parse block_refs</name>
  <files>client/src/main/ipc/chat.ts, client/src/main/ws/chat-events.ts</files>
  <action>
**Part A: Fix `client/src/main/ipc/chat.ts` -- REST history and send handlers**

1. In the `CHAT_FETCH_HISTORY` handler (lines 100-117), change the return from a direct `apiGet<ChatHistoryResponse>` passthrough to a two-step: fetch raw response, then transform messages to parse `block_refs_json`.

   The raw server response has `block_refs_json: string | null` on each message instead of `block_refs: BlockRefData[]`. After the `apiGet` call, map over `messages` and transform each one:
   ```typescript
   const raw = await apiGet<{ messages: Array<ChatMessage & { block_refs_json?: string | null }>; has_more: boolean }>(url, path, token)
   return {
     ...raw,
     messages: raw.messages.map(msg => ({
       ...msg,
       block_refs: msg.block_refs_json
         ? JSON.parse(msg.block_refs_json)
         : undefined,
     }))
   }
   ```

   The `block_refs_json` values are already camelCase-keyed JSON matching `BlockRefData` exactly (serialized by `media.ts` via `JSON.stringify(blockRefs)`) -- no field renaming needed.

2. In the `CHAT_SEND` handler (lines 78-97), apply the same transformation to the returned `ChatMessage`. The REST response from `POST /api/channels/:id/messages` also includes `block_refs_json`:
   ```typescript
   const raw = await apiPost<ChatMessage & { block_refs_json?: string | null }>(url, `/api/channels/${channelId}/messages`, body, token)
   return {
     ...raw,
     block_refs: raw.block_refs_json
       ? JSON.parse(raw.block_refs_json)
       : undefined,
   }
   ```

Import `BlockRefData` is not needed (already typed via `ChatMessage` from `@shared/ipc-bridge`).

**Part B: Fix `client/src/main/ws/chat-events.ts` -- WS live delivery**

In the `newMessageEvent` case (lines 32-46), add `block_refs` field to the ChatEvent message object. After the `reactions: []` line (line 45), add:

```typescript
block_refs: msg.blockRefs.length > 0
  ? msg.blockRefs.map(br => ({
      hash: br.hash,
      size: Number(br.size),
      mimeType: br.mimeType,
      width: br.width,
      height: br.height,
      microThumbnail: br.microThumbnail.length > 0
        ? Buffer.from(br.microThumbnail).toString('base64')
        : undefined,
      blurhash: br.blurhash || undefined,
      filename: br.filename,
    }))
  : undefined,
```

IMPORTANT type conversions:
- `br.size` is `bigint` (protobuf-es generates `uint64` as `bigint`) -- cast with `Number()` (confirmed by existing `Number(msg.serverSequence)` pattern on line 41)
- `br.microThumbnail` is `Uint8Array` (protobuf `bytes`) -- convert to base64 string with `Buffer.from(...).toString('base64')`
- `br.blurhash` is string, use `|| undefined` to convert empty string to undefined
- All other fields map directly (string to string, number to number)
  </action>
  <verify>
Run `cd client && npx tsc --noEmit` -- TypeScript compilation must succeed with no type errors. Verify that:
1. `CHAT_FETCH_HISTORY` handler transforms `block_refs_json` into `block_refs`
2. `CHAT_SEND` handler transforms `block_refs_json` into `block_refs`
3. `chat-events.ts` maps `msg.blockRefs` to `block_refs` in the newMessageEvent case
  </verify>
  <done>
Client compiles successfully. REST history messages have `block_refs: BlockRefData[]` populated from parsed `block_refs_json`. WS live messages have `block_refs: BlockRefData[]` mapped from protobuf `repeated BlockRef`. The renderer's `MessageRow.tsx` receives populated `block_refs` and renders InlineImage/InlineVideo/ImageGrid/AttachmentCard components.
  </done>
</task>

</tasks>

<verification>
1. `cd server && cargo check` passes -- server compiles with the new `parse_block_refs_json` function
2. `cd client && npx tsc --noEmit` passes -- client compiles with the block_refs transformations
3. Code review confirms all three data paths are fixed:
   - Server WS broadcast: `block_refs` populated from `parse_block_refs_json(&block_refs_json)`
   - Client REST history: `block_refs_json` parsed via `JSON.parse()`
   - Client WS event: `msg.blockRefs` mapped to `block_refs: BlockRefData[]`
4. No new dependencies added (serde_json, base64, @bufbuild/protobuf all already present)
</verification>

<success_criteria>
- Server builds and the protobuf ChatMessage WS broadcast includes populated block_refs when block_refs_json exists
- Client TypeScript compiles and both CHAT_FETCH_HISTORY and CHAT_SEND return ChatMessage with parsed block_refs
- Client chat-events.ts maps protobuf blockRefs to BlockRefData[] in newMessageEvent handler
- All four MEDIA requirements (01-04) are unblocked: the existing UI components will render media once they receive non-empty block_refs data
</success_criteria>

<output>
After completion, create `.planning/phases/10-media-attachment-wiring/10-01-SUMMARY.md`
</output>
