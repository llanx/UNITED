---
phase: 05-direct-messages
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/proto/dm.proto
  - shared/proto/ws.proto
  - server/src/dm/mod.rs
  - server/src/dm/conversations.rs
  - server/src/dm/messages.rs
  - server/src/dm/keys.rs
  - server/src/dm/offline.rs
  - server/src/db/migrations.rs
  - server/src/db/models.rs
  - server/src/lib.rs
  - server/src/routes.rs
  - server/src/proto/mod.rs
  - server/build.rs
  - server/src/state.rs
autonomous: true
requirements: [DM-01, DM-02, SEC-05]

must_haves:
  truths:
    - "dm.proto defines all DM message types including encrypted payloads, key exchange, and conversation metadata"
    - "ws.proto Envelope has DM payload variants in fields 150-169"
    - "Migration 5 creates dm_conversations, dm_messages, dm_public_keys, and dm_offline_queue tables"
    - "POST /api/dm/keys publishes the user's X25519 public key derived from their Ed25519 identity"
    - "GET /api/dm/keys/{pubkey} retrieves another user's X25519 public key for key exchange"
    - "POST /api/dm/conversations creates or retrieves an existing DM conversation between two users"
    - "POST /api/dm/messages stores an encrypted DM blob and notifies the recipient via WS"
    - "GET /api/dm/messages/{conversation_id} returns paginated encrypted DM blobs for the conversation"
    - "GET /api/dm/offline returns encrypted DM blobs received while the user was offline"
    - "Server stores only encrypted blobs -- it cannot read DM content"
    - "Offline DM blobs older than 30 days are purged by a background cleanup task"
    - "DM events are broadcast to the specific recipient only (not all WS clients)"
  artifacts:
    - path: "shared/proto/dm.proto"
      provides: "DmConversation, EncryptedDmMessage, DmKeyExchange, offline delivery types"
      contains: "package united.dm"
    - path: "server/src/dm/conversations.rs"
      provides: "POST create/get conversation, GET list conversations endpoints"
      contains: "create_conversation"
    - path: "server/src/dm/messages.rs"
      provides: "POST send encrypted DM, GET paginated DM history endpoints"
      contains: "send_dm_message"
    - path: "server/src/dm/keys.rs"
      provides: "POST publish X25519 key, GET retrieve X25519 key endpoints"
      contains: "publish_dm_key"
    - path: "server/src/dm/offline.rs"
      provides: "GET offline messages, background cleanup task"
      contains: "get_offline_messages"
  key_links:
    - from: "server/src/dm/messages.rs"
      to: "server/src/ws/broadcast.rs"
      via: "After storing encrypted DM, send DmMessageEvent to recipient only via send_to_user"
      pattern: "send_to_user"
    - from: "server/src/dm/keys.rs"
      to: "server/src/db/migrations.rs"
      via: "Stores X25519 public keys in dm_public_keys table"
      pattern: "dm_public_keys"
    - from: "server/src/dm/offline.rs"
      to: "server/src/dm/messages.rs"
      via: "Offline queue populated when recipient has no active WS connection"
      pattern: "dm_offline_queue"
    - from: "shared/proto/ws.proto"
      to: "shared/proto/dm.proto"
      via: "import and oneof payload variants for DM events"
      pattern: "united.dm"
---

<objective>
Server-side DM infrastructure: protobuf schemas, database migration, REST endpoints for X25519 key exchange, encrypted DM storage, conversation management, offline delivery queue, and targeted WS broadcast.

Purpose: Establishes the server as an encrypted blob relay for DMs. The server never sees plaintext DM content -- it stores encrypted payloads, manages conversations, facilitates X25519 public key exchange, and queues messages for offline recipients. Without this, the client has no backend to relay encrypted DMs through.

Output: dm.proto, ws.proto extensions (fields 150-169), server dm module with REST endpoints, DB migration 5, offline queue with 30-day TTL background cleanup, targeted WS push for DM events.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-direct-messages/05-CONTEXT.md
@.planning/IDENTITY-ARCHITECTURE.md

Key existing files to reference:
@shared/proto/ws.proto (Envelope oneof, field allocation comment)
@shared/proto/chat.proto (ChatMessage pattern -- DMs follow similar structure)
@server/src/ws/broadcast.rs (broadcast_to_all, send_to_user patterns)
@server/src/db/migrations.rs (migrations 1-3 existing)
@server/src/routes.rs (existing route groups pattern)
@server/src/state.rs (AppState)
@server/src/chat/messages.rs (REST endpoint pattern for messages)
@server/src/lib.rs (module declarations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Protobuf schemas and database migration</name>
  <files>
    shared/proto/dm.proto
    shared/proto/ws.proto
    server/src/db/migrations.rs
    server/src/db/models.rs
    server/src/proto/mod.rs
    server/build.rs
  </files>
  <action>
Create `shared/proto/dm.proto` (package united.dm) with these messages:

```protobuf
syntax = "proto3";
package united.dm;

// A DM conversation between two users
message DmConversation {
  string id = 1;                    // UUID
  string participant_a_pubkey = 2;  // hex-encoded Ed25519 pubkey
  string participant_b_pubkey = 3;  // hex-encoded Ed25519 pubkey
  string participant_a_display_name = 4;
  string participant_b_display_name = 5;
  uint64 created_at = 6;           // Unix millis
  uint64 last_message_at = 7;      // Unix millis, for ordering
  string last_message_preview = 8;  // Empty string (server cannot read encrypted content)
}

// An encrypted DM message (server stores as opaque blob)
message EncryptedDmMessage {
  string id = 1;                   // UUID
  string conversation_id = 2;
  string sender_pubkey = 3;        // hex-encoded Ed25519 pubkey
  bytes encrypted_payload = 4;     // XChaCha20-Poly1305 encrypted content
  bytes nonce = 5;                 // 24-byte nonce for XChaCha20-Poly1305
  bytes ephemeral_pubkey = 6;      // Sender's ephemeral X25519 public key (for forward secrecy per-message)
  uint64 timestamp = 7;            // Unix millis (set by sender, not server)
  uint64 server_sequence = 8;      // Server-assigned ordering within conversation
  string sender_display_name = 9;  // Plaintext (for notification routing only -- not secret)
}

// X25519 public key publication
message DmPublicKey {
  string ed25519_pubkey = 1;       // hex-encoded Ed25519 public key (identity key)
  bytes x25519_pubkey = 2;         // 32-byte X25519 public key derived from Ed25519
  uint64 published_at = 3;         // Unix millis
}

// Events
message DmMessageEvent {
  EncryptedDmMessage message = 1;
}

message DmConversationCreatedEvent {
  DmConversation conversation = 1;
}

message DmKeyRotatedEvent {
  string user_pubkey = 1;          // Ed25519 pubkey of user who rotated
  bytes new_x25519_pubkey = 2;     // New X25519 public key
  uint64 timestamp = 3;
}

// Request/Response for REST-over-WS (if needed)
message DmHistoryRequest {
  string conversation_id = 1;
  uint64 before_sequence = 2;
  uint32 limit = 3;
}

message DmHistoryResponse {
  repeated EncryptedDmMessage messages = 1;
  bool has_more = 2;
}

message DmConversationListRequest {}

message DmConversationListResponse {
  repeated DmConversation conversations = 1;
}

message DmOfflineMessagesResponse {
  repeated EncryptedDmMessage messages = 1;
}
```

Modify `shared/proto/ws.proto`:
- Add import: `import "dm.proto";`
- Add field allocation comment: `// 150-169: Direct Messages (Phase 5)`
- Add to Envelope oneof payload (fields 150-161):
  - united.dm.DmMessageEvent dm_message_event = 150
  - united.dm.DmConversationCreatedEvent dm_conversation_created_event = 151
  - united.dm.DmKeyRotatedEvent dm_key_rotated_event = 152
  - united.dm.DmHistoryRequest dm_history_request = 153
  - united.dm.DmHistoryResponse dm_history_response = 154
  - united.dm.DmConversationListRequest dm_conversation_list_request = 155
  - united.dm.DmConversationListResponse dm_conversation_list_response = 156
  - united.dm.DmOfflineMessagesResponse dm_offline_messages_response = 157

Add Migration 5 (or the next sequential migration number -- check what exists) to `server/src/db/migrations.rs`:
```sql
-- Migration 5: Direct Messages (Phase 5)

-- X25519 public keys for DM key exchange
-- Ed25519 -> X25519 conversion is done client-side; server stores the result
CREATE TABLE dm_public_keys (
    ed25519_pubkey TEXT PRIMARY KEY,
    x25519_pubkey BLOB NOT NULL,
    published_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- DM conversations (one-to-one only in v1)
CREATE TABLE dm_conversations (
    id TEXT PRIMARY KEY,
    participant_a TEXT NOT NULL,
    participant_b TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    last_message_at TEXT,
    UNIQUE(participant_a, participant_b)
);
CREATE INDEX idx_dm_conversations_a ON dm_conversations(participant_a);
CREATE INDEX idx_dm_conversations_b ON dm_conversations(participant_b);

-- Encrypted DM messages (server stores opaque encrypted blobs)
CREATE TABLE dm_messages (
    id TEXT PRIMARY KEY,
    conversation_id TEXT NOT NULL,
    sender_pubkey TEXT NOT NULL,
    encrypted_payload BLOB NOT NULL,
    nonce BLOB NOT NULL,
    ephemeral_pubkey BLOB,
    timestamp INTEGER NOT NULL,
    server_sequence INTEGER NOT NULL,
    sender_display_name TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (conversation_id) REFERENCES dm_conversations(id) ON DELETE CASCADE
);
CREATE INDEX idx_dm_messages_conv_seq ON dm_messages(conversation_id, server_sequence);

-- Offline delivery queue (messages waiting for recipient to come online)
-- Cleaned up after 30 days
CREATE TABLE dm_offline_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    recipient_pubkey TEXT NOT NULL,
    dm_message_id TEXT NOT NULL,
    queued_at TEXT NOT NULL DEFAULT (datetime('now')),
    delivered INTEGER NOT NULL DEFAULT 0,
    FOREIGN KEY (dm_message_id) REFERENCES dm_messages(id) ON DELETE CASCADE
);
CREATE INDEX idx_dm_offline_recipient ON dm_offline_queue(recipient_pubkey, delivered);
```

IMPORTANT: The UNIQUE constraint on (participant_a, participant_b) requires normalizing the order -- always store the lexicographically smaller pubkey as participant_a. This prevents duplicate conversations for the same pair.

Add DmConversation, DmMessage, DmPublicKey, DmOfflineQueueEntry models to `server/src/db/models.rs`.

Update `server/build.rs` to compile dm.proto (add to the prost_build inputs list alongside existing protos).
Update `server/src/proto/mod.rs` to add the dm proto module following the existing pattern.
  </action>
  <verify>
Run `cd server && /c/Users/matts/.cargo/bin/cargo build` -- compilation succeeds with new proto types and migration.
Verify proto types are generated: check that `united::dm::EncryptedDmMessage` and `united::dm::DmConversation` are accessible in Rust code.
Run `cd server && /c/Users/matts/.cargo/bin/cargo test` -- all existing tests still pass.
  </verify>
  <done>
dm.proto exists with all DM message types (conversations, encrypted messages, key exchange, events). ws.proto has Phase 5 payload variants (fields 150-157). Migration creates dm_public_keys, dm_conversations, dm_messages, and dm_offline_queue tables. All proto types compile and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: REST endpoints for key exchange, conversations, messages, and offline delivery</name>
  <files>
    server/src/dm/mod.rs
    server/src/dm/conversations.rs
    server/src/dm/messages.rs
    server/src/dm/keys.rs
    server/src/dm/offline.rs
    server/src/lib.rs
    server/src/routes.rs
    server/src/state.rs
  </files>
  <action>
Create `server/src/dm/mod.rs` with module declarations:
```rust
pub mod conversations;
pub mod keys;
pub mod messages;
pub mod offline;
```

Create `server/src/dm/keys.rs`:
- `POST /api/dm/keys` -- Publish X25519 public key. JWT auth required (Claims extractor). Body: `{ "x25519_pubkey": "<hex>" }`. The client derives X25519 from Ed25519 using `crypto_sign_ed25519_pk_to_curve25519` (sodium) and publishes the result. Server stores it in dm_public_keys table keyed by the user's Ed25519 pubkey (from JWT claims). Returns 200 with the published key.
  - UPSERT pattern: INSERT OR REPLACE to handle key rotation (user publishes a new X25519 key after Ed25519 rotation).
  - When a key is updated, broadcast DmKeyRotatedEvent to all WS clients so they know to re-derive shared secrets.
- `GET /api/dm/keys/{ed25519_pubkey}` -- Retrieve another user's X25519 public key. JWT auth required. Returns 200 with `{ "ed25519_pubkey": "...", "x25519_pubkey": "<hex>", "published_at": "..." }` or 404 if the user hasn't published a DM key yet.

Create `server/src/dm/conversations.rs`:
- `POST /api/dm/conversations` -- Create or get DM conversation. JWT auth required. Body: `{ "recipient_pubkey": "<hex ed25519>" }`. Server:
  1. Validate recipient exists in users table (by public_key).
  2. Normalize participant order: lexicographically sort the two Ed25519 pubkeys (hex strings) so participant_a < participant_b. This ensures uniqueness.
  3. Check if conversation already exists (SELECT WHERE participant_a = ?1 AND participant_b = ?2).
  4. If exists, return the existing conversation. If not, INSERT and return new conversation.
  5. Return 200 with DmConversation (id, participants, display names, created_at).
  6. If the conversation is new, broadcast DmConversationCreatedEvent to BOTH participants via send_to_user.
- `GET /api/dm/conversations` -- List all DM conversations for the authenticated user. JWT auth required. Query: SELECT from dm_conversations WHERE participant_a = ?1 OR participant_b = ?1, ordered by last_message_at DESC (most recent first, per CONTEXT.md decision). Include display names from users table via JOIN. Return array of DmConversation objects.
  - IMPORTANT: last_message_at can be NULL for new conversations with no messages yet. Handle NULL -> sort to end.

Create `server/src/dm/messages.rs`:
- `POST /api/dm/messages` -- Send encrypted DM. JWT auth required. Body:
  ```json
  {
    "conversation_id": "uuid",
    "encrypted_payload": "<base64>",
    "nonce": "<base64>",
    "ephemeral_pubkey": "<base64>",
    "timestamp": 1709000000000
  }
  ```
  Server:
  1. Validate the sender is a participant in the conversation.
  2. Generate UUID for message id.
  3. Assign server_sequence (atomic increment for the conversation).
  4. Look up sender's display_name from users table.
  5. Persist to dm_messages table (store encrypted_payload, nonce, ephemeral_pubkey as BLOBs).
  6. Update dm_conversations.last_message_at to current time.
  7. Determine the other participant (the one who is NOT the sender).
  8. Check if recipient has an active WS connection (via ConnectionRegistry).
     - If online: Send DmMessageEvent to recipient via send_to_user (targeted push, NOT broadcast_to_all).
     - If offline: Insert into dm_offline_queue with recipient_pubkey and dm_message_id.
  9. Also send DmMessageEvent back to sender (for multi-device -- sender's other devices should see it).
  10. Return 201 with the EncryptedDmMessage (includes server_sequence).

  CRITICAL: The server does NOT inspect encrypted_payload. It's an opaque blob. The server cannot read, search, or moderate DM content. This is by design per SEC-05.

- `GET /api/dm/messages/{conversation_id}?before={seq}&limit={n}` -- Paginated DM history. JWT auth required. Validate caller is a participant. Default limit 50, max 100. Query dm_messages WHERE conversation_id = ?1 AND server_sequence < ?2 ORDER BY server_sequence DESC LIMIT ?3. Return JSON with messages array and has_more boolean. Use `spawn_blocking` for DB access per established pattern.

Create `server/src/dm/offline.rs`:
- `GET /api/dm/offline` -- Retrieve offline messages for the authenticated user. JWT auth required. Query dm_offline_queue WHERE recipient_pubkey = ?1 AND delivered = 0, JOIN dm_messages to get full encrypted message data. Mark returned entries as delivered = 1. Return array of EncryptedDmMessage.
  - This endpoint is called by the client on connection/reconnection to fetch missed DMs.
- `POST /api/dm/offline/ack` -- Acknowledge offline delivery. JWT auth required. Body: `{ "message_ids": ["uuid1", "uuid2"] }`. Mark entries in dm_offline_queue as delivered = 1. Return 200.
- Background cleanup task: Spawn a tokio task on server startup that runs every hour. DELETE FROM dm_offline_queue WHERE queued_at < datetime('now', '-30 days'). Also DELETE FROM dm_messages WHERE created_at < datetime('now', '-30 days') AND conversation_id IN (conversations where neither participant has fetched this message -- OR just keep messages indefinitely since they're encrypted blobs and storage is cheap). Actually, per CONTEXT.md: "Server holds encrypted blobs for offline delivery for 30 days. After that, undelivered messages are lost." So: DELETE from dm_offline_queue WHERE queued_at < 30 days. Messages in dm_messages persist indefinitely (they're part of conversation history that clients may re-fetch). Only the offline QUEUE entries expire.

Add `pub mod dm;` to `server/src/lib.rs`.

Add DM routes to `server/src/routes.rs`:
```rust
let dm_routes = Router::new()
    .route("/api/dm/keys", axum::routing::post(dm::keys::publish_dm_key))
    .route("/api/dm/keys/{pubkey}", axum::routing::get(dm::keys::get_dm_key))
    .route("/api/dm/conversations", axum::routing::post(dm::conversations::create_conversation))
    .route("/api/dm/conversations", axum::routing::get(dm::conversations::list_conversations))
    .route("/api/dm/messages", axum::routing::post(dm::messages::send_dm_message))
    .route("/api/dm/messages/{conversation_id}", axum::routing::get(dm::messages::get_dm_messages))
    .route("/api/dm/offline", axum::routing::get(dm::offline::get_offline_messages))
    .route("/api/dm/offline/ack", axum::routing::post(dm::offline::ack_offline_messages));
```
Merge dm_routes into the main Router.

Spawn the offline cleanup background task in server startup (main.rs or wherever the server is initialized), similar to how the rate limiter cleanup task is spawned.

No changes to AppState are required -- all DM state is in the database. The ConnectionRegistry already supports send_to_user for targeted WS delivery.
  </action>
  <verify>
Run `cd server && /c/Users/matts/.cargo/bin/cargo build` -- compiles with new dm module and routes.
Run `cd server && /c/Users/matts/.cargo/bin/cargo test` -- all existing tests pass (no AppState changes needed for DM).
Verify: POST /api/dm/keys, GET /api/dm/keys/{pubkey}, POST /api/dm/conversations, GET /api/dm/conversations, POST /api/dm/messages, GET /api/dm/messages/{id}, GET /api/dm/offline, POST /api/dm/offline/ack all compile and are wired into the router.
  </verify>
  <done>
Server DM module complete: X25519 key publication and retrieval, conversation create/list with normalized participant order, encrypted message send with targeted WS delivery (send_to_user, not broadcast_to_all), paginated message history, offline queue with 30-day TTL cleanup. Server stores only encrypted blobs -- zero plaintext DM content touches the server. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
- `cargo build` succeeds with all new proto types and dm module
- `cargo test` passes all existing tests
- Proto schemas follow existing naming conventions (united.dm)
- WS Envelope field numbers are in the 150-169 range per allocation plan
- Migration is additive (CREATE TABLE only), no data loss
- POST /api/dm/messages stores encrypted blob and delivers via targeted WS push
- GET /api/dm/offline returns pending messages for reconnecting clients
- Conversation participant order is normalized (lexicographic) to prevent duplicates
- Offline cleanup task runs hourly and purges entries older than 30 days
</verification>

<success_criteria>
1. dm.proto defines DmConversation, EncryptedDmMessage, DmPublicKey, and all events
2. ws.proto Envelope has 8 new DM payload variants (fields 150-157)
3. Migration creates dm_public_keys, dm_conversations, dm_messages, dm_offline_queue tables
4. POST /api/dm/keys publishes X25519 public key derived from Ed25519
5. POST /api/dm/conversations creates or returns existing conversation with normalized ordering
6. POST /api/dm/messages stores encrypted blob and pushes DmMessageEvent to recipient
7. GET /api/dm/messages/{id} returns paginated encrypted history
8. GET /api/dm/offline returns pending offline messages and marks them delivered
9. Offline queue entries older than 30 days are purged by background task
10. All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-direct-messages/05-01-SUMMARY.md`
</output>
