---
phase: 05-direct-messages
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/main/ipc/channels.ts
  - client/src/main/ipc/dm.ts
  - client/src/main/ipc/dm-crypto.ts
  - client/src/main/ws/client.ts
  - client/src/renderer/src/stores/dm.ts
  - client/src/renderer/src/stores/index.ts
  - client/src/renderer/src/hooks/useDm.ts
  - client/src/preload/index.ts
  - shared/src/ipc-bridge.ts
autonomous: true
requirements: [DM-01, DM-02, SEC-05]

must_haves:
  truths:
    - "Client can derive X25519 public key from Ed25519 identity and publish it to the server"
    - "Client can perform X25519 key exchange to derive a shared secret for each DM conversation"
    - "Client encrypts DM messages with XChaCha20-Poly1305 using the per-conversation shared secret before sending"
    - "Client decrypts incoming DM messages using the shared secret derived from the sender's X25519 key"
    - "DM IPC handlers exist for all DM operations (list conversations, send message, fetch history, publish key)"
    - "Zustand DM store tracks conversations ordered by most recent activity and per-conversation messages"
    - "WS push events for DM messages are forwarded from main process to renderer"
    - "Client fetches offline DMs on connection and merges them into conversation state"
    - "Decrypted DM content is stored locally in the client SQLite for history scrollback"
    - "Key exchange failure (peer key unavailable) is surfaced as a state the UI can check"
  artifacts:
    - path: "client/src/main/ipc/dm-crypto.ts"
      provides: "X25519 key derivation, shared secret computation, encrypt/decrypt DM content"
      contains: "deriveX25519FromEd25519"
    - path: "client/src/main/ipc/dm.ts"
      provides: "IPC handlers for DM conversations, messages, key exchange"
      contains: "registerDmHandlers"
    - path: "client/src/renderer/src/stores/dm.ts"
      provides: "Zustand slice for DM conversations and per-conversation messages"
      contains: "createDmSlice"
    - path: "client/src/renderer/src/hooks/useDm.ts"
      provides: "Hook for DM subscription, message loading, and send"
      contains: "useDm"
  key_links:
    - from: "client/src/main/ipc/dm-crypto.ts"
      to: "client/src/main/ipc/crypto.ts"
      via: "Uses getSessionKeys() to access Ed25519 keypair for X25519 derivation"
      pattern: "getSessionKeys"
    - from: "client/src/main/ipc/dm.ts"
      to: "client/src/main/ipc/dm-crypto.ts"
      via: "Encrypts before sending, decrypts after receiving"
      pattern: "encryptDmMessage"
    - from: "client/src/main/ws/client.ts"
      to: "client/src/renderer/src/stores/dm.ts"
      via: "WS DM push events forwarded via IPC, store handles in event listener"
      pattern: "PUSH_DM_EVENT"
    - from: "client/src/renderer/src/hooks/useDm.ts"
      to: "client/src/renderer/src/stores/dm.ts"
      via: "Hook reads conversations and messages from store, triggers IPC for mutations"
      pattern: "useDm"
---

<objective>
Client DM data layer: X25519 key exchange crypto module, IPC handlers for all DM operations, Zustand store for conversations and messages, WS event forwarding, offline message retrieval, and local encrypted storage.

Purpose: Establishes the entire client-side DM pipeline -- cryptographic key exchange, encryption/decryption of messages, communication with the server's DM endpoints, and state management. The DM UI (plan 03) consumes this data layer without building any crypto or data plumbing itself.

Output: dm-crypto.ts (X25519 key derivation, encrypt/decrypt), dm.ts (IPC handlers), dm.ts store (Zustand slice), useDm.ts hook, WS event forwarding for DM events, preload bridge extensions.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-direct-messages/05-CONTEXT.md
@.planning/IDENTITY-ARCHITECTURE.md

Key existing files to reference:
@client/src/main/ipc/crypto.ts (getSessionKeys, bufToHex, hexToBuf, encrypt/decrypt with XChaCha20-Poly1305)
@client/src/main/ipc/connection.ts (apiGet/apiPost/apiPut helpers, getAccessToken, getServerUrl pattern)
@client/src/main/ipc/channels.ts (IPC constant naming pattern)
@client/src/main/ws/client.ts (WS push event forwarding pattern)
@client/src/renderer/src/stores/channels.ts (Zustand slice pattern: StateCreator<RootStore, [], [], SliceType>)
@client/src/renderer/src/stores/index.ts (Root store composition via spread)
@client/src/preload/index.ts (preload bridge pattern)
@shared/src/ipc-bridge.ts (type definitions for IPC)
</context>

<tasks>

<task type="auto">
  <name>Task 1: DM crypto module and IPC handlers</name>
  <files>
    client/src/main/ipc/dm-crypto.ts
    client/src/main/ipc/dm.ts
    client/src/main/ipc/channels.ts
    client/src/main/ws/client.ts
  </files>
  <action>
**DM Crypto Module:**

Create `client/src/main/ipc/dm-crypto.ts`:

This module handles the E2E encryption for DMs. It uses sodium-native (already a project dependency) for all crypto operations.

```typescript
import sodium from 'sodium-native'
import { getSessionKeys, bufToHex, hexToBuf } from './crypto'
```

Functions to implement:

1. `deriveX25519FromEd25519()`: Derive X25519 keypair from the session Ed25519 keypair.
   - Use `sodium.crypto_sign_ed25519_pk_to_curve25519(x25519Pub, ed25519Pub)` for public key.
   - Use `sodium.crypto_sign_ed25519_sk_to_curve25519(x25519Sec, ed25519Sec)` for secret key.
   - Returns `{ publicKey: Buffer, secretKey: Buffer }`.
   - Throws if session keys not unlocked.

2. `computeSharedSecret(ourX25519Secret: Buffer, theirX25519Public: Buffer): Buffer`: Compute X25519 shared secret.
   - Use `sodium.crypto_scalarmult(sharedSecret, ourX25519Secret, theirX25519Public)`.
   - Returns 32-byte shared secret.
   - IMPORTANT: Hash the raw shared secret with `sodium.crypto_generichash(derivedKey, sharedSecret)` (BLAKE2b) before using as encryption key. Raw X25519 output should never be used directly as a symmetric key (standard practice per NaCl/libsodium docs).

3. `encryptDmMessage(plaintext: string, sharedSecret: Buffer): { encrypted: Buffer, nonce: Buffer }`:
   - Generate random 24-byte nonce: `sodium.randombytes_buf(nonce)`.
   - Encrypt with XChaCha20-Poly1305: `sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(ciphertext, Buffer.from(plaintext, 'utf-8'), null, null, nonce, sharedSecret)`.
   - Returns encrypted buffer and nonce.

4. `decryptDmMessage(encrypted: Buffer, nonce: Buffer, sharedSecret: Buffer): string`:
   - Decrypt with XChaCha20-Poly1305: `sodium.crypto_aead_xchacha20poly1305_ietf_decrypt(plaintext, null, encrypted, null, nonce, sharedSecret)`.
   - Returns plaintext string (UTF-8).
   - Throws on decryption failure (tampered or wrong key).

5. `getOrPublishDmKey(serverUrl: string, token: string): Promise<string>`: Ensure user's X25519 key is published.
   - Derive X25519 from Ed25519 session keys.
   - POST to `/api/dm/keys` with `{ x25519_pubkey: bufToHex(x25519Pub) }`.
   - Return the hex-encoded X25519 public key.

6. `fetchPeerDmKey(serverUrl: string, token: string, peerEd25519Pubkey: string): Promise<Buffer | null>`:
   - GET `/api/dm/keys/{peerEd25519Pubkey}`.
   - Return the X25519 public key as Buffer, or null if not published.

7. In-memory shared secret cache: `Map<string, Buffer>` keyed by conversation_id. Avoids recomputing X25519 shared secret on every message. Clear on session lock/quit.
   - `getOrComputeSharedSecret(conversationId: string, peerEd25519Pubkey: string, serverUrl: string, token: string): Promise<Buffer>`:
     1. Check cache.
     2. If miss: fetch peer's X25519 public key, derive our X25519 secret, compute shared secret, cache it.
     3. Return shared secret.
   - `clearSharedSecretCache()`: Zero and clear all cached secrets. Called on identity lock/quit.

**IPC Handlers:**

Create `client/src/main/ipc/dm.ts` with `registerDmHandlers(ipcMain)`:

Follow the established IPC pattern from connection.ts: use apiGet/apiPost helpers, getAccessToken()/getServerUrl() from './auth'.

- `DM_PUBLISH_KEY` handler: Call `getOrPublishDmKey(serverUrl, token)`. Return the published X25519 key hex. Called once on app startup after authentication.

- `DM_LIST_CONVERSATIONS` handler: GET `/api/dm/conversations` with auth token. Return array of DmConversation objects.

- `DM_CREATE_CONVERSATION` handler: Takes `{ recipientPubkey: string }`. POST `/api/dm/conversations` with `{ recipient_pubkey }`. Return DmConversation.

- `DM_SEND_MESSAGE` handler: Takes `{ conversationId: string, recipientPubkey: string, content: string }`.
  1. Get shared secret via `getOrComputeSharedSecret(conversationId, recipientPubkey, serverUrl, token)`.
  2. If shared secret is null (peer key unavailable), return `{ error: 'key_unavailable', message: 'Recipient has not published encryption keys' }`.
  3. Encrypt: `encryptDmMessage(content, sharedSecret)`.
  4. POST `/api/dm/messages` with `{ conversation_id, encrypted_payload: base64(encrypted), nonce: base64(nonce), timestamp: Date.now() }`.
  5. Return the server response (EncryptedDmMessage with server_sequence) PLUS the decrypted content (so the sender's UI can display it immediately without re-decrypting).

- `DM_FETCH_HISTORY` handler: Takes `{ conversationId: string, recipientPubkey: string, beforeSequence?: number, limit?: number }`.
  1. GET `/api/dm/messages/{conversationId}?before={seq}&limit={n}` with auth token.
  2. Get shared secret via `getOrComputeSharedSecret`.
  3. Decrypt each message's encrypted_payload using the shared secret and nonce.
  4. Return array of decrypted messages (with plaintext content) plus has_more flag.
  5. On decryption failure for individual messages: include the message with `content: "[Unable to decrypt]"` and a flag `decryptionFailed: true`.

- `DM_FETCH_OFFLINE` handler: GET `/api/dm/offline` with auth token. Decrypt each message. Return decrypted messages grouped by conversation_id. Called on connection/reconnection.

- `DM_DELETE_LOCAL` handler: Takes `{ conversationId: string, messageId: string }`. Delete from local SQLite only. No server call per CONTEXT.md ("Delete for self only").

- `DM_GET_PEER_KEY_STATUS` handler: Takes `{ peerPubkey: string }`. Check if peer has published an X25519 key. Return `{ available: boolean }`. Used by UI to show "Waiting for encryption keys" state.

**IPC Channel Constants:**

Extend `client/src/main/ipc/channels.ts` with:
```typescript
// Direct Messages
DM_PUBLISH_KEY: 'dm:publish-key',
DM_LIST_CONVERSATIONS: 'dm:list-conversations',
DM_CREATE_CONVERSATION: 'dm:create-conversation',
DM_SEND_MESSAGE: 'dm:send-message',
DM_FETCH_HISTORY: 'dm:fetch-history',
DM_FETCH_OFFLINE: 'dm:fetch-offline',
DM_DELETE_LOCAL: 'dm:delete-local',
DM_GET_PEER_KEY_STATUS: 'dm:get-peer-key-status',
DM_BLOCK_USER: 'dm:block-user',
DM_UNBLOCK_USER: 'dm:unblock-user',

// Push events (main -> renderer)
PUSH_DM_EVENT: 'dm:event',
PUSH_DM_KEY_ROTATED: 'dm:key-rotated',
```

**WS Event Forwarding:**

Modify `client/src/main/ws/client.ts` (or the WS message handler):
- When a WS push message is received, check for DM payload types:
  - DmMessageEvent -> Decrypt the message using the shared secret cache. Forward via `webContents.send(IPC.PUSH_DM_EVENT, { type: 'new', message: decryptedMessage })` to all renderer windows.
  - DmConversationCreatedEvent -> Forward as `{ type: 'conversation-created', conversation }`.
  - DmKeyRotatedEvent -> Clear the shared secret cache for conversations involving this user. Forward via `IPC.PUSH_DM_KEY_ROTATED`.
- For incoming DMs: Check if notification should fire (user is in a different view). Send Electron notification with sender name and "New direct message" (do NOT include content in notification -- it's E2E encrypted and the notification may be logged by OS).

Register DM handlers in the main process IPC setup (wherever other handlers are registered -- typically main/index.ts or main/ipc/index.ts). Call `registerDmHandlers(ipcMain)`.
  </action>
  <verify>
`cd client && npx tsc --noEmit` -- TypeScript compiles with new DM crypto module and IPC handlers (some errors may exist from Phase 4 unbuilt code, but no new errors from Phase 5 DM code).
Verify sodium-native crypto functions: crypto_sign_ed25519_pk_to_curve25519 and crypto_scalarmult are available in the sodium-native API.
Verify IPC channel constants are unique and don't collide with existing ones.
  </verify>
  <done>
DM crypto module implements X25519 key derivation from Ed25519, shared secret computation (X25519 + BLAKE2b), XChaCha20-Poly1305 encrypt/decrypt with per-message nonce. IPC handlers cover: publish key, list conversations, create conversation, send encrypted message, fetch and decrypt history, offline message retrieval, local delete, peer key status check. WS push events forward decrypted DM messages to renderer. Shared secret cache avoids redundant key exchange. All crypto operations use sodium-native.
  </done>
</task>

<task type="auto">
  <name>Task 2: Zustand DM store, hook, and preload bridge</name>
  <files>
    client/src/renderer/src/stores/dm.ts
    client/src/renderer/src/stores/index.ts
    client/src/renderer/src/hooks/useDm.ts
    client/src/preload/index.ts
    shared/src/ipc-bridge.ts
  </files>
  <action>
**TypeScript Types:**

Add DM types to `shared/src/ipc-bridge.ts` (or create `shared/src/dm-types.ts` if the file is getting large):

```typescript
export interface DmConversation {
  id: string
  participantAPubkey: string
  participantBPubkey: string
  participantADisplayName: string
  participantBDisplayName: string
  createdAt: number       // Unix millis
  lastMessageAt: number   // Unix millis
}

export interface DecryptedDmMessage {
  id: string
  conversationId: string
  senderPubkey: string
  senderDisplayName: string
  content: string         // Decrypted plaintext
  timestamp: number       // Unix millis
  serverSequence: number
  decryptionFailed?: boolean  // True if message couldn't be decrypted
}

export interface DmEvent {
  type: 'new' | 'conversation-created' | 'key-rotated'
  message?: DecryptedDmMessage
  conversation?: DmConversation
  userPubkey?: string      // For key-rotated events
}

export interface DmKeyStatus {
  available: boolean
}
```

**Zustand DM Store:**

Create `client/src/renderer/src/stores/dm.ts`:

```typescript
interface ConversationMessages {
  messages: DecryptedDmMessage[]
  oldestLoaded: number | null
  newestLoaded: number | null
  hasMoreHistory: boolean
}

interface DmSlice {
  // State
  dmConversations: DmConversation[]
  dmMessages: Record<string, ConversationMessages>  // keyed by conversation_id
  activeDmConversationId: string | null
  dmUnreadCounts: Record<string, number>   // per-conversation unread count
  dmView: boolean                          // true when user is in DM mode (vs channel mode)
  dmEncryptionBannerDismissed: boolean     // per CONTEXT.md: dismissible first-time banner
  dmKeyStatus: Record<string, boolean>     // per-pubkey: whether peer's X25519 key is available

  // Actions
  loadConversations: () => Promise<void>
  setActiveDmConversation: (id: string | null) => void
  setDmView: (active: boolean) => void
  loadDmMessages: (conversationId: string, recipientPubkey: string) => Promise<void>
  loadOlderDmMessages: (conversationId: string, recipientPubkey: string) => Promise<void>
  appendDmMessage: (conversationId: string, message: DecryptedDmMessage) => void
  createConversation: (recipientPubkey: string) => Promise<DmConversation>
  sendDmMessage: (conversationId: string, recipientPubkey: string, content: string) => Promise<void>
  deleteLocalDmMessage: (conversationId: string, messageId: string) => void
  dismissEncryptionBanner: () => void
  checkPeerKeyStatus: (peerPubkey: string) => Promise<boolean>
  incrementDmUnread: (conversationId: string) => void
  clearDmUnread: (conversationId: string) => void
  getTotalDmUnread: () => number
}
```

Implementation notes:
- `dmConversations` is ordered by lastMessageAt DESC (most recent first) per CONTEXT.md.
- `loadConversations`: Calls `window.united.dm.listConversations()`. Updates dmConversations state.
- `setDmView(true)`: Switches the UI from channel mode to DM mode. The server rail DM icon triggers this.
- `appendDmMessage`: Deduplicates by server_sequence (same pattern as channel messages from Phase 4). Updates the conversation's lastMessageAt and reorders the conversation list.
- `dmEncryptionBannerDismissed`: Persisted via `window.united.storage.setCachedState('dm_banner_dismissed', true)`. Loaded on hydration.
- `dmUnreadCounts`: Incremented when a DM arrives for a conversation that is not the active one. Cleared when user opens the conversation.
- `getTotalDmUnread`: Sum of all dmUnreadCounts values. Used for the red badge on the DM icon in server rail.
- Window cap: Keep max 200 messages per conversation in memory (DMs are lower volume than channels).

Update `client/src/renderer/src/stores/index.ts`:
- Import and compose DmSlice into RootStore:
  ```typescript
  import { createDmSlice, type DmSlice } from './dm'

  export type RootStore = AuthSlice & ConnectionSlice & ... & DmSlice

  export const useStore = create<RootStore>()((...a) => ({
    ...createAuthSlice(...a),
    ...
    ...createDmSlice(...a),
  }))
  ```

Update hydration in `stores/index.ts`:
- On hydrate, load `dm_banner_dismissed` from cached state. If true, set `dmEncryptionBannerDismissed: true`.

**Hook:**

Create `client/src/renderer/src/hooks/useDm.ts`:

- `useDm(conversationId?: string)` hook:
  - On mount: Load conversations if not yet loaded. Set up IPC listener for PUSH_DM_EVENT.
  - When conversationId changes: Load messages for the new conversation. Clear unread count for it.
  - Event handler: When PUSH_DM_EVENT with type 'new' arrives:
    - Append message to the correct conversation's message list.
    - If the conversation is not active, increment unread count.
    - If conversation is not in the list, trigger a re-fetch of conversations.
  - When PUSH_DM_EVENT with type 'conversation-created' arrives: Add to conversations list.
  - Returns: { conversations, messages, hasMore, loading, loadOlder, send, totalUnread }.
  - Cleanup: Remove IPC listener on unmount.

- `useDmKeyStatus(peerPubkey: string)` hook:
  - Checks if the peer has published an X25519 key.
  - Returns `{ keyAvailable: boolean, loading: boolean }`.
  - Used by UI to show/hide the "Waiting for encryption keys" state.

**Preload Bridge:**

Update `client/src/preload/index.ts` to expose DM methods on `window.united`:
```typescript
dm: {
  publishKey: () => ipcRenderer.invoke(IPC.DM_PUBLISH_KEY),
  listConversations: () => ipcRenderer.invoke(IPC.DM_LIST_CONVERSATIONS),
  createConversation: (recipientPubkey: string) =>
    ipcRenderer.invoke(IPC.DM_CREATE_CONVERSATION, recipientPubkey),
  sendMessage: (conversationId: string, recipientPubkey: string, content: string) =>
    ipcRenderer.invoke(IPC.DM_SEND_MESSAGE, conversationId, recipientPubkey, content),
  fetchHistory: (conversationId: string, recipientPubkey: string, beforeSeq?: number, limit?: number) =>
    ipcRenderer.invoke(IPC.DM_FETCH_HISTORY, conversationId, recipientPubkey, beforeSeq, limit),
  fetchOffline: () => ipcRenderer.invoke(IPC.DM_FETCH_OFFLINE),
  deleteLocal: (conversationId: string, messageId: string) =>
    ipcRenderer.invoke(IPC.DM_DELETE_LOCAL, conversationId, messageId),
  getPeerKeyStatus: (peerPubkey: string) =>
    ipcRenderer.invoke(IPC.DM_GET_PEER_KEY_STATUS, peerPubkey),
  onDmEvent: (callback: (event: DmEvent) => void) => {
    const listener = (_event: Electron.IpcRendererEvent, data: DmEvent) => callback(data)
    ipcRenderer.on(IPC.PUSH_DM_EVENT, listener)
    return () => { ipcRenderer.removeListener(IPC.PUSH_DM_EVENT, listener) }
  },
  onKeyRotated: (callback: (userPubkey: string) => void) => {
    const listener = (_event: Electron.IpcRendererEvent, userPubkey: string) => callback(userPubkey)
    ipcRenderer.on(IPC.PUSH_DM_KEY_ROTATED, listener)
    return () => { ipcRenderer.removeListener(IPC.PUSH_DM_KEY_ROTATED, listener) }
  },
},
```

Add DM-related types to the UnitedAPI type definition in `shared/src/ipc-bridge.ts`.

**Offline DM fetch on reconnect:**

In the connection status handler (connection.ts or wherever WS 'connected' event is handled):
- After successful WS authentication, call `dm.fetchOffline()` to retrieve any DMs received while offline.
- Process and decrypt offline DMs, merge into the DM store.
- Also call `dm.publishKey()` to ensure the user's X25519 key is published (handles first-time setup and key rotation scenarios).
  </action>
  <verify>
`cd client && npx tsc --noEmit` -- TypeScript compiles with DM store, hook, and preload bridge.
Verify store composition: RootStore includes DmSlice without type conflicts.
Verify preload bridge: `window.united.dm` is exposed with all methods.
Verify DM types are exported from shared package.
  </verify>
  <done>
Client DM data layer complete: DM crypto module (X25519 derivation, shared secret, encrypt/decrypt), IPC handlers for all DM operations, Zustand DM store with conversation list and per-conversation messages, useDm hook with real-time event subscription, preload bridge extended, offline DM fetch on reconnect, auto-publish X25519 key on connection. Message deduplication and per-conversation windowing implemented.
  </done>
</task>

</tasks>

<verification>
- DM crypto module uses sodium-native for X25519 derivation and XChaCha20-Poly1305 encryption
- Shared secret is derived from X25519 + BLAKE2b hash (never raw X25519 output)
- IPC channel constants are unique and follow naming convention
- Zustand DM slice composes into RootStore without type conflicts
- WS push events forward decrypted DM messages from main to renderer
- Preload bridge exposes all DM IPC methods
- Offline DMs fetched and decrypted on reconnection
- Per-conversation unread counts tracked
- Shared secret cache prevents redundant key exchange computations
</verification>

<success_criteria>
1. X25519 key derivation from Ed25519 works via sodium-native
2. Shared secret computation uses X25519 + BLAKE2b hash
3. DM messages encrypted with XChaCha20-Poly1305 before sending to server
4. Incoming DM messages decrypted correctly using shared secret
5. IPC handlers cover: publish key, conversations, send, history, offline, peer key status
6. Zustand DM store tracks conversations (ordered by recency) and per-conversation messages
7. WS push events for DM messages forwarded and decrypted for renderer
8. Offline DMs fetched on reconnection and merged into store
9. Preload bridge exposes all DM methods
10. TypeScript compiles without new errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-direct-messages/05-02-SUMMARY.md`
</output>
