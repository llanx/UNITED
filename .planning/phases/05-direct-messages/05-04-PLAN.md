---
phase: 05-direct-messages
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/types/generated/dm_pb.ts
  - shared/types/generated/ws_pb.ts
  - client/src/main/ws/dm-events.ts
autonomous: true
gap_closure: true
requirements: [DM-01]

must_haves:
  truths:
    - "Real-time DM push events from server arrive at the renderer store within 100ms"
    - "Recipient sees incoming DM messages appear in conversation without polling or reconnecting"
    - "DM conversation-created and key-rotated WS events are forwarded to renderer"
  artifacts:
    - path: "shared/types/generated/dm_pb.ts"
      provides: "TypeScript types for DmMessageEvent, DmConversationCreatedEvent, DmKeyRotatedEvent, EncryptedDmMessage"
      contains: "DmMessageEventSchema"
    - path: "shared/types/generated/ws_pb.ts"
      provides: "Envelope oneof payload cases including dmMessageEvent, dmConversationCreatedEvent, dmKeyRotatedEvent"
      contains: "dmMessageEvent"
    - path: "client/src/main/ws/dm-events.ts"
      provides: "WS listener that decodes protobuf Envelope and handles DM payload cases"
      contains: "fromBinary"
  key_links:
    - from: "client/src/main/ws/dm-events.ts"
      to: "shared/types/generated/ws_pb.ts"
      via: "fromBinary(EnvelopeSchema, data) decoding"
      pattern: "fromBinary.*EnvelopeSchema"
    - from: "client/src/main/ws/dm-events.ts"
      to: "client/src/renderer/src/stores/dm.ts"
      via: "IPC.PUSH_DM_EVENT broadcast to renderer"
      pattern: "broadcastToRenderers.*PUSH_DM_EVENT"
---

<objective>
Fix broken WS DM push event delivery so real-time DM messages reach recipients.

Purpose: The server sends DM events as protobuf binary Envelope messages (using Payload::DmMessageEvent fields 150-157), but the client dm-events.ts attempts JSON.parse on the binary data and silently discards every WS DM event. Additionally, the generated TypeScript protobuf types (ws_pb.ts) were never regenerated after dm.proto was added to ws.proto imports, so the Envelope type lacks DM payload variants entirely. This two-part fix regenerates protobuf types and rewrites the event handler to use the same fromBinary pattern as chat-events.ts.

Output: Working real-time DM push delivery — recipient sees incoming DMs immediately without polling.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/05-direct-messages/05-VERIFICATION.md

# Key reference files for implementation pattern
@client/src/main/ws/chat-events.ts
@shared/proto/dm.proto
@shared/proto/ws.proto
@shared/buf.gen.yaml
@shared/buf.yaml
@client/src/main/ws/dm-events.ts
@client/src/main/ipc/dm-crypto.ts
@client/src/main/ipc/channels.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate protobuf TypeScript types from updated protos</name>
  <files>
    shared/types/generated/dm_pb.ts
    shared/types/generated/ws_pb.ts
  </files>
  <action>
    Run `npx buf generate` from the `shared/` directory to regenerate all TypeScript protobuf types from the .proto files.

    This will:
    1. Generate `shared/types/generated/dm_pb.ts` (new file — DmMessageEvent, DmConversationCreatedEvent, DmKeyRotatedEvent, EncryptedDmMessage, DmConversation, DmPublicKey, etc.)
    2. Regenerate `shared/types/generated/ws_pb.ts` to include the DM payload variants in the Envelope oneof (dmMessageEvent field 150, dmConversationCreatedEvent field 151, dmKeyRotatedEvent field 152, etc.)

    The buf.gen.yaml config already points protoc-gen-es at `types/generated` output directory with `target=ts`. The buf.yaml module path is `proto/` which contains dm.proto. No configuration changes needed — just run the generator.

    After generation, verify:
    - `dm_pb.ts` exists and exports DmMessageEventSchema, DmConversationCreatedEventSchema, DmKeyRotatedEventSchema, EncryptedDmMessageSchema
    - `ws_pb.ts` contains `dmMessageEvent` in the Envelope payload oneof cases
    - No other generated files are broken (auth_pb.ts, chat_pb.ts, etc. should be regenerated identically)
  </action>
  <verify>
    1. `ls shared/types/generated/dm_pb.ts` — file exists
    2. `grep "dmMessageEvent" shared/types/generated/ws_pb.ts` — DM payload case present in Envelope
    3. `grep "DmMessageEventSchema" shared/types/generated/dm_pb.ts` — schema export exists
    4. `npx tsc --noEmit -p client/tsconfig.json` or equivalent TypeScript check passes (no type errors from regenerated files)
  </verify>
  <done>dm_pb.ts generated with all DM proto types; ws_pb.ts regenerated with DM payload variants (fields 150-157) in Envelope oneof</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite dm-events.ts to decode protobuf Envelope instead of JSON</name>
  <files>
    client/src/main/ws/dm-events.ts
  </files>
  <action>
    Rewrite `client/src/main/ws/dm-events.ts` to use the same protobuf decoding pattern as `chat-events.ts`. The current file tries `JSON.parse(new TextDecoder().decode(data))` which always fails on protobuf binary data.

    Replace the JSON parsing approach with:
    1. Import `fromBinary` from `@bufbuild/protobuf` and `EnvelopeSchema` from `@shared/generated/ws_pb`
    2. In the `wsClient.on('message')` handler, decode with `fromBinary(EnvelopeSchema, data)`
    3. Switch on `envelope.payload.case` for the three DM event types:

    **case 'dmMessageEvent':**
    - Extract the EncryptedDmMessage from `payload.value.message`
    - The message fields come from the protobuf type: id, conversationId, senderPubkey, senderDisplayName, encryptedPayload (Uint8Array), nonce (Uint8Array), timestamp (bigint), serverSequence (bigint)
    - Convert encryptedPayload and nonce from Uint8Array to Buffer for the existing decryptDmMessage function
    - Call `getOrComputeSharedSecret(conversationId, senderPubkey, url, token)` to get the shared secret
    - Call `decryptDmMessage(encryptedPayloadBuffer, nonceBuffer, sharedSecret)` to decrypt
    - Build the DecryptedDmMessage object and broadcast via `IPC.PUSH_DM_EVENT`
    - On decryption failure, set content to '[Unable to decrypt]' with decryptionFailed: true (preserve existing graceful degradation pattern)
    - Show desktop notification with sender name only (preserve E2E privacy — never show content)

    **case 'dmConversationCreatedEvent':**
    - Extract the DmConversation from `payload.value.conversation`
    - Map protobuf fields to the DmConversation interface expected by the renderer store
    - Broadcast as DmEvent type 'conversation-created' via `IPC.PUSH_DM_EVENT`

    **case 'dmKeyRotatedEvent':**
    - Extract user_pubkey from `payload.value.userPubkey`
    - Call `clearSharedSecretCache()` to invalidate cached shared secrets
    - Broadcast via `IPC.PUSH_DM_KEY_ROTATED`

    **default:** Return silently (not a DM event — handled by chat-events.ts or other listeners)

    Wrap the entire handler in try/catch — if fromBinary throws (not a valid protobuf Envelope), silently return (same as chat-events.ts pattern). This allows both chat-events.ts and dm-events.ts to listen on the same 'message' event without interfering.

    Keep all existing imports that are still needed: BrowserWindow, Notification, IPC, wsClient, getOrComputeSharedSecret, decryptDmMessage, clearSharedSecretCache, getAccessToken, getServerUrl, and the DmEvent/DecryptedDmMessage types.

    Remove the JSON-specific interfaces (WsDmMessagePayload, WsDmConversationPayload, WsDmKeyRotatedPayload, WsDmPayload) — they are replaced by the generated protobuf types.

    Note on timestamp/serverSequence: protobuf bigint fields need conversion to number for the DecryptedDmMessage interface. Use `Number(msg.timestamp)` and `Number(msg.serverSequence)`.
  </action>
  <verify>
    1. `grep "fromBinary" client/src/main/ws/dm-events.ts` — uses protobuf decoding, not JSON.parse
    2. `grep "EnvelopeSchema" client/src/main/ws/dm-events.ts` — imports the correct schema
    3. `grep "dmMessageEvent" client/src/main/ws/dm-events.ts` — handles the DM message event case
    4. `grep "dmConversationCreatedEvent" client/src/main/ws/dm-events.ts` — handles conversation created case
    5. `grep "dmKeyRotatedEvent" client/src/main/ws/dm-events.ts` — handles key rotation case
    6. `grep -c "JSON.parse" client/src/main/ws/dm-events.ts` — returns 0 (no JSON parsing)
    7. TypeScript compiles cleanly (no type errors)
  </verify>
  <done>dm-events.ts decodes protobuf Envelope using fromBinary and switches on payload.case for dmMessageEvent, dmConversationCreatedEvent, dmKeyRotatedEvent — matching the chat-events.ts pattern. JSON.parse is removed. Real-time DM push delivery works end-to-end.</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Type generation:** `shared/types/generated/dm_pb.ts` exists with DM proto types; `ws_pb.ts` includes DM Envelope payload cases
2. **Event handler:** `dm-events.ts` uses `fromBinary(EnvelopeSchema, data)` not `JSON.parse`, handles all three DM event types
3. **Build:** TypeScript compiles without errors across all three build targets (main, preload, renderer)
4. **Integration:** The WS message listener in dm-events.ts can successfully decode a protobuf Envelope containing DmMessageEvent and forward the decrypted message to renderers via IPC

The verification gap from 05-VERIFICATION.md is fully addressed:
- Truth "User can send and receive direct messages that are end-to-end encrypted — real-time WS delivery works" changes from PARTIAL to VERIFIED
- Anti-pattern "JSON.parse attempted on protobuf binary Uint8Array data" is eliminated
- Anti-pattern "Missing DM payload cases in ws_pb.ts" is eliminated
</verification>

<success_criteria>
- dm_pb.ts generated with all DM protobuf types
- ws_pb.ts regenerated with DM payload variants in Envelope oneof
- dm-events.ts uses fromBinary protobuf decoding (zero JSON.parse calls)
- dm-events.ts handles dmMessageEvent, dmConversationCreatedEvent, dmKeyRotatedEvent
- TypeScript compiles cleanly across all targets
- Phase 5 success criterion 1 (E2E encrypted DMs with real-time delivery) is fully satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-direct-messages/05-04-SUMMARY.md`
</output>
