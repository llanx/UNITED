---
phase: 03-p2p-networking
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - client/package.json
  - client/package-lock.json
  - client/src/main/p2p/node.ts
  - client/src/main/p2p/identity.ts
  - client/src/main/p2p/gossipsub.ts
  - client/src/main/p2p/discovery.ts
  - client/src/main/p2p/types.ts
  - client/src/main/ipc/p2p.ts
  - client/src/main/ipc/connection.ts
  - client/src/main/index.ts
  - shared/types/ipc-bridge.ts
autonomous: true
requirements:
  - P2P-02
  - SEC-06
  - APP-02

must_haves:
  truths:
    - "Client creates a libp2p node that connects to the server's libp2p WebSocket endpoint"
    - "Client subscribes to gossipsub topics for ALL joined channels at startup"
    - "Switching channels in the UI causes zero network activity — connections persist"
    - "Client can publish a gossipsub message that the server receives and persists"
    - "All client-to-server libp2p connections are Noise-encrypted"
    - "Client-to-client connections via WebRTC DataChannels use DTLS encryption"
    - "Client discovers peers by querying the server's peer directory via WebSocket"
    - "Client automatically reconnects to mesh peers with exponential backoff"
  artifacts:
    - path: "client/src/main/p2p/node.ts"
      provides: "createLibp2p() configuration with WebSocket, WebRTC, circuitRelay transports"
      contains: "createUnitedP2PNode"
    - path: "client/src/main/p2p/identity.ts"
      provides: "Convert UNITED Ed25519 keys to libp2p identity format"
      contains: "unitedKeysToLibp2p"
    - path: "client/src/main/p2p/gossipsub.ts"
      provides: "Topic subscription, message publish/receive, envelope handling"
      contains: "subscribeToChannels"
    - path: "client/src/main/p2p/discovery.ts"
      provides: "Peer discovery via WS directory queries, connection management"
      contains: "discoverAndConnectPeers"
    - path: "client/src/main/ipc/p2p.ts"
      provides: "IPC handlers for P2P operations"
      contains: "registerP2PHandlers"
  key_links:
    - from: "client/src/main/p2p/node.ts"
      to: "server libp2p WS endpoint (port 1985)"
      via: "WebSocket transport connecting to server multiaddr"
      pattern: "webSockets|/ip4/.*ws"
    - from: "client/src/main/p2p/gossipsub.ts"
      to: "shared/proto/p2p.proto"
      via: "GossipEnvelope encode/decode with @bufbuild/protobuf"
      pattern: "GossipEnvelope"
    - from: "client/src/main/p2p/discovery.ts"
      to: "client/src/main/ipc/connection.ts"
      via: "Sends PeerDirectoryRequest via existing WS connection"
      pattern: "PeerDirectoryRequest"
    - from: "client/src/main/p2p/identity.ts"
      to: "client/src/main/ipc/crypto.ts"
      via: "Reads Ed25519 seed from stored identity"
      pattern: "privateKeyFromProtobuf|unitedKeysToLibp2p"
---

<objective>
Build the client's libp2p node in the Electron main process with WebSocket transport (to server), WebRTC DataChannels (peer-to-peer), gossipsub topic subscriptions, peer discovery via the server's directory API, and connection lifecycle management. Connections persist across channel navigation — switching channels is a pure UI operation.

Purpose: Without the client's P2P node, messages cannot flow peer-to-peer — everything would route through the server's REST/WS API. This plan enables direct peer messaging and makes the client a full mesh participant.
Output: Working client P2P node that connects to server and peers, subscribes to all channel topics, publishes and receives gossipsub messages.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-p2p-networking/03-CONTEXT.md
@.planning/phases/03-p2p-networking/03-RESEARCH.md
@.planning/phases/03-p2p-networking/03-01-SUMMARY.md
@client/src/main/ipc/connection.ts
@client/src/main/ipc/crypto.ts
@client/src/main/ipc/auth.ts
@client/src/main/index.ts
@shared/types/ipc-bridge.ts
@shared/proto/p2p.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Client libp2p node, identity bridge, gossipsub, and envelope handling</name>
  <files>
    client/package.json
    client/src/main/p2p/node.ts
    client/src/main/p2p/identity.ts
    client/src/main/p2p/gossipsub.ts
    client/src/main/p2p/types.ts
  </files>
  <action>
    **1. Install libp2p dependencies:**
    ```bash
    cd client && npm install libp2p@^3.1.3 @libp2p/websockets @libp2p/webrtc @chainsafe/libp2p-noise @chainsafe/libp2p-yamux @chainsafe/libp2p-gossipsub @libp2p/identify @libp2p/circuit-relay-v2 @libp2p/dcutr @libp2p/ping @libp2p/crypto node-datachannel
    ```

    Then rebuild native modules for Electron:
    ```bash
    npx electron-rebuild --version 40.6.0
    ```
    This rebuilds node-datachannel (native N-API module) alongside existing sodium-native and better-sqlite3.

    **2. Create client/src/main/p2p/types.ts:**
    Shared TypeScript types used across all P2P modules:
    ```typescript
    export interface PeerInfo {
      unitedId: string        // UNITED fingerprint
      peerId: string          // libp2p PeerId string
      multiaddrs: string[]    // Advertised multiaddresses
      channels: string[]      // Subscribed channel UUIDs
      natType: 'public' | 'private' | 'unknown'
      latencyMs?: number      // Last measured RTT
      connectionType?: 'direct' | 'relayed'
    }

    export interface TopicStats {
      topic: string           // Channel UUID topic
      messageCount: number    // Messages received since subscription
      lastReceived?: number   // Timestamp of last message
    }

    export interface P2PStats {
      peers: PeerInfo[]
      topics: TopicStats[]
      natType: string
      isConnected: boolean
      serverPeerId: string
    }

    export interface GossipMessage {
      senderPubkey: Uint8Array
      signature: Uint8Array
      topic: string
      messageType: number
      timestamp: number
      sequenceHint: number
      payload: Uint8Array
    }
    ```

    **3. Create client/src/main/p2p/identity.ts:**
    Function `unitedKeysToLibp2p(secretKeyBytes: Uint8Array)` that converts a UNITED Ed25519 secret key (32-byte seed) to libp2p's expected format:
    - Use `@libp2p/crypto` `generateKeyPairFromSeed` or equivalent to create an Ed25519 private key from the 32-byte seed
    - The exact API depends on `@libp2p/crypto`'s v3.x interface. Key approaches:
      a. Use `privateKeyFromRaw` if available with type `'Ed25519'` (check v3.x API)
      b. Use `@noble/ed25519` to expand seed to full 64-byte secret key, then import via `privateKeyFromProtobuf`
      c. Fallback: use sodium-native `crypto_sign_seed_keypair()` to get the full 64-byte key, then use libp2p's protobuf key format
    - The UNITED client already has sodium-native available (used for key generation in ipc/crypto.ts). Use `sodium.crypto_sign_seed_keypair(publicKey, secretKey, seed)` to expand the 32-byte seed to 64-byte ed25519 keypair, then import into libp2p format.
    - Derive PeerId from the private key using `peerIdFromPrivateKey()`
    - Return `{ privateKey, peerId }`
    - **Critical test:** After conversion, `peerId.toString()` should be deterministic for the same seed. Log the PeerId to verify.

    Function `getIdentityKeySeed(): Promise<Uint8Array | null>` that:
    - Reads the stored encrypted identity from the client's local storage (via the existing auth IPC)
    - Returns the 32-byte Ed25519 seed for libp2p identity conversion
    - Returns null if no identity is stored (user not logged in)

    **4. Create client/src/main/p2p/node.ts:**
    Export `createUnitedP2PNode(privateKey, serverMultiaddr: string)` function:
    ```typescript
    import { createLibp2p } from 'libp2p'
    import { webSockets } from '@libp2p/websockets'
    import { webRTC } from '@libp2p/webrtc'
    import { noise } from '@chainsafe/libp2p-noise'
    import { yamux } from '@chainsafe/libp2p-yamux'
    import { gossipsub } from '@chainsafe/libp2p-gossipsub'
    import { identify } from '@libp2p/identify'
    import { circuitRelayTransport } from '@libp2p/circuit-relay-v2'
    import { dcutr } from '@libp2p/dcutr'
    import { ping } from '@libp2p/ping'
    ```

    Configuration:
    - `privateKey` from identity bridge
    - `transports`: [webSockets(), webRTC(), circuitRelayTransport()]
    - `connectionEncrypters`: [noise()]
    - `streamMuxers`: [yamux()]
    - `services.pubsub`: gossipsub with D=4, Dlo=3, Dhi=8, emitSelf=false, allowPublishToZeroTopicPeers=true (server is always subscribed)
    - `services.identify`: identify()
    - `services.dcutr`: dcutr()
    - `services.ping`: ping()

    Export `startP2PNode(serverUrl: string)` lifecycle function:
    - Get identity seed from stored identity
    - Convert to libp2p identity via `unitedKeysToLibp2p()`
    - Construct server multiaddr: convert `serverUrl` (e.g., `http://localhost:1984`) to libp2p multiaddr format `/ip4/127.0.0.1/tcp/1985/ws/p2p/{serverPeerId}`
    - Fetch the server's PeerId and libp2p port via `GET /api/p2p/info` (implemented in 03-01). This endpoint returns `{ peer_id, multiaddr, libp2p_port }`. Call this from the main process via the existing IPC HTTP helper before creating the libp2p node.
    - Create and start the libp2p node
    - Dial the server's multiaddr to establish the initial connection
    - Return the node instance

    Export `stopP2PNode()` to cleanly shut down the node.

    Store the node instance in a module-level variable accessible to other P2P modules.

    **5. Create client/src/main/p2p/gossipsub.ts:**
    Function `subscribeToChannels(node, channelIds: string[], serverFingerprint: string)`:
    - For each channel, compute topic string: `${serverFingerprint.slice(0, 16)}/${channelId}`
    - Subscribe to each topic via `node.services.pubsub.subscribe(topic)`
    - Track subscription state in module-level Map<string, TopicStats>

    Function `publishMessage(node, topic: string, envelope: GossipMessage)`:
    - Encode the GossipEnvelope using protobuf (@bufbuild/protobuf with the generated p2p_pb types)
    - Publish to gossipsub topic via `node.services.pubsub.publish(topic, encodedBytes)`

    Function `setupMessageHandler(node, onMessage: (msg: GossipMessage) => void)`:
    - Listen to `node.services.pubsub.addEventListener('message', handler)`
    - In handler: decode GossipEnvelope from protobuf bytes
    - Verify Ed25519 signature using sodium-native `crypto_sign_verify_detached()`
    - On valid message: update TopicStats (message count, last received), call `onMessage` callback
    - On invalid signature: log warning, discard message

    Maintain a Lamport counter (module-level `let lamportCounter = 0`):
    - On send: increment counter, use as sequence_hint
    - On receive: `lamportCounter = Math.max(lamportCounter, received.sequenceHint) + 1`

    **6. Run `npx electron-vite build` to verify the build succeeds with new dependencies.**
  </action>
  <verify>
    Run `npm install` in client/ — all packages install without errors. Run `npx electron-rebuild --version 40.6.0` — node-datachannel rebuilds successfully. Run `npx electron-vite build` — TypeScript compiles and bundles without errors. Check that `node_modules/@chainsafe/libp2p-gossipsub` and `node_modules/libp2p` exist with correct versions.
  </verify>
  <done>
    Client has a working libp2p node factory that creates a node with WebSocket + WebRTC + circuitRelay transports, Noise encryption, Yamux muxing, and gossipsub v1.1 (D=4, Dlo=3, Dhi=8). Identity bridge converts UNITED Ed25519 seed to libp2p format. Gossipsub subscribes to all joined channel topics. Messages are encoded/decoded as GossipEnvelope protobuf with Ed25519 signature verification. Lamport counter tracks message ordering hints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Peer discovery, connection management, and IPC integration</name>
  <files>
    client/src/main/p2p/discovery.ts
    client/src/main/ipc/p2p.ts
    client/src/main/ipc/connection.ts
    client/src/main/index.ts
    shared/types/ipc-bridge.ts
  </files>
  <action>
    **1. Create client/src/main/p2p/discovery.ts:**

    Function `discoverAndConnectPeers(node, channelIds: string[])`:
    - Send `PeerDirectoryRequest` via the existing WS connection (encode protobuf, send through existing WS envelope)
    - Receive `PeerDirectoryResponse` with peer multiaddresses
    - For each discovered peer not already connected: `node.dial(multiaddr(peerMultiaddr))`
    - Log connection attempts and results
    - Return list of successfully connected peers

    Function `setupReconnection(node)`:
    - Listen to `node.addEventListener('peer:disconnect', handler)`
    - On disconnect of a mesh peer (peer that was in gossipsub mesh): start exponential backoff reconnection
    - Backoff schedule: 1s, 2s, 4s, 8s, 16s, 30s (cap at 30s per CONTEXT.md)
    - After ~2 minutes (approximately 7-8 attempts) of failed reconnection: call `discoverAndConnectPeers()` to query server directory for replacement peers
    - On reconnection success: clear backoff timer
    - For non-mesh peers (identified via gossipsub mesh membership): do NOT auto-reconnect (lazy reconnection per CONTEXT.md)

    Function `registerPeerIdWithServer(peerId: string)`:
    - Send `RegisterPeerId` message via WS to tell the server "my libp2p PeerId is X"
    - This enables the server's peer directory to map UNITED identity (from WS auth) to PeerId

    Function `handleMemberListVerification(node)`:
    - After the Noise handshake succeeds for an incoming connection, verify the peer's public key is a registered server member
    - Use the cached member list (already maintained in the client from Phase 2 WS events)
    - On verification failure: query server for this specific member before rejecting (handles race condition per RESEARCH.md Pitfall 8)
    - If server confirms not a member: close connection

    **2. Create client/src/main/ipc/p2p.ts:**
    Export `registerP2PHandlers()` function that sets up IPC handlers:
    - `IPC.P2P_START_MESH`: Start the P2P node (calls `startP2PNode()` then `subscribeToChannels()` then `discoverAndConnectPeers()` then `registerPeerIdWithServer()`)
    - `IPC.P2P_STOP_MESH`: Stop the P2P node (calls `stopP2PNode()`)
    - `IPC.P2P_SEND_TEST_MESSAGE`: Publish a test gossipsub message (MessageType.TEST) with provided text payload
    - `IPC.P2P_PING_PEER`: Ping a specific peer by PeerId, return RTT
    - `IPC.P2P_FORCE_RECONNECT`: Disconnect and reconnect to all peers (for dev panel)
    - `IPC.P2P_GET_STATS`: Return current P2PStats snapshot (for polling or initial fetch)
    - `IPC.P2P_PANEL_OPEN` / `IPC.P2P_PANEL_CLOSE`: Track dev panel open state for stats push (next plan)

    Add IPC channel name constants to a shared location (or extend existing IPC enum).

    **3. Update shared/types/ipc-bridge.ts:**
    Add P2P-related methods to the `UnitedAPI` interface:
    ```typescript
    p2p: {
      startMesh(): Promise<{ peerId: string }>
      stopMesh(): Promise<void>
      sendTestMessage(topic: string, text: string): Promise<void>
      pingPeer(peerId: string): Promise<{ rttMs: number }>
      forceReconnect(): Promise<void>
      getStats(): Promise<P2PStats>
      onStatsUpdate(callback: (stats: P2PStats) => void): () => void  // returns cleanup fn
      openPanel(): void
      closePanel(): void
    }
    ```

    **4. Update client/src/main/ipc/connection.ts:**
    After successful WebSocket connection and authentication:
    - Auto-start the P2P mesh by calling the P2P start logic
    - Fetch the server's PeerId (from server info or a new endpoint) before starting the mesh so the client knows the server's multiaddr
    - On WS disconnect: do NOT stop the P2P mesh (P2P connections should survive temporary WS interruptions per graceful degradation decision in CONTEXT.md)
    - Only stop the P2P mesh on explicit logout or server change

    **5. Update client/src/main/index.ts:**
    Call `registerP2PHandlers()` during app initialization alongside existing IPC handler registration.

    **6. Channel subscription lifecycle:**
    When the user joins a new channel (via channel create events from WS): subscribe to its gossipsub topic.
    When a channel is deleted: unsubscribe from its topic.
    Listen for existing WS push events for channel create/delete and wire them to gossipsub subscribe/unsubscribe.
  </action>
  <verify>
    Run `npx electron-vite build` — compiles without errors. Verify all IPC handlers are registered by checking the handler registration in index.ts. Verify the ipc-bridge.ts types include the p2p methods. Start the Electron app alongside the server — verify the client connects to the server's libp2p endpoint (check server logs for incoming connection on port 1985).
  </verify>
  <done>
    Client discovers peers via server's WS-based peer directory and connects directly. Reconnection uses exponential backoff (1s-30s) with server directory fallback after ~2 minutes. RegisterPeerId maps UNITED identity to PeerId on the server. Member list verification prevents unauthorized mesh joins. IPC handlers expose full P2P control surface to renderer. P2P mesh auto-starts after WS authentication and persists across channel navigation (APP-02). All P2P connections are encrypted via Noise (WS to server) and DTLS (WebRTC to peers) satisfying SEC-06.
  </done>
</task>

</tasks>

<verification>
1. `npm install` and `npx electron-rebuild --version 40.6.0` succeed in client/
2. `npx electron-vite build` compiles without errors
3. Client libp2p node connects to server's libp2p endpoint (port 1985) on startup
4. Client subscribes to gossipsub topics for all joined channels
5. Switching channels in UI does NOT cause any libp2p dial/disconnect activity
6. Client can publish a test gossipsub message that appears in server logs
7. Peer discovery returns at least the server as a peer in the directory response
8. IPC bridge types are complete and all handlers are registered
</verification>

<success_criteria>
- Client libp2p node starts with WebSocket + WebRTC + Circuit Relay transports
- Noise encryption secures all libp2p connections (SEC-06)
- Client subscribes to ALL joined channel topics at startup (APP-02 + P2P-02)
- Gossipsub messages flow client -> server (via gossipsub, not just WS)
- Peer discovery queries server directory and connects to returned peers
- Reconnection follows exponential backoff (1s-30s cap) with directory fallback
- P2P mesh persists across channel navigation — no reconnection on channel switch (APP-02)
- Identity bridge correctly converts UNITED Ed25519 seed to libp2p format
- node-datachannel rebuilds for Electron 40.6.0 without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-p2p-networking/03-02-SUMMARY.md`
</output>
