---
phase: 03-p2p-networking
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/main/p2p/discovery.ts
autonomous: true
gap_closure: true
requirements:
  - P2P-02
  - SEC-06
  - APP-02

must_haves:
  truths:
    - "scheduleReconnect() dials the disconnected remote peer's multiaddrs during exponential backoff"
    - "PeerId is parsed from the string stored in ReconnectState using peerIdFromString"
    - "If multiaddrs are found in the peerStore, each is dialed in sequence until one succeeds"
    - "If no multiaddrs found or all dials fail, attempt counter increments and backoff continues"
    - "Directory fallback after MAX_RECONNECT_BEFORE_DIRECTORY attempts still works"
  artifacts:
    - path: "client/src/main/p2p/discovery.ts"
      provides: "Fixed scheduleReconnect with actual remote peer dial"
      contains: "peerIdFromString"
  key_links:
    - from: "client/src/main/p2p/discovery.ts"
      to: "@libp2p/peer-id"
      via: "peerIdFromString import"
      pattern: "peerIdFromString"
    - from: "scheduleReconnect()"
      to: "node.peerStore.get()"
      via: "parsed remote PeerId"
      pattern: "peerStore.get(remotePeerId)"
    - from: "scheduleReconnect()"
      to: "node.dial()"
      via: "multiaddrs from peerStore"
      pattern: "node.dial(addr.multiaddr)"
---

<objective>
Fix the reconnection bug in `client/src/main/p2p/discovery.ts` where `scheduleReconnect()` queries the local node's own PeerId instead of the disconnected remote peer, making exponential backoff reconnection attempts no-ops.

Purpose: Without this fix, when a mesh peer disconnects, the fast-recovery path (1s, 2s, 4s... backoff) does nothing — reconnection only happens after ~2 minutes via the directory fallback. This must be fixed before Phase 4 real-time chat, where dropped connections need sub-second recovery.

Output: Fixed `scheduleReconnect()` function that actually dials the disconnected peer's multiaddrs during backoff attempts.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/03-p2p-networking/03-VERIFICATION.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From client/src/main/p2p/discovery.ts (current broken code, lines 237-275):
```typescript
function scheduleReconnect(
  node: Libp2p<{ pubsub: PubSub }>,
  state: ReconnectState,
  channelIds: string[]
): void {
  // ... backoff logic ...
  state.timer = setTimeout(async () => {
    try {
      const peerStore = node.peerStore
      let peerData
      try {
        peerData = await peerStore.get(node.peerId) // BUG: queries self, not remote peer
      } catch {
        // Peer not in store
      }
      // Never dials — just increments attempt and reschedules
      state.attempt++
      scheduleReconnect(node, state, channelIds)
    } catch (err) {
      // ...
    }
  }, delay)
}
```

From client/src/main/p2p/discovery.ts (existing imports, line 23):
```typescript
import type { Libp2p, PubSub, PeerId } from '@libp2p/interface'
```

From client/src/main/p2p/identity.ts (existing peerIdFromPrivateKey usage):
```typescript
import { peerIdFromPrivateKey } from '@libp2p/peer-id'
```

ReconnectState interface (lines 29-33):
```typescript
interface ReconnectState {
  peerId: string        // String form of remote peer's PeerId
  attempt: number
  timer: ReturnType<typeof setTimeout> | null
}
```

The `@libp2p/peer-id` package is already a transitive dependency (used in identity.ts). It exports `peerIdFromString()` which converts a PeerId string back to a PeerId object suitable for `peerStore.get()`.

The `node.peerStore.get(peerId: PeerId)` returns `Promise<Peer>` where `Peer` has an `addresses` field: `Array<{ multiaddr: Multiaddr, isCertified: boolean }>`.

The `node.dial(ma: Multiaddr)` dials a peer at the given multiaddress and returns a `Connection`.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix scheduleReconnect to dial disconnected remote peer</name>
  <files>client/src/main/p2p/discovery.ts</files>
  <action>
Fix the `scheduleReconnect()` function in `client/src/main/p2p/discovery.ts` to properly reconnect to disconnected peers during exponential backoff.

**Step 1: Add import**

Add `peerIdFromString` to the imports. The package `@libp2p/peer-id` is already a transitive dependency (used in `identity.ts`). Add this import near the top of the file alongside the existing `@libp2p/interface` import:

```typescript
import { peerIdFromString } from '@libp2p/peer-id'
```

**Step 2: Rewrite the setTimeout callback inside `scheduleReconnect()`**

Replace the entire `state.timer = setTimeout(async () => { ... }, delay)` block (lines 255-274) with logic that:

1. Parses `state.peerId` (string) into a PeerId object using `peerIdFromString(state.peerId)`
2. Looks up the remote peer in `node.peerStore.get(remotePeerId)` — NOT `node.peerId`
3. If the peer has addresses in the store, iterates over `peerData.addresses` and dials each `addr.multiaddr` using `node.dial(addr.multiaddr)`
4. On successful dial: logs success and returns (the `peer:connect` event handler already cleans up the ReconnectState)
5. If no addresses found in peerStore, or all dials fail: increment `state.attempt` and call `scheduleReconnect()` again for the next backoff step

The fixed code should look like:

```typescript
state.timer = setTimeout(async () => {
  try {
    // Parse the string PeerId back to a PeerId object for peerStore lookup
    const remotePeerId = peerIdFromString(state.peerId)
    const peerStore = node.peerStore
    let peerData
    try {
      peerData = await peerStore.get(remotePeerId)
    } catch {
      // Peer not in store — skip to next attempt
    }

    if (peerData && peerData.addresses.length > 0) {
      // Try each known multiaddr
      for (const addr of peerData.addresses) {
        try {
          await node.dial(addr.multiaddr)
          console.log(`[P2P] Reconnected to ${state.peerId} via ${addr.multiaddr.toString()}`)
          return // Success — peer:connect handler cleans up state
        } catch {
          // This addr failed, try next
        }
      }
    }

    // All addrs failed or none found — backoff and retry
    state.attempt++
    scheduleReconnect(node, state, channelIds)
  } catch (err) {
    console.debug(`[P2P] Reconnect to ${state.peerId} failed:`, err)
    state.attempt++
    scheduleReconnect(node, state, channelIds)
  }
}, delay)
```

**What NOT to do:**
- Do NOT change the `setupReconnection()` function's event listeners — they are correct
- Do NOT change the `MAX_RECONNECT_BEFORE_DIRECTORY` fallback logic — it works correctly
- Do NOT change the `calculateBackoff()` function — it is correct
- Do NOT change the `clearReconnectionState()` cleanup function — it is correct
- Do NOT add `@libp2p/peer-id` to package.json dependencies — it is already available as a transitive dependency and the existing `identity.ts` already imports from it without issues
  </action>
  <verify>
    <automated>cd /c/Users/matts/united/client && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - `scheduleReconnect()` uses `peerIdFromString(state.peerId)` to look up the remote peer (not `node.peerId`)
    - `peerStore.get()` is called with the remote PeerId object
    - If multiaddrs exist, `node.dial(addr.multiaddr)` is called for each address
    - On successful dial, the function returns (peer:connect handler cleans up)
    - On failure, backoff increments and reschedules
    - Directory fallback after MAX_RECONNECT_BEFORE_DIRECTORY attempts still works unchanged
    - TypeScript compilation passes with no errors
  </done>
</task>

</tasks>

<verification>
1. **TypeScript compilation**: `cd client && npx tsc --noEmit` passes without errors
2. **Import check**: `peerIdFromString` is imported from `@libp2p/peer-id`
3. **Bug fix verification**: `peerStore.get()` call uses a parsed remote PeerId, not `node.peerId`
4. **Dial attempt**: `node.dial(addr.multiaddr)` is called inside the backoff setTimeout callback
5. **Fallback preserved**: The `MAX_RECONNECT_BEFORE_DIRECTORY` check and `discoverAndConnectPeers()` fallback remain unchanged
</verification>

<success_criteria>
- The `scheduleReconnect()` function actually dials the disconnected remote peer during backoff attempts
- `peerStore.get()` queries the remote peer's PeerId (not `node.peerId`)
- All existing reconnection behavior (backoff timing, directory fallback, cleanup on connect) is preserved
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-p2p-networking/03-04-SUMMARY.md`
</output>
