---
phase: 03-p2p-networking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/Cargo.toml
  - server/Cargo.lock
  - server/build.rs
  - server/src/config.rs
  - server/src/state.rs
  - server/src/main.rs
  - server/src/lib.rs
  - server/src/routes.rs
  - server/src/p2p/mod.rs
  - server/src/p2p/config.rs
  - server/src/p2p/identity.rs
  - server/src/p2p/behaviour.rs
  - server/src/p2p/swarm.rs
  - server/src/p2p/messages.rs
  - server/src/p2p/directory.rs
  - server/src/proto/mod.rs
  - server/src/ws/protocol.rs
  - server/src/db/migrations.rs
  - server/src/db/models.rs
  - shared/proto/p2p.proto
  - shared/proto/ws.proto
autonomous: true
requirements:
  - P2P-02
  - SEC-06

must_haves:
  truths:
    - "Server starts a libp2p Swarm alongside axum in the same tokio runtime"
    - "Server subscribes to gossipsub topics for all existing channels"
    - "Server persists every gossipsub message to SQLite with a server-assigned sequence number"
    - "All libp2p connections are encrypted via Noise_XX handshake using the server's Ed25519 identity"
    - "Server acts as Circuit Relay v2 with configurable limits exposed in united.toml"
    - "Clients can query the peer directory via WebSocket and receive multiaddresses of online peers"
    - "Server's libp2p PeerId is derived from a persistent Ed25519 keypair stored at `{data_dir}/p2p_identity.key`, loaded on startup and regenerated only if the file does not exist"
    - "Clients can fetch the server's PeerId and libp2p multiaddr via GET /api/p2p/info"
  artifacts:
    - path: "server/src/p2p/behaviour.rs"
      provides: "Composed NetworkBehaviour with gossipsub, relay, autonat, identify, dcutr, ping"
      contains: "UnitedBehaviour"
    - path: "server/src/p2p/swarm.rs"
      provides: "Swarm event loop and command channel integration with AppState"
      contains: "SwarmCommand"
    - path: "server/src/p2p/messages.rs"
      provides: "GossipEnvelope encode/decode, signature verification, message persistence"
      contains: "GossipEnvelope"
    - path: "server/src/p2p/directory.rs"
      provides: "Peer directory tracking online peers and their multiaddresses per channel"
      contains: "PeerDirectory"
    - path: "shared/proto/p2p.proto"
      provides: "GossipEnvelope and MessageType protobuf definitions"
      contains: "GossipEnvelope"
    - path: "server/src/p2p/config.rs"
      provides: "P2P configuration struct merged into united.toml"
      contains: "P2pConfig"
  key_links:
    - from: "server/src/main.rs"
      to: "server/src/p2p/swarm.rs"
      via: "tokio::spawn of swarm event loop task"
      pattern: "tokio::spawn.*swarm"
    - from: "server/src/p2p/swarm.rs"
      to: "server/src/state.rs"
      via: "mpsc command/event channels stored in AppState"
      pattern: "swarm_cmd_tx|SwarmCommand"
    - from: "server/src/ws/protocol.rs"
      to: "server/src/p2p/directory.rs"
      via: "WS PeerDirectoryRequest dispatches to directory"
      pattern: "PeerDirectoryRequest"
    - from: "server/src/p2p/messages.rs"
      to: "server/src/db/migrations.rs"
      via: "Persists gossipsub messages to messages table with sequence numbers"
      pattern: "INSERT INTO messages"
    - from: "server/src/routes.rs"
      to: "server/src/state.rs"
      via: "GET /api/p2p/info reads server PeerId and libp2p multiaddr from AppState"
      pattern: "p2p_info|peer_id"
---

<objective>
Build the server's libp2p node with gossipsub pub/sub messaging, Circuit Relay v2 for NAT traversal, peer directory service, and message persistence. The server becomes a full mesh participant that subscribes to all gossipsub topics (one per channel), persists every message with server-assigned sequence numbers, and acts as a super-seeder and relay for NAT-challenged clients.

Purpose: The server's libp2p node is the foundation that all client P2P connections depend on. Without it, clients have nothing to connect to and no peer directory to query.
Output: Working libp2p Swarm running alongside axum, gossipsub message flow, peer directory API, relay infrastructure, and message persistence.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-p2p-networking/03-CONTEXT.md
@.planning/phases/03-p2p-networking/03-RESEARCH.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/02-server-management/02-01-SUMMARY.md
@server/src/main.rs
@server/src/state.rs
@server/src/config.rs
@server/src/ws/protocol.rs
@server/src/ws/mod.rs
@server/src/db/migrations.rs
@server/src/db/models.rs
@server/Cargo.toml
@shared/proto/ws.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Server libp2p node — config, identity bridge, NetworkBehaviour, Swarm event loop</name>
  <files>
    server/Cargo.toml
    server/src/config.rs
    server/src/p2p/mod.rs
    server/src/p2p/config.rs
    server/src/p2p/identity.rs
    server/src/p2p/behaviour.rs
    server/src/p2p/swarm.rs
    server/src/state.rs
    server/src/main.rs
    server/src/lib.rs
  </files>
  <action>
    **1. Add libp2p dependency to Cargo.toml:**
    ```toml
    libp2p = { version = "0.56", features = [
        "gossipsub", "relay", "autonat", "noise", "identify",
        "dcutr", "websocket", "tokio", "yamux", "tcp", "dns", "ping"
    ] }
    ```
    Also add `sha2 = "0.10"` (for gossipsub message_id_fn content hashing).

    **2. Create server/src/p2p/config.rs:**
    Define `P2pConfig` struct with serde Serialize/Deserialize:
    - `libp2p_port: u16` (default 1985) — separate from axum's 1984
    - `gossipsub_mesh_n: usize` (default 4) — D parameter
    - `gossipsub_mesh_n_low: usize` (default 3) — D_lo
    - `gossipsub_mesh_n_high: usize` (default 8) — D_hi
    - `gossipsub_max_transmit_size: usize` (default 65536) — 64 KiB
    - `relay_max_circuits: usize` (default 64)
    - `relay_max_circuits_per_peer: usize` (default 8)
    - `relay_max_circuit_duration_secs: u64` (default 1800) — 30 minutes
    - `relay_max_circuit_bytes: usize` (default 10485760) — 10 MB

    Add `P2pConfig` as an `Option<P2pConfig>` field named `p2p` on the existing `Config` struct in config.rs. Default to `Some(P2pConfig::default())`. Update `generate_config_template()` to include commented P2P section.

    **3. Create server/src/p2p/identity.rs:**
    Function `server_identity_keypair(data_dir: &str) -> libp2p::identity::Keypair` that:
    - Checks for `{data_dir}/p2p_identity.key` file
    - If exists: read 32-byte Ed25519 seed, reconstruct keypair via `identity::ed25519::Keypair::try_from_bytes()`
    - If not: generate new Ed25519 keypair via libp2p's `identity::Keypair::generate_ed25519()`, save 32-byte seed to file
    - Log the PeerId on startup: `tracing::info!("Server libp2p PeerId: {}", PeerId::from(keypair.public()))`

    Note: The server's libp2p identity is separate from UNITED user identities. This is the SERVER node identity for the mesh. Future consideration: could reuse the server's Ed25519 signing key, but for now keep it independent and simple.

    **4. Create server/src/p2p/behaviour.rs:**
    Define `UnitedBehaviour` using `#[derive(NetworkBehaviour)]`:
    - `gossipsub: gossipsub::Behaviour` — with `MessageAuthenticity::Signed(keypair)`, tuned config from P2pConfig
    - `relay: relay::Behaviour` — with configured limits from P2pConfig
    - `autonat: autonat::Behaviour` — default config
    - `identify: identify::Behaviour` — protocol string `/united/1.0.0`
    - `dcutr: dcutr::Behaviour` — default
    - `ping: ping::Behaviour` — default

    Gossipsub config (per RESEARCH.md pitfall guidance):
    - `mesh_n`, `mesh_n_low`, `mesh_n_high` from P2pConfig
    - `mesh_outbound_min(2)`
    - `heartbeat_interval(Duration::from_secs(1))`
    - `max_transmit_size` from P2pConfig
    - `validation_mode(ValidationMode::Strict)`
    - `flood_publish(true)` — ensure delivery during low peer count
    - `message_id_fn` using SHA-256 hash of message data for dedup

    Gossipsub v1.1 peer scoring (CONTEXT.md locked decision — mesh self-optimizes by tracking peer delivery quality):
    - Enable peer scoring via `.with_peer_scoring(peer_score_params, peer_score_thresholds)` on the gossipsub `ConfigBuilder`
    - `PeerScoreParams`: Start conservative for a chat application:
      - `topics`: For each subscribed topic, set `TopicScoreParams` with:
        - `topic_weight: 1.0`
        - `time_in_mesh_weight: 0.01`, `time_in_mesh_quantum: Duration::from_secs(1)`, `time_in_mesh_cap: 100.0` — reward peers that stay connected
        - `first_message_deliveries_weight: 1.0`, `first_message_deliveries_cap: 50.0`, `first_message_deliveries_decay: 0.95` — reward peers that deliver messages first
        - `mesh_message_deliveries_weight: -0.1` (low penalty), `mesh_message_deliveries_threshold: 1.0`, `mesh_message_deliveries_cap: 20.0`, `mesh_message_deliveries_decay: 0.95`, `mesh_message_deliveries_activation: Duration::from_secs(60)`, `mesh_message_deliveries_window: Duration::from_millis(500)` — light penalty for missing expected deliveries
        - `invalid_message_deliveries_weight: -10.0`, `invalid_message_deliveries_decay: 0.9` — strong penalty for invalid signature messages
      - `decay_interval: Duration::from_secs(10)`
      - `decay_to_zero: 0.01`
    - `PeerScoreThresholds`: Conservative values to avoid premature peer eviction:
      - `gossip_threshold: -100.0` — peers below this stop receiving gossip
      - `publish_threshold: -200.0` — peers below this can't publish
      - `graylist_threshold: -300.0` — peers below this are fully rejected
      - `opportunistic_graft_threshold: 5.0` — peers above this are candidates for opportunistic grafting
    - These values are intentionally conservative (low penalties, large negative thresholds). Per RESEARCH.md: "Start with conservative scoring, tune in later phases based on real-world testing."
    - Note: `build_behaviour()` must accept a list of topic hashes so it can configure per-topic scoring params at construction time. The topic list comes from the channel query in main.rs.

    Relay config: map P2pConfig fields to `relay::Config` struct. Increase defaults from relay v2 defaults per RESEARCH.md Pitfall 4.

    Provide a `build_behaviour(keypair: &identity::Keypair, config: &P2pConfig) -> UnitedBehaviour` function.

    **5. Create server/src/p2p/swarm.rs:**
    Define `SwarmCommand` enum:
    - `SubscribeTopic(String)` — subscribe to gossipsub topic
    - `UnsubscribeTopic(String)` — unsubscribe
    - `Publish { topic: String, data: Vec<u8> }` — publish gossipsub message
    - `GetPeerInfo(tokio::sync::oneshot::Sender<Vec<PeerInfo>>)` — for directory queries
    - `GetTopicPeers { topic: String, reply: oneshot::Sender<Vec<PeerId>> }` — peers subscribed to a topic

    Define `SwarmEvent` enum:
    - `GossipMessage { source: PeerId, topic: String, data: Vec<u8> }` — received gossipsub message
    - `PeerConnected(PeerId)` — new peer connection
    - `PeerDisconnected(PeerId)` — peer lost

    Function `build_swarm(keypair: identity::Keypair, config: &P2pConfig) -> Swarm<UnitedBehaviour>`:
    - Use `SwarmBuilder::with_existing_identity(keypair)`
    - `.with_tokio()`
    - `.with_tcp(Default::default(), noise::Config::new, yamux::Config::default)`
    - `.with_websocket(noise::Config::new, yamux::Config::default)`
    - `.with_behaviour(|key| build_behaviour(key, config))`
    - `.build()`

    Function `run_swarm_loop(swarm: Swarm<UnitedBehaviour>, cmd_rx: mpsc::UnboundedReceiver<SwarmCommand>, evt_tx: mpsc::UnboundedSender<SwarmEvent>, listen_addr: String)`:
    - Listen on `/ip4/0.0.0.0/tcp/{port}/ws` where port is from P2pConfig
    - `tokio::select!` loop:
      - `event = swarm.select_next_some()` => handle SwarmEvent (gossipsub message received, peer connect/disconnect, identify events, relay events)
      - `cmd = cmd_rx.recv()` => handle SwarmCommand (subscribe/unsubscribe/publish/query)
    - For gossipsub message events: decode topic, forward via evt_tx as `SwarmEvent::GossipMessage`
    - For identify events: log peer info, store multiaddress for directory
    - For connection events: track in internal state, forward via evt_tx

    **6. Create server/src/p2p/mod.rs:**
    Declare all submodules (pub mod config, identity, behaviour, swarm, messages, directory). Re-export key types: `SwarmCommand`, `SwarmEvent`, `P2pConfig`, `PeerDirectory`.

    **7. Update server/src/state.rs:**
    Add to `AppState`:
    - `swarm_cmd_tx: tokio::sync::mpsc::UnboundedSender<p2p::SwarmCommand>` — axum handlers send commands to swarm
    - `peer_directory: Arc<p2p::PeerDirectory>` — shared peer directory
    - `server_peer_id: String` — the server's libp2p PeerId as a string (set during startup from the keypair, used by the P2P info endpoint)
    - `libp2p_port: u16` — the configured libp2p port (from P2pConfig, used by the P2P info endpoint)

    **8. Update server/src/main.rs:**
    - Add `mod p2p;`
    - After DB init, load P2P config from Config
    - Call `p2p::identity::server_identity_keypair(&config.data_dir)` to load/generate server keypair
    - Build swarm via `p2p::swarm::build_swarm(keypair, &p2p_config)`
    - Create mpsc channels: `(swarm_cmd_tx, swarm_cmd_rx)` and `(swarm_evt_tx, swarm_evt_rx)`
    - Subscribe to all existing channel topics at startup: query channels from DB, send `SubscribeTopic` for each
    - `tokio::spawn(p2p::swarm::run_swarm_loop(swarm, swarm_cmd_rx, swarm_evt_tx, listen_addr))`
    - Spawn a separate task to consume `swarm_evt_rx` and call `p2p::messages::handle_gossip_message()` for each received message (use `tokio::spawn_blocking` for DB writes to avoid starving the swarm)
    - Pass `swarm_cmd_tx` and `peer_directory` into AppState
    - Log the libp2p listening multiaddress on startup

    **9. Update server/src/lib.rs:**
    Add `pub mod p2p;`
  </action>
  <verify>
    Run `/c/Users/matts/.cargo/bin/cargo check` in server/ — must compile with zero errors. The libp2p Swarm should build with all behaviour components. Verify p2p_identity.key is created in data_dir on first run via `cargo run -- --help` (does not start server but triggers config validation).
  </verify>
  <done>
    Server compiles with libp2p 0.56 and all protocol features. P2pConfig is configurable via united.toml. SwarmCommand/SwarmEvent channels connect the Swarm to axum handlers. Server starts libp2p Swarm alongside axum in the same tokio runtime, listening on a configurable port (default 1985).
  </done>
</task>

<task type="auto">
  <name>Task 2: Gossipsub message handling, peer directory, p2p.proto, and message persistence</name>
  <files>
    shared/proto/p2p.proto
    shared/proto/ws.proto
    server/build.rs
    server/src/proto/mod.rs
    server/src/p2p/messages.rs
    server/src/p2p/directory.rs
    server/src/ws/protocol.rs
    server/src/db/migrations.rs
    server/src/db/models.rs
    server/src/routes.rs
  </files>
  <action>
    **1. Create shared/proto/p2p.proto:**
    ```protobuf
    syntax = "proto3";
    package united.p2p;

    message GossipEnvelope {
        bytes sender_pubkey = 1;      // 32-byte Ed25519 public key
        bytes signature = 2;          // 64-byte Ed25519 signature over fields 3-7
        string topic = 3;             // server_fingerprint_prefix/channel_uuid
        MessageType message_type = 4;
        uint64 timestamp = 5;         // Sender wall clock millis (hint only)
        uint64 sequence_hint = 6;     // Lamport counter for offline ordering
        bytes payload = 7;            // Inner message (type-specific protobuf-encoded bytes)
    }

    enum MessageType {
        MESSAGE_TYPE_UNSPECIFIED = 0;
        MESSAGE_TYPE_CHAT = 1;
        MESSAGE_TYPE_TYPING = 2;
        MESSAGE_TYPE_PRESENCE = 3;
        MESSAGE_TYPE_TEST = 99;
    }

    // Peer directory messages (sent over WS, not gossipsub)
    message PeerDirectoryRequest {
        repeated string channel_ids = 1;  // Channel UUIDs to query peers for
    }

    message PeerDirectoryResponse {
        repeated PeerInfo peers = 1;
    }

    message PeerInfo {
        string united_id = 1;          // UNITED fingerprint (stable across key rotation)
        string peer_id = 2;            // libp2p PeerId (changes on key rotation)
        repeated string multiaddrs = 3; // Advertised multiaddresses
        repeated string channels = 4;   // Channel UUIDs this peer is subscribed to
        string nat_type = 5;           // "public", "private", "unknown"
    }
    ```

    Use topic namespace prefix: `{server_fingerprint_16chars}/{channel_uuid}` per research discretion recommendation. The server fingerprint is derived from the first 16 hex chars of the server's libp2p PeerId.

    **2. Update server/build.rs:**
    Add `"../shared/proto/p2p.proto"` to the list of proto files compiled by prost-build.

    **3. Update server/src/proto/mod.rs:**
    Add the `united::p2p` module following the existing pattern for the new p2p proto types.

    **4. Extend shared/proto/ws.proto:**
    Add new payload variants to the WS Envelope oneof for peer directory:
    - Field 110: `united.p2p.PeerDirectoryRequest peer_directory_request`
    - Field 111: `united.p2p.PeerDirectoryResponse peer_directory_response`

    Import p2p.proto at top. Use field numbers in the 110+ range (P2P block).

    **5. Create server/src/p2p/messages.rs:**

    Function `encode_gossip_envelope(sender_pubkey: &[u8], signing_key: &ed25519_dalek::SigningKey, topic: &str, message_type: MessageType, sequence_hint: u64, payload: &[u8]) -> Vec<u8>`:
    - Build a GossipEnvelope with all fields except signature
    - Serialize fields 3-7 to canonical bytes for signing (concatenate topic + message_type as u32 + timestamp + sequence_hint + payload)
    - Sign canonical bytes with Ed25519 signing key
    - Set signature field, encode full envelope with prost

    Function `decode_and_verify_gossip_envelope(data: &[u8]) -> Result<GossipEnvelope, Error>`:
    - Decode with prost
    - Extract sender_pubkey, reconstruct VerifyingKey
    - Reconstruct canonical bytes from fields 3-7
    - Verify Ed25519 signature
    - Return verified envelope or error

    Function `handle_gossip_message(db: &DbPool, envelope: &GossipEnvelope) -> Result<u64, Error>`:
    - Extract channel_id from topic (strip server prefix, parse UUID)
    - Assign next sequence number (atomic counter or DB-based auto-increment)
    - Insert into `messages` table: `channel_id, sender_pubkey (hex), message_type, payload, timestamp, sequence_hint, server_sequence, signature, created_at`
    - Use `tokio::task::spawn_blocking` for the DB write (called from the swarm event consumer task, not the swarm loop itself)
    - Return assigned sequence number

    **6. Create server/src/db/migrations.rs addition (Migration 3):**
    Add a new migration creating the `messages` table:
    ```sql
    CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        channel_id TEXT NOT NULL,
        sender_pubkey TEXT NOT NULL,
        message_type INTEGER NOT NULL DEFAULT 0,
        payload BLOB,
        timestamp INTEGER NOT NULL,
        sequence_hint INTEGER NOT NULL DEFAULT 0,
        server_sequence INTEGER NOT NULL,
        signature BLOB NOT NULL,
        created_at TEXT NOT NULL DEFAULT (datetime('now')),
        FOREIGN KEY (channel_id) REFERENCES channels(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_messages_channel_seq ON messages(channel_id, server_sequence);
    CREATE INDEX IF NOT EXISTS idx_messages_channel_time ON messages(channel_id, created_at);
    ```
    Also add a `server_sequence_counter` table or use a simpler approach: `SELECT COALESCE(MAX(server_sequence), 0) + 1 FROM messages WHERE channel_id = ?` for each insert. For Phase 3, this is sufficient — the server is single-writer.

    **7. Update server/src/db/models.rs:**
    Add `Message` struct with fields matching the messages table.

    **8. Create server/src/p2p/directory.rs:**
    Define `PeerDirectory` struct (wrapped in `Arc<RwLock<...>>` or use `DashMap`):
    - `peers: DashMap<PeerId, PeerDirectoryEntry>` where entry has: united_id (fingerprint), multiaddrs, subscribed_channels, nat_type, last_seen
    - `identity_to_peer: DashMap<String, PeerId>` — maps UNITED fingerprint to current PeerId

    Methods:
    - `register_peer(peer_id, united_id, multiaddrs)` — called on identify event
    - `unregister_peer(peer_id)` — called on disconnect
    - `update_nat_type(peer_id, nat_type)` — called on AutoNAT result
    - `update_channels(peer_id, channels: Vec<String>)` — called when peer subscribes/unsubscribes topics
    - `get_peers_for_channels(channel_ids: &[String]) -> Vec<PeerInfo>` — returns peer info for requested channels (for directory response)

    The directory is populated from:
    1. libp2p identify events (peer_id + multiaddrs)
    2. gossipsub subscription events (which topics each peer subscribes to)
    3. The server's own WS connection registry (UNITED fingerprint to peer mapping — when a WS-connected user also connects via libp2p, we correlate by timing/IP or a dedicated "register my PeerId" WS message)

    For the PeerId-to-UNITED-identity mapping: Add a new WS message `RegisterPeerId { peer_id: string }` that clients send after connecting their libp2p node. The server matches this to the authenticated WS user. Add this to the ws.proto envelope.

    **9. Update server/src/ws/protocol.rs:**
    Add handler for `PeerDirectoryRequest`: call `peer_directory.get_peers_for_channels()`, encode response as `PeerDirectoryResponse`, send back via WS envelope.
    Add handler for `RegisterPeerId`: associate the authenticated user's fingerprint with their libp2p PeerId in the directory.

    **10. Wire up channel topic subscriptions in server:**
    When a new channel is created (in existing channel CRUD), send `SwarmCommand::SubscribeTopic` to subscribe the server's gossipsub to the new channel topic. When a channel is deleted, send `UnsubscribeTopic`. Modify the channel create/delete routes to send these commands via `swarm_cmd_tx` from AppState.

    **11. Add `GET /api/p2p/info` endpoint in server/src/routes.rs:**
    Create a public (no auth required) JSON endpoint that returns the server's P2P connection info:
    ```json
    {
      "peer_id": "<server's libp2p PeerId string>",
      "multiaddr": "/ip4/0.0.0.0/tcp/1985/ws/p2p/<PeerId>",
      "libp2p_port": 1985
    }
    ```
    Read `server_peer_id` and `libp2p_port` from `AppState`. Construct the multiaddr string dynamically. This endpoint is required by the client (03-02) to construct the server's libp2p multiaddr for dialing. Add the route to the existing router in `build_router()` under `/api/p2p/info`.
  </action>
  <verify>
    Run `/c/Users/matts/.cargo/bin/cargo check` in server/ — must compile with zero errors. Run `/c/Users/matts/.cargo/bin/cargo test` in server/ — existing tests must still pass. Verify the messages table is created by the migration. Verify p2p.proto compiles and types are accessible in `proto::united::p2p::GossipEnvelope`.
  </verify>
  <done>
    GossipEnvelope protobuf is defined with sender_pubkey, signature, topic, message_type, timestamp, sequence_hint, and payload. Server encodes/decodes/verifies envelopes. Messages table persists gossipsub messages with server-assigned sequence numbers. Peer directory tracks online peers with multiaddresses and channel subscriptions. WS protocol handles PeerDirectoryRequest/Response and RegisterPeerId for identity-PeerId mapping. Channel CRUD auto-subscribes/unsubscribes the server's gossipsub. GET /api/p2p/info endpoint returns server PeerId, multiaddr, and libp2p port for client connection bootstrapping.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with zero errors in server/
2. `cargo test` passes — all existing Phase 1 + Phase 2 tests still green
3. Server starts and logs both axum listener (port 1984) and libp2p listener (port 1985)
4. `united.toml` config template includes P2P section with documented defaults
5. `p2p_identity.key` is created on first run in data_dir
6. Messages table exists after migration runs
7. p2p.proto types are accessible via prost-generated code
8. `GET /api/p2p/info` returns JSON with `peer_id`, `multiaddr`, and `libp2p_port` fields
9. Gossipsub is configured with peer scoring enabled (`.with_peer_scoring()` called)
</verification>

<success_criteria>
- Server runs a libp2p Swarm with gossipsub, relay, autonat, identify, dcutr, and ping
- Gossipsub is configured with D=4, D_lo=3, D_hi=8, max_transmit_size=64KiB
- Gossipsub v1.1 peer scoring enabled with conservative PeerScoreParams and PeerScoreThresholds
- Circuit Relay v2 has chat-appropriate limits (30min duration, 10MB per circuit)
- Server subscribes to gossipsub topics for all existing channels at startup
- Incoming gossipsub messages are verified (Ed25519 signature) and persisted to SQLite
- Peer directory responds to WS queries with online peer multiaddresses
- All P2P configuration is exposed in united.toml with sensible defaults
- GET /api/p2p/info endpoint serves server PeerId and multiaddr for client bootstrapping
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/03-p2p-networking/03-01-SUMMARY.md`
</output>
