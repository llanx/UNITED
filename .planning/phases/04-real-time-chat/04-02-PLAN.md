---
phase: 04-real-time-chat
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/package.json
  - client/src/main/ipc/channels.ts
  - client/src/main/ipc/chat.ts
  - client/src/main/ipc/presence.ts
  - client/src/main/ipc/notifications.ts
  - client/src/main/ws/client.ts
  - client/src/renderer/src/stores/messages.ts
  - client/src/renderer/src/stores/presence.ts
  - client/src/renderer/src/stores/notifications.ts
  - client/src/renderer/src/stores/index.ts
  - client/src/renderer/src/hooks/useMessages.ts
  - client/src/renderer/src/hooks/usePresence.ts
  - client/src/main/ipc/channels.ts
  - client/src/preload/index.ts
autonomous: true
requirements: [MSG-01, MSG-02, MSG-05, MSG-06, MSG-07, APP-03, SEC-03]

must_haves:
  truths:
    - "Client can fetch paginated message history for a channel via IPC"
    - "Client can send a message via IPC (main process signs and sends to server)"
    - "Client receives real-time messages from WS push events and stores them in Zustand"
    - "Client deduplicates messages received via multiple paths"
    - "Message store is per-channel with windowed arrays"
    - "Presence store tracks online/offline/away status for all known users"
    - "Typing state tracks who is typing in each channel"
    - "Notification preferences stored per-channel"
    - "New npm dependencies installed: react-markdown, remark-gfm, rehype-highlight, highlight.js, emoji-picker-react, date-fns"
  artifacts:
    - path: "client/src/main/ipc/chat.ts"
      provides: "IPC handlers for send message, fetch history, edit, delete, reactions"
      contains: "registerChatHandlers"
    - path: "client/src/main/ipc/presence.ts"
      provides: "IPC handlers for presence updates and typing indicators"
      contains: "registerPresenceHandlers"
    - path: "client/src/renderer/src/stores/messages.ts"
      provides: "Zustand slice for per-channel message state"
      contains: "createMessagesSlice"
    - path: "client/src/renderer/src/stores/presence.ts"
      provides: "Zustand slice for presence and typing state"
      contains: "createPresenceSlice"
    - path: "client/src/renderer/src/hooks/useMessages.ts"
      provides: "Hook for message subscription and scroll management"
      contains: "useMessages"
  key_links:
    - from: "client/src/main/ws/client.ts"
      to: "client/src/renderer/src/stores/messages.ts"
      via: "WS push events forwarded via IPC to renderer, store handles in event listener"
      pattern: "PUSH_CHAT_EVENT"
    - from: "client/src/main/ipc/chat.ts"
      to: "server REST API"
      via: "apiGet/apiPost for message history, send, edit, delete"
      pattern: "api/channels.*messages"
    - from: "client/src/renderer/src/stores/messages.ts"
      to: "client/src/renderer/src/stores/presence.ts"
      via: "Typing events update presence store; message events may trigger notification store"
      pattern: "useStore"
---

<objective>
Client data layer for real-time chat: install npm dependencies, create IPC handlers for message operations, Zustand store slices for messages/presence/notifications, hooks for subscriptions, and WS push event handling.

Purpose: Establishes the entire client-side data pipeline so the chat UI (plan 03) can render messages, send new ones, and react to real-time events without building any data plumbing itself.

Output: npm dependencies installed, IPC handlers (chat.ts, presence.ts, notifications.ts), Zustand slices (messages.ts, presence.ts, notifications.ts), subscription hooks, WS protocol extension.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-chat/04-CONTEXT.md
@.planning/phases/04-real-time-chat/04-RESEARCH.md

Key existing files to reference:
@client/src/main/ipc/connection.ts (IPC handler pattern: apiGet/apiPost, getAccessToken, getServerUrl)
@client/src/main/ipc/channels.ts (IPC channel name constants -- extend with chat/presence channels)
@client/src/renderer/src/stores/channels.ts (Zustand slice pattern: StateCreator<RootStore, [], [], SliceType>)
@client/src/renderer/src/stores/index.ts (Root store composition via spread)
@client/src/main/ipc/crypto.ts (signChallenge, bufToHex for message signing)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create IPC channel constants</name>
  <files>
    client/package.json
    client/src/main/ipc/channels.ts
  </files>
  <action>
Install Phase 4 npm dependencies in the client directory:
```bash
cd client && npm install react-markdown remark-gfm rehype-highlight highlight.js emoji-picker-react date-fns
```

Extend `client/src/main/ipc/channels.ts` IPC constant object with new channels:

```typescript
// Chat messages
CHAT_SEND: 'chat:send',
CHAT_FETCH_HISTORY: 'chat:fetch-history',
CHAT_EDIT: 'chat:edit',
CHAT_DELETE: 'chat:delete',

// Reactions
REACTIONS_ADD: 'reactions:add',
REACTIONS_REMOVE: 'reactions:remove',
REACTIONS_FETCH: 'reactions:fetch',

// Presence
PRESENCE_SET: 'presence:set',
PRESENCE_FETCH: 'presence:fetch',

// Last read / unread
LAST_READ_UPDATE: 'last-read:update',
LAST_READ_FETCH: 'last-read:fetch',

// Notifications
NOTIFICATIONS_SET_PREFS: 'notifications:set-prefs',

// Push events (main -> renderer)
PUSH_CHAT_EVENT: 'chat:event',
PUSH_TYPING_EVENT: 'typing:event',
PUSH_PRESENCE_EVENT: 'presence:event',
```
  </action>
  <verify>
`cd client && npm ls react-markdown remark-gfm rehype-highlight highlight.js emoji-picker-react date-fns` -- all 6 packages listed.
Check that `client/src/main/ipc/channels.ts` has no TypeScript errors: `cd client && npx tsc --noEmit --pretty 2>&1 | head -20` (may have other errors from Phase 3 incomplete, but no errors in channels.ts itself).
  </verify>
  <done>
Six new npm packages installed. IPC channel constants extended with 14 new channels for chat, reactions, presence, last-read, and push events.
  </done>
</task>

<task type="auto">
  <name>Task 2: IPC handlers, Zustand stores, and WS event forwarding</name>
  <files>
    client/src/main/ipc/chat.ts
    client/src/main/ipc/presence.ts
    client/src/main/ipc/notifications.ts
    client/src/main/ws/client.ts
    client/src/renderer/src/stores/messages.ts
    client/src/renderer/src/stores/presence.ts
    client/src/renderer/src/stores/notifications.ts
    client/src/renderer/src/stores/index.ts
    client/src/renderer/src/hooks/useMessages.ts
    client/src/renderer/src/hooks/usePresence.ts
    client/src/preload/index.ts
  </files>
  <action>
**IPC Handlers (main process):**

Create `client/src/main/ipc/chat.ts` with `registerChatHandlers(ipcMain)`:
- `CHAT_SEND` handler: Takes { channelId, content, replyToId? }. Gets session keys from crypto module. Signs the message content with Ed25519 (use signChallenge pattern from crypto.ts -- sign the content bytes). Sends POST to server `/api/channels/{channelId}/messages` with body { content, sender_pubkey (hex), signature (hex), reply_to_id }. Note: If the server does not yet have a POST endpoint for creating messages via REST (plan 01 may only handle gossip-sourced messages), create a POST endpoint OR send via WS. Decision: Use REST POST for reliability. The server should accept REST-submitted messages the same way it accepts gossip ones -- assign server_sequence, persist, broadcast.
  IMPORTANT: If the REST POST /messages endpoint does not exist from plan 01 (plan 01 relies on gossipsub for message creation), then this handler should send the message as a protobuf WS Envelope or via REST with the server creating and broadcasting it. Choose the simplest path: REST POST that the server handles by persisting + broadcasting + returning the ChatMessage with server_sequence.
- `CHAT_FETCH_HISTORY` handler: Takes { channelId, beforeSequence?, limit? }. Calls GET `/api/channels/{channelId}/messages?before={seq}&limit={n}` with auth token. Returns the message array and has_more flag.
- `CHAT_EDIT` handler: Takes { channelId, messageId, newContent }. Calls PUT `/api/channels/{channelId}/messages/{messageId}` with auth token.
- `CHAT_DELETE` handler: Takes { channelId, messageId }. Calls DELETE `/api/channels/{channelId}/messages/{messageId}` with auth token.
- `REACTIONS_ADD` handler: Takes { messageId, emoji }. Calls POST `/api/messages/{messageId}/reactions` with body { emoji }.
- `REACTIONS_REMOVE` handler: Takes { messageId, emoji }. Calls DELETE `/api/messages/{messageId}/reactions/{emoji}`.
- `REACTIONS_FETCH` handler: Takes { messageId }. Calls GET `/api/messages/{messageId}/reactions`.
- `LAST_READ_UPDATE` handler: Takes { channelId, lastSequence }. Calls PUT `/api/channels/{channelId}/last-read` with body { last_sequence }.
- `LAST_READ_FETCH` handler: Takes { channelId }. Calls GET `/api/channels/{channelId}/last-read`.

Follow the established IPC pattern from connection.ts: use apiGet/apiPost/apiPut helpers, getAccessToken()/getServerUrl() from './auth'.

Create `client/src/main/ipc/presence.ts` with `registerPresenceHandlers(ipcMain)`:
- `PRESENCE_SET` handler: Takes { status: 'online'|'away'|'dnd'|'offline' }. Sends presence update to server (REST POST or WS).
- Idle detection: Set up a 15-minute timer using `powerMonitor.getSystemIdleTime()` from Electron. When idle > 15 minutes, auto-set status to 'away'. When activity resumes, auto-set back to 'online' (unless user manually set DND).

Create `client/src/main/ipc/notifications.ts` with `registerNotificationHandlers(ipcMain)`:
- Notification display function (called when a mention is received): Use Electron `Notification` API. Coalesce rapid notifications (2s window per channel). Don't notify if window is focused and user is in the same channel.
- Click handler: Focus window and send IPC to renderer to navigate to channel.
- `NOTIFICATIONS_SET_PREFS` handler: Store notification preferences (per-channel mute, notify-all toggle).

**WS Event Forwarding:**

Modify `client/src/main/ws/client.ts` (or wherever WS messages are processed):
- When a WS push message is received, check for Phase 4 payload types:
  - NewMessageEvent -> forward via `webContents.send(IPC.PUSH_CHAT_EVENT, { type: 'new', message })` to all renderer windows
  - MessageEditedEvent -> forward as `{ type: 'edited', messageId, channelId, newContent, editTimestamp }`
  - MessageDeletedEvent -> forward as `{ type: 'deleted', messageId, channelId }`
  - ReactionAddedEvent -> forward as `{ type: 'reaction-added', messageId, userPubkey, emoji }`
  - ReactionRemovedEvent -> forward as `{ type: 'reaction-removed', messageId, userPubkey, emoji }`
  - PresenceUpdateEvent -> forward via `IPC.PUSH_PRESENCE_EVENT`
  - TypingEvent -> forward via `IPC.PUSH_TYPING_EVENT`
- For messages that mention the current user, trigger notification via the notifications module.

**Zustand Store Slices (renderer):**

Create `client/src/renderer/src/stores/messages.ts`:
```typescript
interface ChannelMessages {
  messages: ChatMessage[];        // Ordered by server_sequence
  oldestLoaded: number | null;
  newestLoaded: number | null;
  hasMoreHistory: boolean;
  lastReadSequence: number;
}

interface MessagesSlice {
  channelMessages: Record<string, ChannelMessages>;
  loadMessages: (channelId: string) => Promise<void>;
  loadOlderMessages: (channelId: string) => Promise<void>;
  appendMessage: (channelId: string, msg: ChatMessage) => void;
  updateMessage: (channelId: string, messageId: string, updates: Partial<ChatMessage>) => void;
  removeMessage: (channelId: string, messageId: string) => void;
  addReaction: (channelId: string, messageId: string, emoji: string, userPubkey: string) => void;
  removeReaction: (channelId: string, messageId: string, emoji: string, userPubkey: string) => void;
  markChannelRead: (channelId: string) => void;
  getUnreadCount: (channelId: string) => number;
  getMentionCount: (channelId: string) => number;
}
```
Use Record<string, ChannelMessages> (not Map -- Zustand works better with plain objects for reactivity).
Deduplication: On appendMessage, check if a message with the same server_sequence already exists.
Window cap: Keep max 500 messages per channel in memory. When exceeded, trim from the oldest end.

Create `client/src/renderer/src/stores/presence.ts`:
```typescript
interface PresenceSlice {
  userPresence: Record<string, { status: 'online' | 'away' | 'dnd' | 'offline'; displayName: string }>;
  typingUsers: Record<string, { userId: string; displayName: string; timeout: number }[]>; // per-channel
  setPresence: (userPubkey: string, status: string, displayName: string) => void;
  addTypingUser: (channelId: string, userId: string, displayName: string) => void;
  removeTypingUser: (channelId: string, userId: string) => void;
  clearTypingTimeout: (channelId: string, userId: string) => void;
}
```
Typing timeout: 3 seconds. When a typing event arrives, set/reset a timer. When timer fires, remove the user from typingUsers for that channel.

Create `client/src/renderer/src/stores/notifications.ts`:
```typescript
interface NotificationsSlice {
  channelMentionCounts: Record<string, number>;
  notificationPrefs: Record<string, { muted: boolean; notifyAll: boolean }>;
  incrementMentionCount: (channelId: string) => void;
  clearMentionCount: (channelId: string) => void;
  setNotificationPref: (channelId: string, pref: { muted?: boolean; notifyAll?: boolean }) => void;
}
```

Update `client/src/renderer/src/stores/index.ts`:
- Import and compose the three new slices (MessagesSlice, PresenceSlice, NotificationsSlice) into RootStore.

**Hooks:**

Create `client/src/renderer/src/hooks/useMessages.ts`:
- `useMessages(channelId)` hook: On mount, calls loadMessages if channel not yet loaded. Sets up IPC listener for PUSH_CHAT_EVENT. Returns { messages, hasMore, loading, loadOlder }. Cleans up listener on unmount.

Create `client/src/renderer/src/hooks/usePresence.ts`:
- `usePresence()` hook: Sets up IPC listener for PUSH_PRESENCE_EVENT and PUSH_TYPING_EVENT. Updates presence and typing stores. Handles typing timeout cleanup.

**Preload bridge:**

Update `client/src/preload/index.ts` to expose new IPC methods on `window.united`:
- `chat.send(channelId, content, replyToId?)`, `chat.fetchHistory(channelId, beforeSeq?, limit?)`, `chat.edit(channelId, messageId, content)`, `chat.delete(channelId, messageId)`
- `reactions.add(messageId, emoji)`, `reactions.remove(messageId, emoji)`, `reactions.fetch(messageId)`
- `presence.set(status)`, `lastRead.update(channelId, seq)`, `lastRead.fetch(channelId)`
- `notifications.setPrefs(channelId, prefs)`
- IPC listener registrations for push events

Define ChatMessage, Reaction, and other TypeScript types in shared types (e.g., `shared/src/ipc-bridge.ts` or a new `shared/src/chat-types.ts`).
  </action>
  <verify>
`cd client && npx tsc --noEmit` -- TypeScript compiles with new IPC handlers, stores, and hooks (some errors may exist from unbuilt Phase 3 client code, but no new errors from Phase 4 code).
Verify store composition: check that `useStore` in index.ts includes all three new slices without type errors.
Verify preload bridge: check that `window.united.chat` and `window.united.presence` are exposed.
  </verify>
  <done>
Client data layer complete: 3 IPC handler files (chat, presence, notifications), 3 Zustand store slices (messages, presence, notifications), 2 hooks (useMessages, usePresence), WS event forwarding for all Phase 4 event types, preload bridge extended. Message deduplication and per-channel windowing implemented. Typing timeout (3s) and idle detection (15min) wired.
  </done>
</task>

</tasks>

<verification>
- npm dependencies installed and importable
- IPC channel constants are unique and follow naming convention
- Zustand slices compose into RootStore without type conflicts
- WS push events forward from main to renderer for all Phase 4 event types
- Preload bridge exposes all chat/presence/notification IPC methods
- Typing indicator uses 3s timeout, idle detection uses 15min
- Message store deduplicates by server_sequence
</verification>

<success_criteria>
1. Six npm packages installed (react-markdown, remark-gfm, rehype-highlight, highlight.js, emoji-picker-react, date-fns)
2. IPC handlers can fetch history, send messages, manage reactions, update presence
3. Zustand messages slice stores per-channel message arrays with deduplication
4. Zustand presence slice tracks user status and per-channel typing users
5. WS push events (new message, edit, delete, reaction, presence, typing) forwarded to renderer
6. Preload bridge exposes all new IPC methods
7. TypeScript compiles without new errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-chat/04-02-SUMMARY.md`
</output>
