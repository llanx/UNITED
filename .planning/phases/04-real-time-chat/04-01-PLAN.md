---
phase: 04-real-time-chat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/proto/chat.proto
  - shared/proto/presence.proto
  - shared/proto/ws.proto
  - server/src/chat/mod.rs
  - server/src/chat/messages.rs
  - server/src/chat/reactions.rs
  - server/src/chat/broadcast.rs
  - server/src/db/migrations.rs
  - server/src/db/models.rs
  - server/src/lib.rs
  - server/src/routes.rs
  - server/src/proto/mod.rs
  - server/build.rs
  - server/src/ws/protocol.rs
  - server/src/p2p/messages.rs
autonomous: true
requirements: [MSG-01, MSG-02, MSG-04, SEC-03]

must_haves:
  truths:
    - "POST /api/channels/{id}/messages creates a new message, assigns server_sequence, persists it, and broadcasts NewMessageEvent to all WS clients"
    - "GET /api/channels/{id}/messages returns paginated message history ordered by server_sequence"
    - "POST /api/messages/{id}/reactions toggles a reaction and returns updated reaction list"
    - "DELETE /api/messages/{id}/reactions/{emoji} removes a reaction"
    - "Server broadcasts NewMessageEvent to all WS clients when a gossip message is persisted"
    - "Server broadcasts NewMessageEvent to all WS clients when a REST-submitted message is persisted"
    - "Server broadcasts ReactionAdded/Removed events to all WS clients"
    - "Messages table has content_text, edited, deleted, reply_to_id columns"
    - "Reactions table exists with unique constraint on (message_id, user_pubkey, emoji)"
    - "chat.proto and presence.proto define all Phase 4 message types"
    - "ws.proto Envelope has Phase 4 payload variants in fields 120-149"
  artifacts:
    - path: "shared/proto/chat.proto"
      provides: "ChatMessage, Reaction, edit/delete/reaction events, history request/response"
      contains: "package united.chat"
    - path: "shared/proto/presence.proto"
      provides: "PresenceUpdate, TypingIndicator, PresenceStatus enum"
      contains: "package united.presence"
    - path: "server/src/chat/messages.rs"
      provides: "POST create message, GET paginated history, PUT edit, DELETE soft-delete endpoints"
      contains: "create_message"
    - path: "server/src/chat/reactions.rs"
      provides: "POST/DELETE reaction endpoints"
      contains: "add_reaction"
    - path: "server/src/chat/broadcast.rs"
      provides: "WS broadcast helpers for chat events"
      contains: "broadcast_new_message"
  key_links:
    - from: "server/src/chat/messages.rs"
      to: "server/src/chat/broadcast.rs"
      via: "After create_message persists, call broadcast_new_message"
      pattern: "broadcast_new_message"
    - from: "server/src/p2p/messages.rs"
      to: "server/src/chat/broadcast.rs"
      via: "After handle_gossip_message persists, call broadcast_new_message"
      pattern: "broadcast_new_message"
    - from: "server/src/chat/messages.rs"
      to: "server/src/db/migrations.rs"
      via: "Queries against messages table with new columns"
      pattern: "content_text"
    - from: "shared/proto/ws.proto"
      to: "shared/proto/chat.proto"
      via: "import and oneof payload variants"
      pattern: "united.chat.NewMessageEvent"
---

<objective>
Server-side chat infrastructure: protobuf schemas, database migration, REST endpoints (including POST for message creation), and WS broadcast for messages and reactions.

Purpose: Establishes the server-side data model and API surface that the client data layer (plan 02) and chat UI (plan 03) will consume. Without this, no messages can be fetched, sent, or reacted to.

Output: chat.proto, presence.proto, ws.proto extensions, server chat module with REST endpoints, DB migration 4, WS broadcast on both gossip receipt and REST message creation.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-chat/04-CONTEXT.md
@.planning/phases/04-real-time-chat/04-RESEARCH.md
@.planning/phases/03-p2p-networking/03-01-SUMMARY.md

Key existing files to reference:
@shared/proto/p2p.proto (GossipEnvelope, MessageType enum)
@shared/proto/ws.proto (Envelope oneof, field allocation comment)
@server/src/p2p/messages.rs (handle_gossip_message, decode_and_verify_gossip_envelope)
@server/src/ws/broadcast.rs (broadcast_to_all, send_to_user patterns)
@server/src/db/migrations.rs (migration 3 = messages table)
@server/src/routes.rs (existing route groups)
@server/src/state.rs (AppState)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Protobuf schemas and database migration</name>
  <files>
    shared/proto/chat.proto
    shared/proto/presence.proto
    shared/proto/ws.proto
    server/src/db/migrations.rs
    server/src/db/models.rs
    server/src/proto/mod.rs
    server/build.rs
  </files>
  <action>
Create `shared/proto/chat.proto` (package united.chat) with these messages, following the schema from RESEARCH.md code examples:
- ChatMessage (id string UUID, channel_id, sender_pubkey hex, sender_display_name, content, timestamp u64, server_sequence u64, signature bytes, reply_to_id string optional, edited bool, mention_user_ids repeated string, mention_role_ids repeated string)
- Reaction (message_id string, user_pubkey string, emoji string, timestamp u64)
- NewMessageEvent (ChatMessage message)
- MessageEditedEvent (message_id, channel_id, new_content, edit_timestamp u64)
- MessageDeletedEvent (message_id, channel_id)
- ReactionAddedEvent (Reaction reaction)
- ReactionRemovedEvent (message_id, user_pubkey, emoji)
- FetchHistoryRequest (channel_id, before_sequence u64, limit u32)
- FetchHistoryResponse (repeated ChatMessage messages, bool has_more)

Create `shared/proto/presence.proto` (package united.presence) with:
- PresenceStatus enum (UNSPECIFIED=0, ONLINE=1, AWAY=2, DND=3, OFFLINE=4)
- PresenceUpdate (user_pubkey, PresenceStatus status, timestamp u64)
- TypingIndicator (user_pubkey, channel_id, display_name, timestamp u64)
- PresenceUpdateEvent (PresenceUpdate update)
- TypingEvent (TypingIndicator indicator)

Modify `shared/proto/ws.proto`:
- Add imports: `import "chat.proto";` and `import "presence.proto";`
- Add field allocation comment: `// 120-149: Real-Time Chat (Phase 4)`
- Add to Envelope oneof payload (fields 120-131):
  - united.chat.NewMessageEvent new_message_event = 120
  - united.chat.MessageEditedEvent message_edited_event = 121
  - united.chat.MessageDeletedEvent message_deleted_event = 122
  - united.chat.ReactionAddedEvent reaction_added_event = 123
  - united.chat.ReactionRemovedEvent reaction_removed_event = 124
  - united.presence.PresenceUpdateEvent presence_update_event = 125
  - united.presence.TypingEvent typing_event = 126
  - united.chat.FetchHistoryRequest fetch_history_request = 130
  - united.chat.FetchHistoryResponse fetch_history_response = 131

Add Migration 4 to `server/src/db/migrations.rs`:
```sql
-- Migration 4: Chat Features (Phase 4)
ALTER TABLE messages ADD COLUMN content_text TEXT;
ALTER TABLE messages ADD COLUMN edited INTEGER NOT NULL DEFAULT 0;
ALTER TABLE messages ADD COLUMN edit_timestamp TEXT;
ALTER TABLE messages ADD COLUMN deleted INTEGER NOT NULL DEFAULT 0;
ALTER TABLE messages ADD COLUMN reply_to_id TEXT;

CREATE TABLE reactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id INTEGER NOT NULL,
    user_pubkey TEXT NOT NULL,
    emoji TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (message_id) REFERENCES messages(id) ON DELETE CASCADE,
    UNIQUE(message_id, user_pubkey, emoji)
);
CREATE INDEX idx_reactions_message ON reactions(message_id);

CREATE TABLE last_read (
    user_id TEXT NOT NULL,
    channel_id TEXT NOT NULL,
    last_sequence INTEGER NOT NULL DEFAULT 0,
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    PRIMARY KEY (user_id, channel_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (channel_id) REFERENCES channels(id) ON DELETE CASCADE
);
```

Add Reaction and LastRead models to `server/src/db/models.rs`.

Update `server/build.rs` to compile chat.proto and presence.proto.
Update `server/src/proto/mod.rs` to add chat and presence proto modules.

IMPORTANT: The existing messages table (Migration 3) stores payload as BLOB and sender_pubkey as TEXT (hex). The new content_text column is for direct text storage alongside the protobuf payload for efficient SQL queries. When a CHAT-type message is persisted, extract the text content from the ChatMessage protobuf payload and store it in content_text.
  </action>
  <verify>
Run `cd server && /c/Users/matts/.cargo/bin/cargo build` -- compilation succeeds with new proto types and migration.
Verify proto types are generated: check that `united::chat::ChatMessage` and `united::presence::PresenceStatus` are accessible in Rust code.
Run `cd server && /c/Users/matts/.cargo/bin/cargo test` -- all existing 42 tests still pass.
  </verify>
  <done>
chat.proto and presence.proto exist with all message types. ws.proto has Phase 4 payload variants (fields 120-131). Migration 4 adds content_text, edited, deleted, reply_to_id to messages table and creates reactions + last_read tables. All proto types compile and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: REST endpoints and WS broadcast for chat events</name>
  <files>
    server/src/chat/mod.rs
    server/src/chat/messages.rs
    server/src/chat/reactions.rs
    server/src/chat/broadcast.rs
    server/src/lib.rs
    server/src/routes.rs
    server/src/ws/protocol.rs
    server/src/p2p/messages.rs
  </files>
  <action>
Create `server/src/chat/mod.rs` with module declarations for messages, reactions, broadcast.

Create `server/src/chat/messages.rs` with:
- `POST /api/channels/{channel_id}/messages` -- **Create a new message via REST.** JWT auth required (Claims extractor). Accepts JSON body `{ content: string, reply_to_id?: string }`. The server performs:
  1. Validate content is non-empty and within size limit (e.g., 4000 chars).
  2. Look up sender's display_name from the users table using the JWT claims user_id.
  3. Generate a UUID for the message id.
  4. Assign the next server_sequence for the channel (atomic increment or SELECT MAX+1 within a transaction).
  5. Set timestamp to current time (Unix millis).
  6. Persist the message to the messages table: insert a row with channel_id, sender_pubkey (from JWT claims), server_sequence, content_text (from body), reply_to_id, payload (can be NULL or a ChatMessage protobuf encoding), message_type = CHAT.
  7. Construct a ChatMessage proto with all fields populated (id, channel_id, sender_pubkey, sender_display_name, content, timestamp, server_sequence, reply_to_id, edited=false, mention_user_ids/mention_role_ids parsed from content).
  8. Call `broadcast_new_message(registry, channel_id, chat_message)` to push NewMessageEvent to all connected WS clients.
  9. Return 201 with the ChatMessage as JSON (id, server_sequence, timestamp, etc.) so the client can confirm delivery.
  Note: This REST path is the primary way clients submit messages. The gossipsub path (from Phase 3) also persists messages -- both paths converge on the same broadcast. The REST path is simpler and more reliable for single-server deployments.

- `GET /api/channels/{channel_id}/messages?before={seq}&limit={n}` -- Paginated message history. JWT auth required (Claims extractor). Default limit 50, max 100. Query messages WHERE channel_id = ?1 AND server_sequence < ?2 AND deleted = 0, ORDER BY server_sequence DESC, LIMIT ?3. Map rows to ChatMessage proto format (id as string, pubkey as hex, etc). Return JSON response with messages array and has_more boolean. Use `spawn_blocking` for DB access per established pattern.
- `PUT /api/channels/{channel_id}/messages/{message_id}` -- Edit own message. JWT auth required. Only the sender (match sender_pubkey) can edit. Update content_text, set edited=1, set edit_timestamp. Broadcast MessageEditedEvent to all WS clients.
- `DELETE /api/channels/{channel_id}/messages/{message_id}` -- Delete own message. JWT auth required. Sender OR admin (check is_owner or admin permission) can delete. Set deleted=1. Broadcast MessageDeletedEvent to all WS clients.

Also include in `messages.rs`:
- `PUT /api/channels/{channel_id}/last-read` with body `{ "last_sequence": N }` -- Update last_read for the authenticated user. Upsert into last_read table.
- `GET /api/channels/{channel_id}/last-read` -- Get last_read sequence for authenticated user.

Create `server/src/chat/reactions.rs` with:
- `POST /api/messages/{message_id}/reactions` with body `{ "emoji": "thumbs_up" }` -- Add reaction. JWT auth required. Insert into reactions table (UNIQUE constraint handles duplicates -- use INSERT OR IGNORE). Broadcast ReactionAddedEvent. Return 201.
- `DELETE /api/messages/{message_id}/reactions/{emoji}` -- Remove own reaction. JWT auth required. Delete from reactions WHERE message_id AND user_pubkey AND emoji. Broadcast ReactionRemovedEvent. Return 200.
- `GET /api/messages/{message_id}/reactions` -- List reactions for a message. Return array of { emoji, count, user_pubkeys }. No auth required (public read).

Create `server/src/chat/broadcast.rs` with helpers:
- `broadcast_new_message(registry, channel_id, chat_message)` -- Wraps ChatMessage in NewMessageEvent, wraps in Envelope, broadcasts to all connected WS clients via broadcast_to_all.
- `broadcast_message_edited(registry, event)` -- Broadcasts MessageEditedEvent.
- `broadcast_message_deleted(registry, event)` -- Broadcasts MessageDeletedEvent.
- `broadcast_reaction(registry, event)` -- Broadcasts ReactionAdded/RemovedEvent.

Modify `server/src/p2p/messages.rs` handle_gossip_message():
- After persisting the message, if message_type is MESSAGE_TYPE_CHAT, decode the payload as ChatMessage protobuf, extract content_text and store it in the new column.
- Return the full ChatMessage proto alongside the server_sequence so the caller can broadcast it.
- Note: The function signature may need to change to return more data. The caller in main.rs gossip event handler should call broadcast_new_message after handle_gossip_message succeeds.

Update `server/src/main.rs` (or wherever the gossip event consumer loop lives):
- After handle_gossip_message returns success, construct a ChatMessage and call broadcast_new_message to push to all WS clients.

Add `pub mod chat;` to `server/src/lib.rs`.

Add chat routes to `server/src/routes.rs`:
```rust
let chat_routes = Router::new()
    .route("/api/channels/{channel_id}/messages", axum::routing::get(chat::messages::get_channel_messages).post(chat::messages::create_message))
    .route("/api/channels/{channel_id}/messages/{message_id}", axum::routing::put(chat::messages::edit_message))
    .route("/api/channels/{channel_id}/messages/{message_id}", axum::routing::delete(chat::messages::delete_message))
    .route("/api/channels/{channel_id}/last-read", axum::routing::put(chat::messages::update_last_read))
    .route("/api/channels/{channel_id}/last-read", axum::routing::get(chat::messages::get_last_read))
    .route("/api/messages/{message_id}/reactions", axum::routing::post(chat::reactions::add_reaction))
    .route("/api/messages/{message_id}/reactions", axum::routing::get(chat::reactions::get_reactions))
    .route("/api/messages/{message_id}/reactions/{emoji}", axum::routing::delete(chat::reactions::remove_reaction));
```
Merge chat_routes into the main Router.

For message history response, include reactions as a nested array on each ChatMessage. Each message in the history response should include its reactions (grouped by emoji with count and user_pubkeys).

The WS protocol.rs dispatch does NOT need new handlers for chat -- messages flow through gossipsub and REST, not WS request/response. But the Envelope variants must be compilable for the broadcast functions to construct them.
  </action>
  <verify>
Run `cd server && /c/Users/matts/.cargo/bin/cargo build` -- compiles with new chat module, routes, and broadcast functions.
Run `cd server && /c/Users/matts/.cargo/bin/cargo test` -- all tests pass (existing 42 + any new ones).
Verify the gossip-to-WS broadcast path compiles: handle_gossip_message -> broadcast_new_message chain.
Verify the REST create message path compiles: POST /api/channels/{id}/messages -> create_message -> broadcast_new_message chain.
  </verify>
  <done>
Server has: POST create message (assigns server_sequence, persists, broadcasts NewMessageEvent), GET message history (paginated by server_sequence), PUT/DELETE for edit/delete, POST/DELETE/GET for reactions, PUT/GET for last_read. Both REST-submitted and gossip-sourced messages are broadcast as NewMessageEvent to all WS clients after persistence. All existing tests pass. The chat module is wired into the router and lib.rs.
  </done>
</task>

</tasks>

<verification>
- `cargo build` succeeds with all new proto types and chat module
- `cargo test` passes all existing tests plus new chat endpoint tests
- Proto schemas follow existing naming conventions (united.chat, united.presence)
- WS Envelope field numbers are in the 120-149 range per allocation plan
- Migration 4 is additive (ALTER TABLE + CREATE TABLE), no data loss
- POST /api/channels/{id}/messages creates a message and returns 201 with server_sequence
</verification>

<success_criteria>
1. chat.proto and presence.proto define all Phase 4 message types
2. ws.proto Envelope has 9 new payload variants (fields 120-131)
3. Migration 4 adds content_text/edited/deleted/reply_to_id to messages, creates reactions and last_read tables
4. POST /api/channels/{id}/messages creates a message, assigns server_sequence, persists, and broadcasts NewMessageEvent
5. GET /api/channels/{id}/messages returns paginated history with reactions
6. Reaction CRUD endpoints work (POST/DELETE/GET)
7. Gossip messages trigger WS broadcast of NewMessageEvent to all clients
8. Edit/delete endpoints broadcast corresponding events
9. All 42+ existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-chat/04-01-SUMMARY.md`
</output>
