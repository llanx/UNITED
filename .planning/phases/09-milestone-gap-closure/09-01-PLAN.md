---
phase: 09-milestone-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/invite/generate.rs
  - server/src/routes.rs
  - client/src/main/ipc/invite.ts
autonomous: true
gap_closure: true
requirements:
  - SRVR-09

must_haves:
  truths:
    - "User can enter an invite code and receive a valid/invalid verdict from the server"
    - "A valid invite code returns server_name and is accepted for the join flow"
    - "An invalid, expired, or exhausted code is correctly rejected"
  artifacts:
    - path: "server/src/invite/generate.rs"
      provides: "GET /api/invites/{code} route handler"
      contains: "pub async fn get_invite"
    - path: "server/src/routes.rs"
      provides: "Route registration for GET /api/invites/{code}"
      contains: "invite_gen::get_invite"
    - path: "client/src/main/ipc/invite.ts"
      provides: "INVITE_VALIDATE IPC handler calling GET /api/invites/{code}"
      contains: "/api/invites/"
  key_links:
    - from: "client/src/main/ipc/invite.ts"
      to: "server/src/invite/generate.rs"
      via: "GET /api/invites/{code}"
      pattern: "apiGet.*\\/api\\/invites\\/"
    - from: "server/src/routes.rs"
      to: "server/src/invite/generate.rs"
      via: "axum::routing::get(invite_gen::get_invite)"
      pattern: "get_invite"
---

<objective>
Fix the invite validation integration break: client calls GET /api/invites/{code} but the server has no GET handler at that path — returning 405 and causing every invite validation to silently fail.

Purpose: Invite flow is an E2E broken path. SRVR-09 requires that users can join via invite link. The validation step is the first thing that fails.
Output: A GET /api/invites/{code} route on the server that returns invite metadata; client already calls the right path and will work once the server responds correctly.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@server/src/invite/generate.rs
@server/src/routes.rs
@client/src/main/ipc/invite.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add GET /api/invites/{code} server route</name>
  <files>server/src/invite/generate.rs</files>
  <action>
    Add a new public async function `get_invite` to `server/src/invite/generate.rs`. This handler:

    - Signature: `pub async fn get_invite(State(state): State<AppState>, Path(code): Path<String>) -> Result<Json<serde_json::Value>, (StatusCode, String)>`
    - Requires NO auth (public — caller is an unauthenticated potential joiner)
    - Queries the invites table: `SELECT code, expires_at, max_uses, use_count FROM invites WHERE code = ?1`
    - Returns 404 with `"Invite not found"` if no row
    - Checks validity: if `expires_at` is non-empty and in the past (compare with `Utc::now().to_rfc3339()`), return 410 with `"Invite expired"`
    - Checks exhaustion: if `max_uses > 0 && use_count >= max_uses`, return 410 with `"Invite exhausted"`
    - On valid invite, also fetches the server name: `SELECT value FROM settings WHERE key = 'server_name'`
    - Returns 200 with JSON: `{"valid": true, "server_name": "<name or empty string>"}`

    The handler is public (no Claims extractor). Use the existing `tokio::task::spawn_blocking` + db lock pattern already used in `create_invite` and `list_invites` in the same file.

    Required imports already in scope: `axum::{extract::{Path, State}, http::StatusCode, Json}`, `chrono::Utc`, `crate::state::AppState`. Add `serde_json` usage (already a dep).
  </action>
  <verify>
    `cd server && cargo check 2>&1 | grep -E "^error"` — should produce no errors.
  </verify>
  <done>
    `server/src/invite/generate.rs` contains `pub async fn get_invite` that queries the invite by code, validates expiry and use count, and returns JSON with `valid` and `server_name`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register GET route and verify client path alignment</name>
  <files>server/src/routes.rs</files>
  <action>
    In `server/src/routes.rs`, add the GET handler to the existing `invite_routes` block. Current invite_routes:

    ```rust
    let invite_routes = Router::new()
        .route("/api/invites", axum::routing::post(invite_gen::create_invite))
        .route("/api/invites", axum::routing::get(invite_gen::list_invites))
        .route("/api/invites/{code}", axum::routing::delete(invite_gen::delete_invite));
    ```

    Change the `"/api/invites/{code}"` line to chain both DELETE and GET handlers:

    ```rust
    .route("/api/invites/{code}", axum::routing::get(invite_gen::get_invite)
        .delete(invite_gen::delete_invite));
    ```

    The GET handler must NOT be in the authenticated_routes group — it belongs in invite_routes which is merged directly (no JWT middleware on invite_routes). Confirm by checking where invite_routes is merged in the final Router::new() chain — it is a direct merge, not layered under JWT auth, so no JWT is required. This is correct: unauthenticated users call this to preview an invite before registering.

    After making the change, run `cd server && cargo check 2>&1 | grep -E "^error"` to verify compilation.

    No changes needed to `client/src/main/ipc/invite.ts` — it already calls `GET /api/invites/${inviteCode}` correctly. The client calls `apiGet<{ server_name?: string }>(serverUrl, '/api/invites/${inviteCode}')` and returns `{ valid: true, serverName: result.server_name }`. This matches the new server response exactly.
  </action>
  <verify>
    `cd server && cargo check 2>&1 | grep -E "^error"` produces no errors. Grep confirm: `grep -n "get_invite" server/src/routes.rs` shows the handler registered.
  </verify>
  <done>
    GET /api/invites/{code} is registered in routes.rs. The route is publicly accessible (no JWT required). The client's existing apiGet call to /api/invites/{code} will now receive a 200 JSON response with valid=true and server_name for valid invites, and a 404/410 for invalid/expired/exhausted invites, triggering the correct `valid: false` catch branch.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `cd server && cargo check` passes with no errors
2. `grep -n "get_invite" server/src/invite/generate.rs` shows the function defined
3. `grep -n "get_invite" server/src/routes.rs` shows it registered at GET /api/invites/{code}
4. `grep -n "api/invites" client/src/main/ipc/invite.ts` confirms the client calls the same path
5. No JWT auth is required on GET /api/invites/{code} — unauthenticated callers can validate invite codes before registering
</verification>

<success_criteria>
- GET /api/invites/{code} returns 200 + {valid: true, server_name} for a valid invite code
- GET /api/invites/{code} returns 404 for a non-existent code
- GET /api/invites/{code} returns 410 for an expired or exhausted code
- Client INVITE_VALIDATE IPC handler works with the server response without any changes
- cargo check passes with no errors
- E2E invite flow: enter code → INVITE_VALIDATE returns {valid: true} → invite join proceeds
</success_criteria>

<output>
After completion, create `.planning/phases/09-milestone-gap-closure/09-01-SUMMARY.md`
</output>
