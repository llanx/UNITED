---
phase: 09-milestone-gap-closure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - client/src/renderer/src/stores/server.ts
  - client/src/renderer/src/stores/index.ts
  - client/src/renderer/src/hooks/useVoice.ts
autonomous: true
gap_closure: true
requirements:
  - VOICE-01
  - VOICE-03

must_haves:
  truths:
    - "The local user is correctly excluded from WebRTC peer connection creation"
    - "Speaking detection shows the correct user as speaking (not a misidentified peer)"
    - "Lexicographic offer/answer role determination uses the correct user identity"
  artifacts:
    - path: "client/src/renderer/src/stores/server.ts"
      provides: "localUserId field in ServerSlice"
      contains: "localUserId"
    - path: "client/src/renderer/src/stores/index.ts"
      provides: "localUserId populated from activeServer.user_id during hydration"
      contains: "localUserId: activeServer.user_id"
    - path: "client/src/renderer/src/hooks/useVoice.ts"
      provides: "localUserId sourced from state.localUserId (not state.serverId)"
      contains: "state.localUserId"
  key_links:
    - from: "client/src/renderer/src/hooks/useVoice.ts"
      to: "client/src/renderer/src/stores/server.ts"
      via: "useStore.getState().localUserId"
      pattern: "localUserId"
    - from: "client/src/renderer/src/voice/VoiceManager.ts"
      to: "client/src/renderer/src/hooks/useVoice.ts"
      via: "joinChannel(voiceChannelId, localUserId, ...)"
      pattern: "joinChannel.*localUserId"
---

<objective>
Fix the voice localUserId bug: useVoice.ts line 81 reads `state.serverId` (the server's own UUID) instead of the authenticated user's own database UUID, causing VoiceManager to incorrectly identify the local user — breaking self-participant filtering and speaking detection.

Purpose: VOICE-01 requires functioning P2P audio; VOICE-03 requires correct speaking indicators. Both are broken when localUserId is wrong because VoiceManager cannot filter out the local user from the peer list or attribute speaking events correctly.
Output: `localUserId` field added to the store, hydrated from the server's user_id record, and used in useVoice.ts.
</objective>

<execution_context>
@C:/Users/Computer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Computer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@client/src/renderer/src/stores/server.ts
@client/src/renderer/src/stores/index.ts
@client/src/renderer/src/hooks/useVoice.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add localUserId to ServerSlice and hydrate from activeServer.user_id</name>
  <files>client/src/renderer/src/stores/server.ts, client/src/renderer/src/stores/index.ts</files>
  <action>
    **In `client/src/renderer/src/stores/server.ts`:**

    Add `localUserId: string | null` to the `ServerSlice` interface (place it after `serverId: string | null`):

    ```typescript
    serverId: string | null
    localUserId: string | null   // ← add this
    name: string | null
    ```

    Add the initial value in `createServerSlice` (place after `serverId: null`):

    ```typescript
    serverId: null,
    localUserId: null,   // ← add this
    name: null,
    ```

    No setter needed — `localUserId` is set directly via `useStore.setState(...)` during hydration.

    **In `client/src/renderer/src/stores/index.ts`:**

    In the `hydrate()` function, the block that sets state when `activeServer` exists currently reads:

    ```typescript
    useStore.setState({
      serverId: activeServer.id,
      serverUrl: activeServer.url,
      name: activeServer.name,
      description: activeServer.description,
      registrationMode: activeServer.registrationMode,
      displayName: activeServer.displayName,
    })
    ```

    Add `localUserId` here:

    ```typescript
    useStore.setState({
      serverId: activeServer.id,
      localUserId: activeServer.user_id ?? null,   // ← add this
      serverUrl: activeServer.url,
      name: activeServer.name,
      description: activeServer.description,
      registrationMode: activeServer.registrationMode,
      displayName: activeServer.displayName,
    })
    ```

    The `activeServer` object comes from `storage.getActiveServer()` which returns a `ServerRow`. `ServerRow` has `user_id: string | null` (see `client/src/main/db/queries.ts`). The `user_id` is set during `AUTH_REGISTER` when the server assigns the user a UUID and persists it to the local servers table. The `?? null` coalesces undefined to null safely.
  </action>
  <verify>
    TypeScript compile check: `cd client && npx tsc --noEmit 2>&1 | grep -E "error TS"` — should produce no errors related to localUserId.
  </verify>
  <done>
    `ServerSlice` interface includes `localUserId: string | null`. `createServerSlice` initializes it to `null`. `hydrate()` sets it from `activeServer.user_id`. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix useVoice.ts to use state.localUserId</name>
  <files>client/src/renderer/src/hooks/useVoice.ts</files>
  <action>
    In `client/src/renderer/src/hooks/useVoice.ts`, find the bug at line 81 inside the `signaling.onJoinResponse` handler:

    ```typescript
    // Get local user ID from auth state
    const localUserId = state.serverId || ''
    ```

    Change it to:

    ```typescript
    // Get local user ID (DB UUID assigned by server during registration)
    const localUserId = state.localUserId || ''
    ```

    The `state` here is `useStore.getState()` (called on line 72 as `const state = useStore.getState()`). `state.localUserId` is the user's own database UUID — the same value that the server uses as `user_id` in `VoiceParticipant` messages. This ensures VoiceManager correctly:
    - Skips creating a peer connection to itself (`participant.userId === localUserId`)
    - Determines offer/answer role correctly via `shouldOffer` (lexicographic comparison of the correct UUIDs)
    - Attributes speaking detection events to the correct participant

    No other changes needed in this file.
  </action>
  <verify>
    1. `grep -n "localUserId" client/src/renderer/src/hooks/useVoice.ts` shows `state.localUserId` (not `state.serverId`)
    2. `cd client && npx tsc --noEmit 2>&1 | grep -E "error TS"` produces no errors
  </verify>
  <done>
    Line 81 of `useVoice.ts` reads `const localUserId = state.localUserId || ''`. The VoiceManager will now receive the user's own server-assigned UUID, matching what the server sends in VoiceParticipant.user_id for all participants.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `grep -n "localUserId" client/src/renderer/src/stores/server.ts` shows the field in the interface and slice
2. `grep -n "localUserId" client/src/renderer/src/stores/index.ts` shows it set from `activeServer.user_id`
3. `grep -n "localUserId" client/src/renderer/src/hooks/useVoice.ts` shows `state.localUserId` used (not `state.serverId`)
4. TypeScript compiles without errors
5. No occurrences of `state.serverId` remain in useVoice.ts
</verification>

<success_criteria>
- `localUserId: string | null` exists in ServerSlice interface and is initialized to null
- `hydrate()` populates `localUserId` from `activeServer.user_id`
- `useVoice.ts` uses `state.localUserId` (not `state.serverId`) for VoiceManager identity
- TypeScript compilation passes with no new errors
- When user joins a voice channel, VoiceManager receives their actual server UUID — self-participant filtering and lexicographic offer/answer role are both correct
</success_criteria>

<output>
After completion, create `.planning/phases/09-milestone-gap-closure/09-02-SUMMARY.md`
</output>
