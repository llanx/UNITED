---
phase: 07-media-and-prefetching
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/proto/blocks.proto
  - shared/proto/chat.proto
  - server/src/config.rs
  - server/src/blocks/routes.rs
  - server/src/routes.rs
  - server/src/db/migrations.rs
  - server/src/chat/messages.rs
  - server/src/chat/broadcast.rs
  - server/tests/auth_test.rs
  - server/tests/channels_test.rs
  - server/tests/roles_test.rs
  - server/tests/invite_test.rs
  - server/tests/moderation_test.rs
  - server/tests/ws_test.rs
  - client/package.json
  - client/src/main/blocks/thumbnails.ts
  - client/src/main/ipc/media.ts
  - client/src/main/ipc/channels.ts
  - client/src/main/index.ts
  - client/src/preload/index.ts
  - shared/types/ipc-bridge.ts
autonomous: true
requirements:
  - MEDIA-01
  - MEDIA-04

must_haves:
  truths:
    - "User can select files via attachment button, drag-drop, or clipboard paste and the files are chunked into blocks before message send"
    - "Images have blurhash strings encoded alongside existing micro-thumbnails in gossip payload"
    - "Video files get a thumbnail still frame extracted via ffmpeg"
    - "Server enforces a configurable max upload size (default 100 MB)"
    - "Protobuf ChatMessage has a repeated block_refs field and BlockRef has a blurhash field"
    - "Server persists block_refs JSON in the messages table and returns them in history/broadcast"
    - "TypeScript ChatMessage interface has block_refs field for renderer consumption"
  artifacts:
    - path: "shared/proto/blocks.proto"
      provides: "BlockRef with blurhash field"
      contains: "string blurhash"
    - path: "shared/proto/chat.proto"
      provides: "ChatMessage with block_refs"
      contains: "repeated united.blocks.BlockRef block_refs"
    - path: "client/src/main/ipc/media.ts"
      provides: "File upload orchestration, blocking send, progress reporting"
      exports: ["registerMediaHandlers"]
    - path: "client/src/main/blocks/thumbnails.ts"
      provides: "Blurhash encoding, video thumbnail extraction"
      exports: ["generateBlurhash", "generateVideoThumbnail", "isVideoMime"]
    - path: "server/src/config.rs"
      provides: "max_upload_size_mb in BlocksConfig"
      contains: "max_upload_size_mb"
    - path: "server/src/chat/messages.rs"
      provides: "Extended create/query handlers accepting and returning block_refs"
      contains: "block_refs"
    - path: "shared/types/ipc-bridge.ts"
      provides: "ChatMessage with block_refs, BlockRefData, FileAttachment, UploadProgress, media namespace"
      contains: "block_refs"
  key_links:
    - from: "client/src/main/ipc/media.ts"
      to: "client/src/main/blocks/index.ts"
      via: "putBlock for block storage"
      pattern: "putBlock"
    - from: "client/src/main/ipc/media.ts"
      to: "client/src/main/blocks/thumbnails.ts"
      via: "blurhash + thumbnail generation"
      pattern: "generateBlurhash|generateVideoThumbnail"
    - from: "shared/proto/chat.proto"
      to: "shared/proto/blocks.proto"
      via: "import for BlockRef type"
      pattern: "import.*blocks.proto"
    - from: "server/src/chat/messages.rs"
      to: "server/src/db/migrations.rs"
      via: "block_refs_json column in messages table"
      pattern: "block_refs_json"
---

<objective>
Build the file upload infrastructure: protobuf schema extensions for media attachments, server-side migration and endpoint extensions for block_refs, blurhash encoding, video thumbnail extraction, blocking send with progress reporting, and server-side upload size enforcement.

Purpose: This plan creates the foundational upload pipeline that Phase 7 Plans 02 and 03 build upon. Files are chunked into blocks, thumbnails and blurhash placeholders are generated, and the message is only published after all blocks are stored. The server persists block_refs alongside messages and returns them in history and WS broadcasts.

Output: Extended protobuf schemas, server migration 7 (block_refs_json column), extended server chat endpoints, media IPC handlers with upload orchestration, blurhash + video thumbnail generation, server max_upload_size enforcement.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-media-and-prefetching/07-CONTEXT.md
@.planning/phases/07-media-and-prefetching/07-RESEARCH.md
@.planning/phases/06-content-distribution/06-01-SUMMARY.md
@.planning/phases/06-content-distribution/06-02-SUMMARY.md
@.planning/phases/06-content-distribution/06-04-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From shared/proto/blocks.proto (CURRENT -- will be extended):
```protobuf
message BlockRef {
    string hash = 1;
    uint64 size = 2;
    string mime_type = 3;
    uint32 width = 4;
    uint32 height = 5;
    bytes micro_thumbnail = 6;
    string filename = 7;
}
```

From shared/proto/chat.proto (CURRENT -- will be extended):
```protobuf
message ChatMessage {
    string id = 1;
    string channel_id = 2;
    string sender_pubkey = 3;
    string sender_display_name = 4;
    string content = 5;
    uint64 timestamp = 6;
    uint64 server_sequence = 7;
    bytes signature = 8;
    optional string reply_to_id = 9;
    bool edited = 10;
    repeated string mention_user_ids = 11;
    repeated string mention_role_ids = 12;
    // Field 13 will be added for block_refs
}
```

From server/src/chat/messages.rs (CURRENT -- will be extended):
```rust
pub struct CreateMessageRequest {
    pub content: String,
    pub reply_to_id: Option<String>,
    // block_refs_json will be added
}

pub struct MessageResponse {
    pub id: String,
    pub channel_id: String,
    pub sender_pubkey: String,
    pub sender_display_name: String,
    pub content: String,
    pub timestamp: u64,
    pub server_sequence: u64,
    pub reply_to_id: Option<String>,
    pub edited: bool,
    pub reactions: Vec<ReactionGroup>,
    // block_refs_json will be added
}
```

From server/src/config.rs:
```rust
pub struct BlocksConfig {
    pub retention_days: u32,
    pub cleanup_interval_secs: u64,
    // max_upload_size_mb will be added
}
```

From client/src/main/blocks/thumbnails.ts:
```typescript
export function isImageMime(mimeType: string): boolean
export function getFileMimeType(filename: string): string
export async function generateMicroThumbnail(imageData: Buffer): Promise<MicroThumbnailResult>
```

From client/src/main/blocks/index.ts:
```typescript
export function putBlock(data: Buffer, tier: ContentTier, meta?: Partial<BlockMeta>): string
export async function getBlock(hash: string): Promise<Buffer | null>
```

From shared/types/ipc-bridge.ts:
```typescript
export interface ChatMessage {
  id: string; channel_id: string; sender_pubkey: string; sender_display_name: string;
  content: string; timestamp: string; server_sequence: number;
  reply_to_id: string | null; reply_to_preview: string | null;
  edited_at: string | null; reactions: ReactionSummary[];
  // block_refs will be added
}

// blocks namespace already exists with putBlock, getBlock, resolveBlock, etc.
// chat.send(channelId, content, replyToId?) exists
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend protobuf schemas, server migration, chat endpoints, and upload size enforcement</name>
  <files>
    shared/proto/blocks.proto
    shared/proto/chat.proto
    server/src/config.rs
    server/src/blocks/routes.rs
    server/src/routes.rs
    server/src/db/migrations.rs
    server/src/chat/messages.rs
    server/src/chat/broadcast.rs
    server/tests/auth_test.rs
    server/tests/channels_test.rs
    server/tests/roles_test.rs
    server/tests/invite_test.rs
    server/tests/moderation_test.rs
    server/tests/ws_test.rs
    shared/types/ipc-bridge.ts
  </files>
  <action>
    **1. Extend shared/proto/blocks.proto:**
    Add `string blurhash = 8;` field to BlockRef message. This carries the ~30 byte blurhash string alongside the existing micro_thumbnail for dual-placeholder strategy.

    **2. Extend shared/proto/chat.proto:**
    Add `import "blocks.proto";` at the top (after package declaration).
    Add `repeated united.blocks.BlockRef block_refs = 13;` to ChatMessage. Field number 13 is the next available slot. This carries media attachment references in chat messages.
    IMPORTANT: Existing messages without block_refs will simply have an empty array -- proto3 repeated fields default to empty. Always check `message.blockRefs?.length > 0` before rendering attachments.

    **3. Add max_upload_size_mb to server config:**
    In `server/src/config.rs`, add `max_upload_size_mb: u32` field to `BlocksConfig` with default 100 and a `default_max_upload_size()` function returning 100. Add `#[serde(default = "default_max_upload_size")]` annotation.
    Add `max_upload_size_mb` to the AppState fields (similar to how block_retention_days was added). The value should be read from `blocks.max_upload_size_mb` in main.rs when constructing AppState.

    **4. Enforce upload size limit on PUT /api/blocks:**
    In `server/src/blocks/routes.rs`, the `put_block_route` handler should check the body length against `state.max_upload_size_mb * 1024 * 1024` and return 413 Payload Too Large if exceeded.
    Also add an axum `DefaultBodyLimit` layer on the block upload route in `server/src/routes.rs` using the configured max_upload_size_mb. Import `axum::extract::DefaultBodyLimit` and apply `.layer(DefaultBodyLimit::max(max_bytes))` to the blocks PUT route.

    **5. Create Migration 7 for block_refs column:**
    In `server/src/db/migrations.rs`, add Migration 7:
    ```sql
    -- Migration 7: Media Attachments (Phase 7)
    ALTER TABLE messages ADD COLUMN block_refs_json TEXT;
    ```
    This stores the array of block references as a JSON string. Null for messages without attachments.

    **6. Extend server chat message create endpoint:**
    In `server/src/chat/messages.rs`:
    - Add `block_refs_json: Option<String>` to `CreateMessageRequest`. This is a JSON-serialized array of block reference objects from the client.
    - Add `block_refs_json: Option<String>` to `MessageResponse`.
    - In the `create_message` handler: insert `block_refs_json` into the SQL INSERT statement.
    - In the history/get queries: select `block_refs_json` and include in MessageResponse.
    - In the message broadcast builder: include `block_refs_json` in the WS event data so recipients get block_refs in real-time.

    **7. Extend TypeScript ChatMessage interface:**
    In `shared/types/ipc-bridge.ts`, add to the ChatMessage interface:
    ```typescript
    block_refs?: BlockRefData[];
    ```
    Also add the `BlockRefData` interface:
    ```typescript
    export interface BlockRefData {
      hash: string;
      size: number;
      mimeType: string;
      width: number;
      height: number;
      microThumbnail?: string;  // base64 encoded
      blurhash?: string;
      filename: string;
    }
    ```

    **8. Update test AppState constructors:**
    Add `max_upload_size_mb` (or the appropriate field) to all test files that construct AppState. Follow the exact pattern used when block_retention_days was added in Phase 6 Plan 01. Files: auth_test.rs, channels_test.rs, roles_test.rs, invite_test.rs, moderation_test.rs, ws_test.rs.

    **9. Run `buf generate` in the shared directory** to regenerate TypeScript protobuf types (these are gitignored). Run `cargo build` in server to verify compilation. Run `cargo test` to verify all existing tests pass with the new migration and config field.
  </action>
  <verify>
    <automated>cd /c/Users/matts/united/server && /c/Users/matts/.cargo/bin/cargo test 2>&1 | tail -5</automated>
  </verify>
  <done>
    BlockRef proto has blurhash field (field 8). ChatMessage proto has repeated block_refs field (field 13, importing blocks.proto). Server config has max_upload_size_mb (default 100). PUT /api/blocks rejects uploads exceeding the limit with 413. Migration 7 adds block_refs_json column to messages table. Server chat create/query endpoints accept and return block_refs_json. TypeScript ChatMessage has block_refs field. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Media upload IPC handlers with blurhash, video thumbnails, and blocking send</name>
  <files>
    client/package.json
    client/src/main/blocks/thumbnails.ts
    client/src/main/ipc/media.ts
    client/src/main/ipc/channels.ts
    client/src/main/index.ts
    client/src/preload/index.ts
    shared/types/ipc-bridge.ts
  </files>
  <action>
    **1. Install npm dependencies:**
    ```bash
    cd client && npm install blurhash fluent-ffmpeg ffmpeg-static
    ```
    Also install types: `npm install -D @types/fluent-ffmpeg`
    Note: Configure electron-builder to exclude ffmpeg-static from ASAR packaging. In client/package.json build config, add `"asarUnpack": ["**/node_modules/ffmpeg-static/**"]` if an electron-builder config exists, otherwise note this for later packaging.

    **2. Extend client/src/main/blocks/thumbnails.ts:**
    Add a `generateBlurhash(imageData: Buffer): Promise<string>` function:
    - Import `encode` from `blurhash` (the npm package)
    - Resize to 32x32 using sharp (fit: 'inside'), ensureAlpha(), raw() format
    - Call `encode(new Uint8ClampedArray(data), info.width, info.height, 4, 3)` (4 x-components, 3 y-components)
    - Return the blurhash string (~30 bytes)

    Add a `isVideoMime(mimeType: string): boolean` function:
    - Check against set: video/mp4, video/webm, video/quicktime, video/x-msvideo, video/x-matroska

    Add a `generateVideoThumbnail(videoPath: string): Promise<{ thumbnail: Buffer; width: number; height: number } | null>` function:
    - Import ffmpeg from fluent-ffmpeg and ffmpegStatic from ffmpeg-static
    - Set ffmpeg path: `ffmpeg.setFfmpegPath(ffmpegStatic!)`
    - Extract a frame at 1 second (avoids black first frames) to a temp file in `os.tmpdir()`
    - Use `ffprobe` (via ffmpeg) or the screenshots output to get width/height
    - Read the temp file, delete it, return { thumbnail, width, height }
    - On error, return null (graceful degradation -- video will show play button without thumbnail)

    Add VIDEO_MIMES Set constant alongside IMAGE_MIMES.

    **3. Create client/src/main/ipc/media.ts:**
    This is the upload orchestration module. Implements the blocking send pattern.

    Export `registerMediaHandlers(mainWindow: BrowserWindow)` function that registers these IPC handlers:

    a) `MEDIA_UPLOAD_FILES` handler:
       - Receives: `{ channelId: string, content: string, replyToId?: string, files: Array<{ path: string, name: string, mimeType: string }> }`
       - For each file (up to 10):
         - Read file from disk via `fs.promises.readFile(file.path)`
         - Validate file size against 100 MB limit (configurable -- read from server config via stored value or hardcode 100MB default). Throw if exceeded.
         - Call `computeBlockHash(data)` from blocks/crypto.ts to get the content hash
         - Call `putBlock(data, ContentTier.P2_HOT, { mimeType, filename, width?, height? })` to store locally
         - Upload block to server via `PUT /api/blocks` with X-Block-Hash and X-Channel-Id headers (use the auth token from `getAccessToken()` in ipc/auth.ts and the server URL from `getServerUrl()`)
         - If image: call `generateMicroThumbnail(data)` for dimensions, then `generateBlurhash(data)` for the blurhash string
         - If video: call `generateVideoThumbnail(filePath)` for a thumbnail still. If thumbnail returned, call `generateBlurhash(thumbBuffer)` on it and `generateMicroThumbnail(thumbBuffer)` for the micro-thumb.
         - Build a BlockRefData object: `{ hash, size: data.length, mimeType, width, height, microThumbnail (base64), blurhash, filename }`
         - Send progress event to renderer: `mainWindow.webContents.send(IPC.PUSH_UPLOAD_PROGRESS, { fileIndex: i, totalFiles: files.length, percent: 100 })`
       - After all files processed, send the message via the existing REST endpoint (POST /api/channels/{channelId}/messages) with `block_refs_json: JSON.stringify(blockRefs)` included alongside content and reply_to_id
       - Use the apiPost helper pattern from existing IPC modules (ipc/connection.ts has getAccessToken/getServerUrl)
       - Return the sent message

    b) `MEDIA_PICK_FILES` handler:
       - Opens an Electron file dialog (`dialog.showOpenDialog` from `electron`) with `properties: ['openFile', 'multiSelections']`
       - Returns array of `{ path, name, mimeType }` for selected files (use `getFileMimeType` from thumbnails.ts, `path.basename` for name)

    **4. Add IPC channel constants to client/src/main/ipc/channels.ts:**
    Add `MEDIA_UPLOAD_FILES`, `MEDIA_PICK_FILES`, `PUSH_UPLOAD_PROGRESS` channel constants.

    **5. Register media handlers in client/src/main/index.ts:**
    Import `registerMediaHandlers` and call it during app initialization, passing the mainWindow reference.

    **6. Extend client/src/preload/index.ts:**
    Add `media` namespace to the contextBridge exposure:
    ```typescript
    media: {
      uploadFiles: (params: { channelId: string; content: string; replyToId?: string; files: FileAttachment[] }) =>
        ipcRenderer.invoke(IPC.MEDIA_UPLOAD_FILES, params),
      pickFiles: () => ipcRenderer.invoke(IPC.MEDIA_PICK_FILES),
      onUploadProgress: (cb: (progress: UploadProgress) => void) => {
        ipcRenderer.on(IPC.PUSH_UPLOAD_PROGRESS, (_e: unknown, data: UploadProgress) => cb(data))
        return () => { ipcRenderer.removeAllListeners(IPC.PUSH_UPLOAD_PROGRESS) }
      }
    }
    ```

    **7. Extend shared/types/ipc-bridge.ts (media types and namespace):**
    Add `FileAttachment` interface: `{ path: string; name: string; mimeType: string }`
    Add `UploadProgress` interface: `{ fileIndex: number; totalFiles: number; percent: number }`
    Add `media` namespace to UnitedAPI:
    ```typescript
    media: {
      uploadFiles(params: { channelId: string; content: string; replyToId?: string; files: FileAttachment[] }): Promise<ChatMessage>;
      pickFiles(): Promise<FileAttachment[]>;
      onUploadProgress(callback: (progress: UploadProgress) => void): () => void;
    }
    ```
  </action>
  <verify>
    <automated>cd /c/Users/matts/united/client && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>
    blurhash, fluent-ffmpeg, ffmpeg-static installed. thumbnails.ts has generateBlurhash() and generateVideoThumbnail(). media.ts IPC handlers implement blocking send with progress. Preload bridge exposes media namespace. UnitedAPI types updated with media methods and BlockRefData/FileAttachment/UploadProgress interfaces. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. Proto: `grep "blurhash" shared/proto/blocks.proto` returns the field definition
2. Proto: `grep "block_refs" shared/proto/chat.proto` returns the repeated field
3. Server: `cargo test` in server/ passes all existing tests + new migration and config field compiles
4. Server: `grep "block_refs_json" server/src/chat/messages.rs` shows the field in create/response structs
5. Migration: `grep "block_refs_json" server/src/db/migrations.rs` shows the ALTER TABLE
6. Client: `npx tsc --noEmit` in client/ compiles without errors
7. Deps: `node -e "require('blurhash')"` and `node -e "require('ffmpeg-static')"` succeed in client/
8. Types: `grep "block_refs" shared/types/ipc-bridge.ts` shows field on ChatMessage
</verification>

<success_criteria>
- BlockRef protobuf has blurhash field (field 8)
- ChatMessage protobuf has repeated block_refs (field 13) importing blocks.proto
- Server BlocksConfig has max_upload_size_mb (default 100) and PUT /api/blocks enforces it with 413
- Migration 7 adds block_refs_json TEXT column to messages table
- Server create_message accepts block_refs_json, stores it, and returns it in responses and WS broadcasts
- TypeScript ChatMessage interface has `block_refs?: BlockRefData[]` field
- Client has generateBlurhash() producing ~30 byte strings from images via sharp resize + blurhash encode
- Client has generateVideoThumbnail() extracting a still frame at 1s via ffmpeg (returns null on failure)
- Media IPC module handles blocking send: read files, store blocks, generate thumbnails + blurhash, upload to server, then send message with block_refs
- Preload bridge exposes media.uploadFiles, media.pickFiles, media.onUploadProgress
- All existing tests pass on both server and client
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-and-prefetching/07-01-SUMMARY.md`
</output>
