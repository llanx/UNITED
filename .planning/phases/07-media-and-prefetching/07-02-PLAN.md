---
phase: 07-media-and-prefetching
plan: 02
type: execute
wave: 2
depends_on:
  - "07-01"
files_modified:
  - client/src/renderer/src/components/InlineImage.tsx
  - client/src/renderer/src/components/InlineVideo.tsx
  - client/src/renderer/src/components/ImageGrid.tsx
  - client/src/renderer/src/components/Lightbox.tsx
  - client/src/renderer/src/components/BlurhashPlaceholder.tsx
  - client/src/renderer/src/components/FilePreview.tsx
  - client/src/renderer/src/components/UploadProgress.tsx
  - client/src/renderer/src/components/MessageComposer.tsx
  - client/src/renderer/src/components/MessageRow.tsx
  - client/src/renderer/src/components/ChatView.tsx
autonomous: true
requirements:
  - MEDIA-02
  - MEDIA-03
  - P2P-04

must_haves:
  truths:
    - "User can attach files via paperclip button, drag-and-drop onto chat area, or Ctrl+V clipboard paste"
    - "File previews appear in the composer with thumbnail, filename, size, and remove button before sending"
    - "Upload progress bar shows in composer during blocking send, message only appears after blocks are stored"
    - "Images render inline within messages at constrained max-box dimensions (~400-500px wide, ~350px tall)"
    - "Micro-thumbnail shows as blurry preview inline while full image loads from peers"
    - "Clicking an image opens full-screen lightbox with blurhash gradient placeholder while full-res loads"
    - "Videos show thumbnail with play button overlay; click plays inline with standard controls"
    - "Multi-image messages render in adaptive grid (2: side-by-side, 3: 1+2, 4: 2x2, 5+: 2x2 with +N more)"
    - "Mixed media messages show images in grid above, non-image file cards below"
  artifacts:
    - path: "client/src/renderer/src/components/InlineImage.tsx"
      provides: "Constrained image with micro-thumbnail fallback and click-to-lightbox"
    - path: "client/src/renderer/src/components/InlineVideo.tsx"
      provides: "Video thumbnail with play overlay, click-to-play inline"
    - path: "client/src/renderer/src/components/ImageGrid.tsx"
      provides: "Adaptive multi-image grid layout (2/3/4/5+)"
    - path: "client/src/renderer/src/components/Lightbox.tsx"
      provides: "YARL lightbox wrapper with blurhash placeholders and gallery navigation"
    - path: "client/src/renderer/src/components/BlurhashPlaceholder.tsx"
      provides: "Canvas-based blurhash decoding component"
    - path: "client/src/renderer/src/components/FilePreview.tsx"
      provides: "Composer file preview with thumbnail, name, size, remove"
    - path: "client/src/renderer/src/components/UploadProgress.tsx"
      provides: "Progress bar in composer during blocking send"
    - path: "client/src/renderer/src/components/MessageComposer.tsx"
      provides: "Extended composer with attachment button, drag-drop, paste, file staging"
    - path: "client/src/renderer/src/components/MessageRow.tsx"
      provides: "Extended message row rendering inline media attachments"
  key_links:
    - from: "client/src/renderer/src/components/MessageComposer.tsx"
      to: "window.united.media.uploadFiles"
      via: "IPC call for blocking send"
      pattern: "window\\.united\\.media\\.uploadFiles"
    - from: "client/src/renderer/src/components/InlineImage.tsx"
      to: "client/src/renderer/src/hooks/useBlockContent.ts"
      via: "Block resolution for full image"
      pattern: "useBlockContent"
    - from: "client/src/renderer/src/components/MessageRow.tsx"
      to: "client/src/renderer/src/components/ImageGrid.tsx"
      via: "Renders image attachments in adaptive grid"
      pattern: "ImageGrid"
---

<objective>
Build the complete media rendering UI: composer file attachment (3 input methods), file preview/staging, upload progress, inline image/video rendering with dual placeholder strategy, adaptive multi-image grid, and full-screen lightbox gallery.

Purpose: This plan delivers the user-visible media experience. Users attach files in the composer, see upload progress, and recipients see inline images/videos with smooth placeholder transitions. The lightbox provides full-resolution viewing with blurhash gradients while loading.

Output: 7 new components (InlineImage, InlineVideo, ImageGrid, Lightbox, BlurhashPlaceholder, FilePreview, UploadProgress) + extended MessageComposer and MessageRow.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-media-and-prefetching/07-CONTEXT.md
@.planning/phases/07-media-and-prefetching/07-RESEARCH.md
@.planning/phases/07-media-and-prefetching/07-01-SUMMARY.md
@.planning/phases/06-content-distribution/06-04-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase + Plan 07-01 output. -->

From shared/types/ipc-bridge.ts (after Plan 07-01):
```typescript
export interface FileAttachment { path: string; name: string; mimeType: string }
export interface UploadProgress { fileIndex: number; totalFiles: number; percent: number }
export interface BlockRefData {
  hash: string; size: number; mimeType: string;
  width: number; height: number;
  microThumbnail?: string; blurhash?: string; filename: string;
}

export interface ChatMessage {
  id: string; channel_id: string; sender_pubkey: string; sender_display_name: string;
  content: string; timestamp: string; server_sequence: number;
  reply_to_id: string | null; reply_to_preview: string | null;
  edited_at: string | null; reactions: ReactionSummary[];
  block_refs?: BlockRefData[];  // Added by 07-01
}

// UnitedAPI.media namespace (added by 07-01):
media: {
  uploadFiles(params: { channelId: string; content: string; replyToId?: string; files: FileAttachment[] }): Promise<ChatMessage>;
  pickFiles(): Promise<FileAttachment[]>;
  onUploadProgress(callback: (progress: UploadProgress) => void): () => void;
}
```

From client/src/renderer/src/hooks/useBlockContent.ts:
```typescript
export function useBlockContent(hash: string | null): { status: string; data: string | null; progress: string; retry: () => void }
```

From client/src/renderer/src/components/ContentPlaceholder.tsx:
```typescript
interface ContentPlaceholderProps { width: number; height: number; progress: 'cache' | 'fetching' | 'unavailable'; onRetry?: () => void }
```

From client/src/renderer/src/components/AttachmentCard.tsx:
```typescript
interface AttachmentCardProps { filename: string; size: number; mimeType: string; onDownload?: () => void }
```

From client/src/renderer/src/components/MessageComposer.tsx:
```typescript
interface MessageComposerProps {
  channelId: string; channelName: string; replyTo: ChatMessage | null;
  onCancelReply: () => void; onMessageSent: () => void;
}
```

From client/src/renderer/src/components/MessageRow.tsx:
```typescript
interface MessageRowProps {
  message: ChatMessage; isGrouped: boolean;
  onReply: (message: ChatMessage) => void; onScrollToMessage?: (messageId: string) => void;
}
```

From blurhash npm package (renderer):
```typescript
import { decode, isBlurhashValid } from 'blurhash'
// decode(hash: string, width: number, height: number): Uint8ClampedArray
```

From yet-another-react-lightbox:
```typescript
import Lightbox from 'yet-another-react-lightbox'
import Zoom from 'yet-another-react-lightbox/plugins/zoom'
import 'yet-another-react-lightbox/styles.css'
// <Lightbox open={open} close={onClose} slides={slides} plugins={[Zoom]} />
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inline media components -- InlineImage, InlineVideo, BlurhashPlaceholder, ImageGrid, Lightbox</name>
  <files>
    client/src/renderer/src/components/InlineImage.tsx
    client/src/renderer/src/components/InlineVideo.tsx
    client/src/renderer/src/components/BlurhashPlaceholder.tsx
    client/src/renderer/src/components/ImageGrid.tsx
    client/src/renderer/src/components/Lightbox.tsx
  </files>
  <action>
    **Install renderer dependency:**
    The `blurhash` npm package is needed in the renderer for decoding. It was installed in client/ by 07-01.
    Install `yet-another-react-lightbox`: `cd client && npm install yet-another-react-lightbox`

    **1. Create BlurhashPlaceholder.tsx:**
    - Props: `{ hash: string; width: number; height: number }` -- the display dimensions, not decode dimensions
    - Use `useRef<HTMLCanvasElement>` and `useEffect` to decode and render
    - Decode at small resolution (Math.min(width, 32) x Math.min(height, 32)) for performance -- CSS scales up
    - Validate hash with `isBlurhashValid(hash).result` before decoding
    - Canvas style: `width: '100%', height: '100%', objectFit: 'cover'`
    - Memoize with `React.memo` to avoid re-decoding on parent re-renders

    **2. Create InlineImage.tsx:**
    - Props: `{ blockRef: BlockRefData; onClick: () => void }` where BlockRefData is the block reference from the message
    - Constrained max-box: max-width 480px, max-height 350px. If image is smaller, render at original dimensions. Use CSS `max-width` and `max-height` with `object-fit: contain`.
    - Container div has fixed dimensions based on blockRef.width/height (scaled to fit within max-box). This prevents reflow per APP-04.
    - Calculate scaled dimensions: `const scale = Math.min(480 / blockRef.width, 350 / blockRef.height, 1); const displayW = Math.round(blockRef.width * scale); const displayH = Math.round(blockRef.height * scale);`
    - Loading states (layered):
      1. If blockRef.microThumbnail exists: show it as a blurry `<img>` (data URL `data:image/jpeg;base64,${blockRef.microThumbnail}`) at container dimensions with CSS `filter: blur(4px)`. This is the inline placeholder.
      2. If no microThumbnail: show ContentPlaceholder shimmer at container dimensions
      3. When full image loaded (via useBlockContent): transition to full image (remove blur/placeholder)
    - Full image loading: call `useBlockContent(blockRef.hash)` -- when status is 'loaded', render `<img src="data:${blockRef.mimeType};base64,${data}" />` at container dimensions
    - Click handler calls onClick (opens lightbox)
    - GIF/animated images: render with standard `<img>` tag which auto-plays -- follow Discord/Slack convention per user's Claude discretion note
    - Add `cursor: pointer` for click affordance

    **3. Create InlineVideo.tsx:**
    - Props: `{ blockRef: BlockRefData }` where blockRef has width, height, microThumbnail (of the video thumbnail)
    - Initial state: show thumbnail image (from microThumbnail) with a centered play button overlay (CSS absolute positioning, semi-transparent dark circle with white triangle)
    - Container div has fixed dimensions based on blockRef.width/height scaled to max-box (480x350), same calculation as InlineImage
    - State: `const [playing, setPlaying] = useState(false)`
    - On play click: set playing=true, resolve the full video via `useBlockContent(blockRef.hash)`, then create a blob URL from the base64 data: `URL.createObjectURL(new Blob([Uint8Array.from(atob(data), c => c.charCodeAt(0))], { type: blockRef.mimeType }))`
    - IMPORTANT: Do NOT set video src until user clicks play. This prevents bandwidth drain from multiple videos in scroll history (Research Pitfall 7).
    - Video element: `controls` attribute, NO `autoPlay`, constrained to container dimensions
    - If no thumbnail available: show ContentPlaceholder at dimensions with a play icon overlaid
    - Clean up blob URL on unmount via `URL.revokeObjectURL` in useEffect cleanup

    **4. Create ImageGrid.tsx:**
    - Props: `{ images: BlockRefData[]; onImageClick: (index: number) => void }`
    - Adaptive grid based on image count (per CONTEXT.md locked decisions):
      - 1 image: single InlineImage, full max-box width
      - 2 images: CSS grid `grid-template-columns: 1fr 1fr`, gap 4px
      - 3 images: CSS grid with first image spanning 2 rows (2/3 width), two smaller images stacked (1/3 width). Use `grid-template-columns: 2fr 1fr; grid-template-rows: 1fr 1fr;` with first image `grid-row: 1 / 3`
      - 4 images: CSS grid `grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;` (2x2)
      - 5+ images: Same as 4, but 4th image has "+N more" overlay (absolute-positioned dark semi-transparent div with white text). N = total - 4.
    - Max grid container width: 500px. Each cell renders InlineImage.
    - onClick passes the image index to parent for lightbox
    - For grids (2+), each cell should have a fixed height based on max-box/2 to keep grid uniform

    **5. Create Lightbox.tsx:**
    - Props: `{ images: BlockRefData[]; open: boolean; initialIndex: number; onClose: () => void }`
    - Uses `yet-another-react-lightbox` with Zoom plugin
    - Import the CSS: `import 'yet-another-react-lightbox/styles.css'`
    - Map images to slides: for each BlockRefData, create a slide with:
      - `src`: this will be dynamically resolved -- use a custom render function
      - `width` and `height` from blockRef
    - Use YARL's `render.slide` customization to implement the dual placeholder strategy:
      - Initially show BlurhashPlaceholder (if blockRef.blurhash exists) at the slide dimensions
      - Resolve full image via useBlockContent in a wrapper component
      - When loaded, render `<img>` replacing the blurhash
    - Create an internal `LightboxSlide` component that takes a BlockRefData and handles the resolution + placeholder transition
    - Keyboard navigation (left/right arrows, Escape to close) comes built-in with YARL
    - Dark backdrop (YARL default)
  </action>
  <verify>
    <automated>cd /c/Users/matts/united/client && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>
    InlineImage renders images at constrained max-box with micro-thumbnail placeholder and full-image transition. InlineVideo shows thumbnail + play overlay, only loads video on click. BlurhashPlaceholder decodes blurhash to canvas. ImageGrid implements adaptive 1/2/3/4/5+ layouts per CONTEXT.md. Lightbox wraps YARL with blurhash placeholder slides and gallery navigation. yet-another-react-lightbox installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Composer file attachment UI and MessageRow media rendering</name>
  <files>
    client/src/renderer/src/components/FilePreview.tsx
    client/src/renderer/src/components/UploadProgress.tsx
    client/src/renderer/src/components/MessageComposer.tsx
    client/src/renderer/src/components/MessageRow.tsx
    client/src/renderer/src/components/ChatView.tsx
  </files>
  <action>
    **1. Create FilePreview.tsx:**
    - Props: `{ file: FileAttachment; onRemove: () => void }` (FileAttachment from ipc-bridge.ts)
    - Renders a compact card: file icon (based on MIME type category -- reuse simple icon logic: image/video/audio/document/archive/code/generic), filename (truncated to ~30 chars with ellipsis), file size formatted as KB/MB, and an "X" close button for removal
    - For image files: show a small thumbnail preview (the file path can be used as `file://${file.path}` but in Electron CSP this may be blocked -- instead just show an image type icon)
    - Compact horizontal layout: `flex items-center gap-2 px-3 py-2`, subtle border, dark background consistent with theme (`bg-[var(--bg-secondary)]`)

    **2. Create UploadProgress.tsx:**
    - Props: `{ fileIndex: number; totalFiles: number; percent: number }`
    - Renders a progress bar: thin horizontal bar (4px height) with accent color fill (`bg-[var(--accent)]`)
    - Text above bar: "Uploading file {fileIndex + 1} of {totalFiles}..." in muted text color
    - When percent is 100 for the last file (fileIndex + 1 === totalFiles), show "Sending message..." briefly
    - Container matches the same width/padding as the file preview area

    **3. Extend MessageComposer.tsx:**
    Add file attachment state and three input methods.

    State additions:
    - `const [stagedFiles, setStagedFiles] = useState<FileAttachment[]>([])`
    - `const [uploading, setUploading] = useState(false)`
    - `const [uploadProgress, setUploadProgress] = useState<UploadProgress | null>(null)`

    a) **Attachment button:** Add a paperclip/plus icon button to the left of the textarea (or in the button bar). On click, call `window.united.media.pickFiles()` then add returned files to stagedFiles (enforce max 10 total, silently drop extras).

    b) **Drag-and-drop:** Add drag event handlers to the composer's container div:
    - Use a `dragCounter` ref (increment on dragenter, decrement on dragleave, reset to 0 on drop) to properly track nested element drag events.
    - `const [isDragging, setIsDragging] = useState(false)`
    - On dragenter: increment counter, set isDragging if `e.dataTransfer.types.includes('Files')`
    - On dragleave: decrement counter, clear isDragging if counter reaches 0
    - On dragover: `e.preventDefault()` (required to allow drop)
    - On drop: `e.preventDefault()`, reset counter, clear isDragging, extract files from `e.dataTransfer.files`, convert to FileAttachment (in Electron, `File` objects have a `.path` property for the full filesystem path), add to stagedFiles
    - Show a visual drop overlay when isDragging: semi-transparent overlay with dashed border, "Drop files here" centered text

    c) **Clipboard paste:** In the textarea's onPaste handler (extend existing handler if any), check `e.clipboardData.items` for image types (`item.type.startsWith('image/')`). If found, `e.preventDefault()`, get the file via `item.getAsFile()`. Clipboard-pasted files don't have a `.path` -- write them to a temp file path. The simplest Electron approach: use the existing File object and read it as an ArrayBuffer on the renderer side, convert to base64, and send to main process. OR: create a dedicated IPC handler that accepts base64 data and writes to temp file. For simplicity, have the media.uploadFiles handler accept an optional `dataBase64` field alongside `path` in FileAttachment, so clipboard files can be sent as inline data. Update the FileAttachment type if needed: `{ path?: string; name: string; mimeType: string; dataBase64?: string }`.

    d) **File preview area:** When stagedFiles.length > 0, render a horizontal scroll container (`flex overflow-x-auto gap-2 py-2`) between the textarea and the send button row. Map stagedFiles to `<FilePreview file={f} onRemove={() => remove(f)} />`.

    e) **Modified send flow:** When sending with files:
    - Set uploading = true
    - Subscribe to upload progress: `const cleanup = window.united.media.onUploadProgress((p) => setUploadProgress(p))`
    - Call `window.united.media.uploadFiles({ channelId, content: message, replyToId: replyTo?.id, files: stagedFiles })`
    - On success: clear stagedFiles, clear message text, setUploading(false), setUploadProgress(null), cleanup(), call onMessageSent()
    - On error: setUploading(false), setUploadProgress(null), cleanup(), log error
    - While uploading: show UploadProgress component in place of the file preview area, disable send button and textarea

    f) When stagedFiles is empty and message text exists, use the existing text-only send path (`window.united.chat.send`). When stagedFiles has files, always use the media upload path even if text is empty (message can be files-only).

    **4. Extend MessageRow.tsx:**
    After rendering the message content (MarkdownContent), check if `message.block_refs?.length > 0`.
    If attachments exist:
    - Separate into image attachments: `const images = message.block_refs.filter(r => r.mimeType.startsWith('image/'))`
    - Separate non-image attachments: `const files = message.block_refs.filter(r => !r.mimeType.startsWith('image/'))`
    - Render images: if images.length > 0, render `<ImageGrid images={images} onImageClick={(i) => { setLightboxIndex(i); setLightboxOpen(true); }} />`
    - Render non-images: if files.length > 0, map to `<AttachmentCard filename={f.filename} size={f.size} mimeType={f.mimeType} onDownload={() => handleDownload(f)} />` (for download, resolve the block via IPC and trigger a save dialog or browser download)
    - Layout: images above, non-image cards below. Clean separation, no interleaving (per CONTEXT.md).
    - Lightbox state: `const [lightboxOpen, setLightboxOpen] = useState(false)` and `const [lightboxIndex, setLightboxIndex] = useState(0)`. Render `<Lightbox images={images} open={lightboxOpen} initialIndex={lightboxIndex} onClose={() => setLightboxOpen(false)} />` conditionally.
    - Handle video attachments: videos (`mimeType.startsWith('video/')`) should NOT be in the image grid. Instead render them as `<InlineVideo blockRef={ref} />` between the image grid and file cards.

    Note: The `block_refs` field on ChatMessage may not exist for older messages -- always use optional chaining: `message.block_refs?.length > 0`

    **5. Extend ChatView.tsx (drag-and-drop zone):**
    The drag-and-drop zone should ideally wrap the entire chat view (message list + composer) for a larger drop target. Add drag event handlers at the ChatView level and either:
    - Pass a `onFilesDrop` callback prop to MessageComposer, or
    - Use the same dragCounter pattern at ChatView level and render the drop overlay here
    This depends on the existing ChatView structure -- if ChatView renders MessageComposer directly, add the drag handlers wrapping both. The drop callback should add files to the composer's stagedFiles -- the simplest approach is lifting the stagedFiles state to ChatView level or using a callback prop.
  </action>
  <verify>
    <automated>cd /c/Users/matts/united/client && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>
    MessageComposer has attachment button (paperclip icon), drag-and-drop zone with overlay, and clipboard paste handler. FilePreview shows staged files with remove buttons. UploadProgress shows blocking send progress. MessageRow renders image attachments via ImageGrid, video attachments via InlineVideo, and non-image/video attachments via AttachmentCard. Lightbox opens from any image click with gallery navigation. All three upload input methods work. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` passes in client/
2. Components: `grep -r "InlineImage\|InlineVideo\|ImageGrid\|Lightbox\|BlurhashPlaceholder\|FilePreview\|UploadProgress" client/src/renderer/src/components/ --include="*.tsx" -l` returns all 7 new files
3. MessageComposer: contains attachment button, drag handlers, paste handler, upload progress display
4. MessageRow: contains block_refs rendering with ImageGrid + InlineVideo + AttachmentCard separation
5. Lightbox: uses yet-another-react-lightbox with BlurhashPlaceholder
</verification>

<success_criteria>
- 7 new components created: InlineImage, InlineVideo, BlurhashPlaceholder, ImageGrid, Lightbox, FilePreview, UploadProgress
- MessageComposer extended with attachment button, drag-and-drop, clipboard paste, staged file preview, and blocking send with progress
- MessageRow renders inline images (via ImageGrid), videos (via InlineVideo), and non-media files (via AttachmentCard) from message.block_refs
- InlineImage shows micro-thumbnail while loading, full image when resolved, click opens Lightbox
- InlineVideo shows thumbnail + play overlay, loads video only on user click
- ImageGrid implements 1/2/3/4/5+ adaptive layouts per CONTEXT.md locked decisions
- Lightbox uses blurhash placeholders at full viewport size while full-res loads
- P2P-04 satisfied: StorageSettings (from Phase 6) already allows configuring storage buffer size
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-and-prefetching/07-02-SUMMARY.md`
</output>
