---
phase: 07-media-and-prefetching
plan: 03
type: execute
wave: 2
depends_on:
  - "07-01"
files_modified:
  - client/src/main/blocks/protocol.ts
  - client/src/main/ipc/stats.ts
  - client/src/main/ipc/channels.ts
  - client/src/main/index.ts
  - client/src/preload/index.ts
  - shared/types/ipc-bridge.ts
  - client/src/renderer/src/stores/network.ts
  - client/src/renderer/src/stores/messages.ts
  - client/src/renderer/src/stores/index.ts
  - client/src/renderer/src/hooks/useNetworkStats.ts
  - client/src/renderer/src/hooks/usePrefetch.ts
  - client/src/renderer/src/components/NetworkStats.tsx
  - client/src/renderer/src/components/StatusBarIndicator.tsx
  - client/src/renderer/src/components/ChannelList.tsx
  - client/src/renderer/src/components/MainContent.tsx
  - client/src/renderer/src/components/ChatView.tsx
autonomous: true
requirements:
  - P2P-07
  - P2P-08

must_haves:
  truths:
    - "User can see upload/download totals, seeding ratio, blocks seeded, and storage breakdown by tier in Settings"
    - "User can optionally enable a compact status bar indicator showing upload/download speed"
    - "Hovering a channel in the sidebar prefetches the last 20 messages after 200ms debounce"
    - "App launch prefetches messages for the last-viewed channel and the most active channel"
    - "Scrolling to 70% position in chat triggers prefetch of the next batch of older messages"
    - "Stats are private only -- no public visibility to other users"
  artifacts:
    - path: "client/src/main/ipc/stats.ts"
      provides: "Network stats tracking and IPC handlers"
      exports: ["registerStatsHandlers"]
    - path: "client/src/renderer/src/stores/network.ts"
      provides: "Zustand slice for network stats state"
      exports: ["createNetworkSlice", "NetworkSlice"]
    - path: "client/src/renderer/src/hooks/useNetworkStats.ts"
      provides: "Hook subscribing to network stats push events"
      exports: ["useNetworkStats"]
    - path: "client/src/renderer/src/hooks/usePrefetch.ts"
      provides: "Prefetch hooks for channel hover and scroll position"
      exports: ["usePrefetch"]
    - path: "client/src/renderer/src/components/NetworkStats.tsx"
      provides: "Full seeding stats dashboard in Settings"
    - path: "client/src/renderer/src/components/StatusBarIndicator.tsx"
      provides: "Compact upload/download speed indicator"
    - path: "client/src/renderer/src/components/ChannelList.tsx"
      provides: "Extended with onMouseEnter prefetch trigger"
  key_links:
    - from: "client/src/main/blocks/protocol.ts"
      to: "client/src/main/ipc/stats.ts"
      via: "Reports bytes transferred on block serve/receive"
      pattern: "onBlockServed|onBlockReceived"
    - from: "client/src/renderer/src/components/ChannelList.tsx"
      to: "client/src/renderer/src/hooks/usePrefetch.ts"
      via: "Channel hover triggers prefetch"
      pattern: "usePrefetch|onMouseEnter"
    - from: "client/src/renderer/src/stores/network.ts"
      to: "client/src/renderer/src/components/NetworkStats.tsx"
      via: "Stats store drives dashboard rendering"
      pattern: "useStore.*network"
---

<objective>
Build the seeding stats dashboard with upload/download tracking and the predictive prefetching system for channel hover, scroll position, and app launch.

Purpose: Users can see their contribution to the P2P swarm (private stats only) and experience faster content loading through predictive prefetch on channel hover, scroll-ahead, and app startup.

Output: Network stats tracking (main process), stats dashboard UI (Settings panel), optional status bar indicator, prefetch hooks (channel hover debounced, scroll 70%, app launch), extended ChannelList with hover prefetch.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-media-and-prefetching/07-CONTEXT.md
@.planning/phases/07-media-and-prefetching/07-RESEARCH.md
@.planning/phases/07-media-and-prefetching/07-01-SUMMARY.md
@.planning/phases/06-content-distribution/06-03-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From client/src/main/blocks/protocol.ts:
```typescript
export const BLOCK_PROTOCOL = '/united/block/1.0.0'
export function registerBlockProtocol(node: Libp2p): void
// fetchFromHotPeers and fetchFromPeer functions handle block retrieval
// These are where byte tracking callbacks should be added
```

From client/src/main/blocks/cascade.ts:
```typescript
export async function resolveBlock(hash: string): Promise<Buffer | null>
export async function resolveBlockWithProgress(hash: string, onProgress: Function): Promise<Buffer | null>
```

From client/src/renderer/src/stores/messages.ts:
```typescript
export interface ChannelMessages {
  messages: ChatMessage[];
  hasMoreHistory: boolean;
  isLoading: boolean;
  oldestSequence: number | null;
}
export interface MessagesSlice {
  channelMessages: Record<string, ChannelMessages>
  loadMessages: (channelId: string) => Promise<void>
  loadOlderMessages: (channelId: string) => Promise<void>
  appendMessage: (channelId: string, message: ChatMessage) => void
  // prefetchMessages will be added
}
```

From client/src/renderer/src/stores/settings.ts:
```typescript
// Already has storageBudgetGb, warmTtlDays for block store config
// NetworkStats dashboard will be a separate Settings tab
```

From client/src/renderer/src/components/ChannelList.tsx:
```typescript
// Renders channel items in the sidebar with onClick for channel selection
// Will be extended with onMouseEnter/onMouseLeave for prefetch
function ChannelItem({ channel, isActive, onClick, ... }) { ... }
export default function ChannelList({ ... }) { ... }
```

From client/src/renderer/src/stores/index.ts:
```typescript
export type RootStore = AuthSlice & ConnectionSlice & ServerSlice & ChannelsSlice &
  SettingsSlice & UiSlice & RolesSlice & P2PSlice & MessagesSlice &
  PresenceSlice & NotificationsSlice & DmSlice & BlocksSlice
  // & NetworkSlice will be added
```

From shared/types/ipc-bridge.ts:
```typescript
export interface BlockStorageUsage {
  totalBytes: number;
  byTier: Record<number, number>;
}
```

From client/src/renderer/src/components/MainContent.tsx:
```typescript
// Renders the active panel content based on activePanel state
// StatusBarIndicator will be added conditionally at the bottom
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Network stats tracking, IPC bridge, and seeding dashboard</name>
  <files>
    client/src/main/blocks/protocol.ts
    client/src/main/ipc/stats.ts
    client/src/main/ipc/channels.ts
    client/src/main/index.ts
    client/src/preload/index.ts
    shared/types/ipc-bridge.ts
    client/src/renderer/src/stores/network.ts
    client/src/renderer/src/stores/index.ts
    client/src/renderer/src/hooks/useNetworkStats.ts
    client/src/renderer/src/components/NetworkStats.tsx
    client/src/renderer/src/components/StatusBarIndicator.tsx
    client/src/renderer/src/components/MainContent.tsx
  </files>
  <action>
    **1. Add byte tracking to client/src/main/blocks/protocol.ts:**
    Add module-level counters:
    ```typescript
    let bytesUploaded = 0
    let bytesDownloaded = 0
    let blocksSeeded = 0
    const recentUploads: Array<{ time: number; size: number }> = []
    const recentDownloads: Array<{ time: number; size: number }> = []
    ```
    Export `getNetworkStats()` function that returns: `{ bytesUploaded, bytesDownloaded, blocksSeeded, uploadSpeed, downloadSpeed }` where upload/download speed is calculated from a rolling 10-second window of recentUploads/recentDownloads arrays (filter entries where `Date.now() - entry.time > 10000`, sum remaining sizes, divide by 10).
    In the block protocol handler (where blocks are served to peers via the `/united/block/1.0.0` stream handler), increment `bytesUploaded += data.length` and `blocksSeeded++` and push `{ time: Date.now(), size: data.length }` to recentUploads.
    In the fetch functions (fetchFromPeer, fetchFromHotPeers -- where blocks are received from peers), increment `bytesDownloaded += data.length` and push to recentDownloads.
    Export `resetNetworkStats()` for testing.

    **2. Create client/src/main/ipc/stats.ts:**
    Export `registerStatsHandlers(mainWindow: BrowserWindow)`.
    Register these IPC handlers:
    - `STATS_GET_NETWORK`: Returns current network stats from `getNetworkStats()` in protocol.ts
    - `STATS_GET_STORAGE`: Returns `getStorageUsage()` from blocks/index.ts (already exists)
    Start a 5-second interval that pushes stats to renderer: `mainWindow.webContents.send(IPC.PUSH_NETWORK_STATS, getNetworkStats())`. Guard with `if (!mainWindow.isDestroyed())`. Clean up interval on app quit (store interval ID in module scope, clear on `app.on('before-quit')`).

    **3. Add IPC channel constants to client/src/main/ipc/channels.ts:**
    Add `STATS_GET_NETWORK`, `STATS_GET_STORAGE`, `PUSH_NETWORK_STATS`.

    **4. Register stats handlers in client/src/main/index.ts:**
    Import and call `registerStatsHandlers(mainWindow)` during initialization (after mainWindow is created).

    **5. Extend client/src/preload/index.ts:**
    Add `stats` namespace to the contextBridge exposure:
    ```typescript
    stats: {
      getNetworkStats: () => ipcRenderer.invoke(IPC.STATS_GET_NETWORK),
      getStorageUsage: () => ipcRenderer.invoke(IPC.STATS_GET_STORAGE),
      onNetworkStats: (cb: (stats: NetworkStats) => void) => {
        ipcRenderer.on(IPC.PUSH_NETWORK_STATS, (_e: unknown, data: NetworkStats) => cb(data))
        return () => { ipcRenderer.removeAllListeners(IPC.PUSH_NETWORK_STATS) }
      }
    }
    ```

    **6. Extend shared/types/ipc-bridge.ts:**
    Add `NetworkStats` interface:
    ```typescript
    export interface NetworkStats {
      bytesUploaded: number;    // Cumulative
      bytesDownloaded: number;  // Cumulative
      blocksSeeded: number;     // Total blocks served to peers
      uploadSpeed: number;      // Bytes/sec (rolling 10s window)
      downloadSpeed: number;    // Bytes/sec (rolling 10s window)
    }
    ```
    Add `stats` namespace to UnitedAPI:
    ```typescript
    stats: {
      getNetworkStats(): Promise<NetworkStats>;
      getStorageUsage(): Promise<BlockStorageUsage>;
      onNetworkStats(callback: (stats: NetworkStats) => void): () => void;
    }
    ```

    **7. Create client/src/renderer/src/stores/network.ts:**
    Zustand slice (StateCreator pattern matching existing slices):
    ```typescript
    export interface NetworkSlice {
      networkStats: NetworkStats | null;
      showStatusBar: boolean;
      setNetworkStats: (stats: NetworkStats) => void;
      toggleStatusBar: () => void;
    }
    ```
    Initialize showStatusBar from localStorage key `'united-show-status-bar'` (parse as boolean, default false per CONTEXT.md). On toggleStatusBar, persist to localStorage.

    **8. Add NetworkSlice to client/src/renderer/src/stores/index.ts:**
    Import createNetworkSlice and NetworkSlice. Add to RootStore type union. Spread into the create call.

    **9. Create client/src/renderer/src/hooks/useNetworkStats.ts:**
    Hook that subscribes to `window.united.stats.onNetworkStats` on mount, calls `store.setNetworkStats(stats)` to update store, returns cleanup on unmount. Also fetch initial stats on mount via `window.united.stats.getNetworkStats()` and set into store.

    **10. Create client/src/renderer/src/components/NetworkStats.tsx:**
    Full stats dashboard panel for Settings. Dark theme, consistent with existing settings panels (StorageSettings pattern).
    Display:
    - **Upload/Download totals:** Format as human-readable (B/KB/MB/GB) with cumulative values. Two rows or side-by-side cards.
    - **Seeding ratio:** upload:download formatted to 2 decimal places (e.g., "1.25:1"). Handle zero-download case: show "-- : 1" or "N/A".
    - **Blocks seeded:** Plain count with label
    - **Storage breakdown by tier:** Visual bar similar to StorageSettings. Fetch storage usage on mount via `window.united.stats.getStorageUsage()`. Display tier segments: P1 Never-evict (blue), P2 Hot (green), P3 Warm (yellow), P4 Altruistic (purple), free (dark gray). Show budget total vs used.
    - **Status bar toggle:** Checkbox/toggle: "Show network activity in status bar" controlling `toggleStatusBar()` in network store. Off by default.
    - Stats are private only per CONTEXT.md -- no public visibility indicator needed.

    **11. Create client/src/renderer/src/components/StatusBarIndicator.tsx:**
    Compact indicator rendered at bottom of main content area:
    - Height: ~24px, subtle background
    - Show up arrow (green, unicode or SVG) with upload speed and down arrow (blue) with download speed
    - Format speed: B/s for <1KB, KB/s for <1MB, MB/s for >=1MB
    - Only renders when `showStatusBar` is true in network store
    - Use `useStore(s => s.networkStats)` to read current speeds

    **12. Extend client/src/renderer/src/components/MainContent.tsx:**
    - Add `useNetworkStats()` hook call at the top level (subscribes to stats push events)
    - Add 'network-stats' to the activePanel switch/case for rendering `<NetworkStats />` in the Settings area
    - Render `<StatusBarIndicator />` at the bottom of the layout when `useStore(s => s.showStatusBar)` is true. Position it below the main content but above any bottom bar.
  </action>
  <verify>
    <automated>cd /c/Users/matts/united/client && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>
    Network stats tracked in protocol.ts (bytes uploaded/downloaded, blocks seeded, rolling 10s speed window). Stats IPC pushes every 5s to renderer. NetworkStats dashboard shows totals, seeding ratio, blocks seeded, storage tier breakdown, and status bar toggle. StatusBarIndicator shows optional compact speed display. Stats are private only. TypeScript compiles clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Predictive prefetching -- channel hover, scroll position, app launch</name>
  <files>
    client/src/renderer/src/hooks/usePrefetch.ts
    client/src/renderer/src/stores/messages.ts
    client/src/renderer/src/components/ChannelList.tsx
    client/src/renderer/src/components/ChatView.tsx
  </files>
  <action>
    **1. Extend client/src/renderer/src/stores/messages.ts:**
    Add a `prefetchMessages` action to MessagesSlice:
    ```typescript
    prefetchMessages: (channelId: string, messages: ChatMessage[]) => void
    ```
    Implementation: only populate if the channel does NOT already have messages loaded (don't overwrite live data). Use the existing `emptyChannelMessages()` pattern, set messages and hasMoreHistory to true. This is a silent background population -- no loading state changes in the UI.

    Add a `prefetchedChannels` Set to track which channels have been prefetched this session:
    ```typescript
    prefetchedChannels: Set<string>
    ```
    Initialize as `new Set()`. The prefetchMessages action adds the channelId to this set after populating.

    **2. Create client/src/renderer/src/hooks/usePrefetch.ts:**
    Export `usePrefetch()` hook that returns:
    ```typescript
    {
      prefetchOnHover: (channelId: string) => void,
      cancelPrefetch: () => void,
    }
    ```

    a) **prefetchOnHover(channelId):**
    - Uses a ref `prefetchTimeoutRef` for a 200ms debounce timeout
    - On call: clear any existing timeout, set new 200ms timeout
    - After 200ms: check if channel already has messages in store (`channelMessages[channelId]?.messages.length > 0`) OR is in prefetchedChannels set. If either, skip.
    - If not loaded: call `window.united.chat.fetchHistory(channelId, undefined, 20)` silently (no UI loading state)
    - On success: call `useStore.getState().prefetchMessages(channelId, result.messages)`
    - On failure: silently ignore (`.catch(() => {})`)
    - IMPORTANT: Only prefetch text + metadata. Full media loads on demand per CONTEXT.md locked decision.

    b) **cancelPrefetch():**
    - Clear the debounce timeout ref
    - Call this on mouseLeave to cancel in-flight prefetch

    **3. App launch prefetch logic:**
    Create a `useAppLaunchPrefetch()` hook (or include in usePrefetch):
    - Run once on mount (empty dependency `useEffect`):
      - Get last-viewed channel: check `window.united.storage.getCachedChannels()` or `useStore.getState().channelMessages` for the most recently viewed channel. Alternatively, persist `lastViewedChannelId` to localStorage on channel switch and read here.
      - Get most active channel: look at channels list, pick the one with the highest server_sequence or just default to the first channel (typically #general). Another approach: pick the channel with the most unread messages.
      - For each (up to 2): if not already loaded, call `window.united.chat.fetchHistory(channelId, undefined, 20)` and `prefetchMessages()`
    - This runs once on app startup, not on every re-render. Use a module-level flag or ref to prevent double execution in React Strict Mode.

    **4. Extend client/src/renderer/src/components/ChannelList.tsx:**
    Import and use `usePrefetch()` hook at the ChannelList component level.
    For each channel list item (the ChannelItem component or the clickable element):
    - Add `onMouseEnter={() => prefetchOnHover(channel.id)}`
    - Add `onMouseLeave={() => cancelPrefetch()}`
    These handlers trigger the 200ms-debounced prefetch. Moving quickly across channels cancels intermediate fetches (per Research Pitfall 6 -- prevents burst of API calls).

    **5. Extend client/src/renderer/src/components/ChatView.tsx:**
    Add scroll-based prefetching:
    - Track scroll position in the message list container. The ChatView likely uses @tanstack/react-virtual with a scrollable ref.
    - On scroll events: calculate scroll percentage. For a virtualizer scrolling upward through history: check if the user has scrolled past 70% of loaded content (or if the virtualizer reports the first visible item is within 30% of the top of loaded messages).
    - When the 70% threshold is hit: call `useStore.getState().loadOlderMessages(channelId)` which already exists and fetches the next page of history. This is text + metadata only.
    - Debounce the scroll handler: use a ref to prevent calling loadOlderMessages more than once per 2 seconds.

    Also wire the app launch prefetch: call `useAppLaunchPrefetch()` hook in ChatView or in a parent component (Main.tsx) that mounts once on app load.
  </action>
  <verify>
    <automated>cd /c/Users/matts/united/client && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>
    Channel hover prefetches last 20 messages after 200ms debounce, skips if already loaded. App launch prefetches last-viewed + most active channel on startup. Scroll at 70% triggers loading older messages. All prefetching is text + metadata only (no full media per CONTEXT.md). prefetchedChannels set prevents redundant fetches. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. TypeScript: `npx tsc --noEmit` passes in client/
2. Stats: `grep -r "bytesUploaded\|bytesDownloaded\|blocksSeeded" client/src/main/blocks/protocol.ts` shows tracking code
3. Dashboard: `grep -r "NetworkStats" client/src/renderer/src/components/ -l` returns NetworkStats.tsx
4. Prefetch: `grep -r "onMouseEnter.*prefetch\|prefetchOnHover" client/src/renderer/src/components/ChannelList.tsx` shows hover handler
5. Store: `grep -r "prefetchMessages\|prefetchedChannels" client/src/renderer/src/stores/messages.ts` shows prefetch state
</verification>

<success_criteria>
- Network stats tracked: bytesUploaded, bytesDownloaded, blocksSeeded, rolling upload/download speed
- Stats IPC: main process pushes stats every 5s, renderer subscribes
- NetworkStats dashboard in Settings: totals, ratio, blocks seeded, storage tier breakdown, status bar toggle
- StatusBarIndicator: compact optional indicator off by default, shows upload/download speed when enabled
- Channel hover prefetch: 200ms debounce, 20 messages, skips already-loaded channels, silent failure
- App launch prefetch: last-viewed + most active channel on startup
- Scroll prefetch: 70% scroll position triggers loadOlderMessages
- All prefetching is text + metadata only (no full media) per CONTEXT.md
- Stats are private only -- no public visibility per social trust architecture
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-media-and-prefetching/07-03-SUMMARY.md`
</output>
