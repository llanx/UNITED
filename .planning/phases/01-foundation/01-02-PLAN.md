---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - server/src/main.rs
  - server/src/config.rs
  - server/src/db/mod.rs
  - server/src/db/migrations.rs
  - server/src/db/models.rs
  - server/src/auth/mod.rs
  - server/src/auth/challenge.rs
  - server/src/auth/jwt.rs
  - server/src/auth/middleware.rs
  - server/src/identity/mod.rs
  - server/src/identity/registration.rs
  - server/src/admin/mod.rs
  - server/src/admin/setup.rs
  - server/src/admin/settings.rs
  - server/src/routes.rs
autonomous: true
requirements: [SEC-01, SEC-02, SRVR-07]

must_haves:
  truths:
    - "Server starts and listens on configured port (default 1984)"
    - "Challenge-response auth flow works end-to-end"
    - "JWT tokens are issued and validated correctly"
    - "First user with setup token becomes server owner"
    - "Server settings are readable publicly and writable by admin"
    - "Rate limiting rejects rapid auth requests"
  artifacts:
    - path: "server/src/main.rs"
      provides: "Server entry point with config, DB, and route setup"
      contains: "tokio::main"
    - path: "server/src/config.rs"
      provides: "Config loading from TOML + env + CLI"
      contains: "figment"
    - path: "server/src/auth/challenge.rs"
      provides: "Challenge-response auth endpoint"
      contains: "ChallengeRequest"
    - path: "server/src/auth/jwt.rs"
      provides: "JWT issuance and validation with HS256"
      contains: "jsonwebtoken"
    - path: "server/src/identity/registration.rs"
      provides: "User registration with Ed25519 public key"
      contains: "RegisterRequest"
    - path: "server/src/admin/setup.rs"
      provides: "Setup token generation and admin bootstrap"
      contains: "setup_token"
  key_links:
    - from: "server/src/routes.rs"
      to: "server/src/auth/*"
      via: "route registration"
      pattern: "Router::new"
    - from: "server/src/auth/middleware.rs"
      to: "server/src/auth/jwt.rs"
      via: "token validation extractor"
      pattern: "FromRequestParts"
    - from: "server/src/identity/registration.rs"
      to: "server/src/db/models.rs"
      via: "user creation + blob storage"
      pattern: "insert_user"
---

<objective>
Build the Rust coordination server foundation: config system, SQLite database with full schema, challenge-response authentication, JWT issuance/validation, user registration, server settings CRUD, and rate limiting on auth endpoints.

Purpose: Deliver a working server that accepts Ed25519 identity registration and challenge-response authentication.
Output: Server binary that starts on port 1984, accepts auth requests, issues JWTs, and manages server settings.
</objective>

<execution_context>
@C:/Users/matts/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/matts/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/IDENTITY-ARCHITECTURE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config system, SQLite, and server entry point</name>
  <files>server/src/main.rs, server/src/config.rs, server/src/db/mod.rs, server/src/db/migrations.rs, server/src/db/models.rs, server/src/admin/setup.rs, server/src/admin/settings.rs, server/src/routes.rs</files>
  <action>
Implement config.rs using figment: layer defaults &lt; TOML file (united.toml) &lt; env vars (UNITED_*) &lt; CLI args (clap derive). Config struct: port (default 1984), bind_address (default 0.0.0.0), config_path, json_logs flag, generate_config flag, data_dir, jwt_secret_path, registration_mode (open/invite-only).

Implement main.rs: parse CLI (clap), load config (figment), initialize tracing (pretty-print default, JSON if --json-logs), initialize SQLite database, generate JWT signing key on first boot (256-bit random, stored in data_dir), handle --generate-config (print commented TOML template and exit), start axum server.

Implement db/migrations.rs with rusqlite_migration: full schema (users, identity_blobs, rotation_records, refresh_tokens, server_settings, challenges tables with indexes).

Implement db/models.rs: Row structs for all tables.

Implement admin/setup.rs: On first boot (no users), generate setup token (32-byte random, hex-encoded), print to console. Store hashed token in server_settings. First identity presenting valid setup token becomes owner.

Implement admin/settings.rs: GET /api/server/info (public), PUT /api/server/settings (admin-only). Default server name = hostname, no icon, no description. Settings stored in server_settings table.

Assemble initial routes.rs with axum Router.
  </action>
  <verify>cargo build compiles. cargo run -- --generate-config outputs TOML. Server starts on port 1984 and responds to GET /api/server/info.</verify>
  <done>Server boots, prints setup token, serves server info endpoint, SQLite schema applied.</done>
</task>

<task type="auto">
  <name>Task 2: Challenge-response auth, JWT, registration, rate limiting</name>
  <files>server/src/auth/challenge.rs, server/src/auth/jwt.rs, server/src/auth/middleware.rs, server/src/identity/registration.rs, server/src/routes.rs</files>
  <action>
Implement auth/challenge.rs: POST /api/auth/challenge — generate 32-byte random challenge, store with UUIDv7 ID and 60-second expiry, return challenge_id + challenge_bytes. Challenge store: in-memory DashMap with periodic cleanup.

Implement auth/jwt.rs: JWT issuance with HS256 (256-bit random key from first boot). Access token: 15-min expiry, claims = {sub: user_id, fingerprint, roles, iat, exp}. Refresh token: 7-day expiry, stored as SHA-256 hash in refresh_tokens table. POST /api/auth/refresh: validate refresh token, issue new pair, delete old (rotation).

Implement auth/middleware.rs: Axum extractor validating JWT from Authorization: Bearer header, extracting claims. Return 401 for invalid/expired.

Implement identity/registration.rs: POST /api/auth/register — accept public_key, fingerprint, display_name, encrypted_blob. Verify display name uniqueness. Create user record + genesis rotation record + store encrypted blob. If setup token provided, make user owner. Issue JWT tokens.

Implement POST /api/auth/verify: consume challenge, verify Ed25519 signature with ed25519-dalek, look up user by fingerprint, issue JWT.

Implement rate limiting: tower-governor middleware on auth endpoints (5 attempts per minute per IP per user decision).

Update routes.rs with all new routes and middleware layers (rate limiting, CORS, tracing).
  </action>
  <verify>cargo test passes. curl: POST /api/auth/challenge returns challenge. POST /api/auth/verify with valid signature returns JWT. POST /api/auth/register creates user. Rate limiting rejects >5 rapid requests.</verify>
  <done>Full auth flow works: challenge → verify → JWT. Registration creates users. Admin bootstrap via setup token works. Rate limiting enforced.</done>
</task>

</tasks>

<verification>
- cargo build and cargo test pass
- Server starts on port 1984 with setup token printed
- Challenge-response auth flow works end-to-end via curl
- JWT access + refresh tokens are issued and refresh works
- Display name uniqueness enforced
- Server info endpoint returns settings
- Admin can update server settings with valid JWT
- Rate limiting blocks rapid auth attempts
</verification>

<success_criteria>
- Server binary runs and accepts connections
- Ed25519 challenge-response authentication completes successfully
- JWT tokens with correct claims are issued
- Setup token admin bootstrap works on first boot
- Server settings CRUD works for admin users
</success_criteria>

<output>
Create `.planning/phases/01-foundation/01-02-SUMMARY.md` with accomplishments, commits, and metrics.
</output>
